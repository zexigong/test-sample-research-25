messages:
- content: You are an AI agent expert in writing unit tests. Your task is to write
    unit tests for the given code files of the repository. Make sure the tests can
    be executed without lint or compile errors.
  role: system
- content: "### Task Information\nBased on the source code, write/rewrite tests to\
    \ cover the source code.\nRepository: rich\nTest File Path: rich\\test_file_proxy\\\
    test_file_proxy.py\nProject Programming Language: Python\nTesting Framework: pytest\n\
    ### Source File Content\n### Source File Content:\nimport io\nfrom typing import\
    \ IO, TYPE_CHECKING, Any, List\n\nfrom .ansi import AnsiDecoder\nfrom .text import\
    \ Text\n\nif TYPE_CHECKING:\n    from .console import Console\n\n\nclass FileProxy(io.TextIOBase):\n\
    \    \"\"\"Wraps a file (e.g. sys.stdout) and redirects writes to a console.\"\
    \"\"\n\n    def __init__(self, console: \"Console\", file: IO[str]) -> None:\n\
    \        self.__console = console\n        self.__file = file\n        self.__buffer:\
    \ List[str] = []\n        self.__ansi_decoder = AnsiDecoder()\n\n    @property\n\
    \    def rich_proxied_file(self) -> IO[str]:\n        \"\"\"Get proxied file.\"\
    \"\"\n        return self.__file\n\n    def __getattr__(self, name: str) -> Any:\n\
    \        return getattr(self.__file, name)\n\n    def write(self, text: str) ->\
    \ int:\n        if not isinstance(text, str):\n            raise TypeError(f\"\
    write() argument must be str, not {type(text).__name__}\")\n        buffer = self.__buffer\n\
    \        lines: List[str] = []\n        while text:\n            line, new_line,\
    \ text = text.partition(\"\\n\")\n            if new_line:\n                lines.append(\"\
    \".join(buffer) + line)\n                buffer.clear()\n            else:\n \
    \               buffer.append(line)\n                break\n        if lines:\n\
    \            console = self.__console\n            with console:\n           \
    \     output = Text(\"\\n\").join(\n                    self.__ansi_decoder.decode_line(line)\
    \ for line in lines\n                )\n                console.print(output)\n\
    \        return len(text)\n\n    def flush(self) -> None:\n        output = \"\
    \".join(self.__buffer)\n        if output:\n            self.__console.print(output)\n\
    \        del self.__buffer[:]\n\n    def fileno(self) -> int:\n        return\
    \ self.__file.fileno()\n\n### Source File Dependency Files Content\n### Dependency\
    \ File: ansi.py\nimport re\nimport sys\nfrom contextlib import suppress\nfrom\
    \ typing import Iterable, NamedTuple, Optional\n\nfrom .color import Color\nfrom\
    \ .style import Style\nfrom .text import Text\n\nre_ansi = re.compile(\n    r\"\
    \"\"\n(?:\\x1b[0-?])|\n(?:\\x1b\\](.*?)\\x1b\\\\)|\n(?:\\x1b([(@-Z\\\\-_]|\\[[0-?]*[\
    \ -/]*[@-~]))\n\"\"\",\n    re.VERBOSE,\n)\n\n\nclass _AnsiToken(NamedTuple):\n\
    \    \"\"\"Result of ansi tokenized string.\"\"\"\n\n    plain: str = \"\"\n \
    \   sgr: Optional[str] = \"\"\n    osc: Optional[str] = \"\"\n\n\ndef _ansi_tokenize(ansi_text:\
    \ str) -> Iterable[_AnsiToken]:\n    \"\"\"Tokenize a string in to plain text\
    \ and ANSI codes.\n\n    Args:\n        ansi_text (str): A String containing ANSI\
    \ codes.\n\n    Yields:\n        AnsiToken: A named tuple of (plain, sgr, osc)\n\
    \    \"\"\"\n\n    position = 0\n    sgr: Optional[str]\n    osc: Optional[str]\n\
    \    for match in re_ansi.finditer(ansi_text):\n        start, end = match.span(0)\n\
    \        osc, sgr = match.groups()\n        if start > position:\n           \
    \ yield _AnsiToken(ansi_text[position:start])\n        if sgr:\n            if\
    \ sgr == \"(\":\n                position = end + 1\n                continue\n\
    \            if sgr.endswith(\"m\"):\n                yield _AnsiToken(\"\", sgr[1:-1],\
    \ osc)\n        else:\n            yield _AnsiToken(\"\", sgr, osc)\n        position\
    \ = end\n    if position < len(ansi_text):\n        yield _AnsiToken(ansi_text[position:])\n\
    \n\nSGR_STYLE_MAP = {\n    1: \"bold\",\n    2: \"dim\",\n    3: \"italic\",\n\
    \    4: \"underline\",\n    5: \"blink\",\n    6: \"blink2\",\n    7: \"reverse\"\
    ,\n    8: \"conceal\",\n    9: \"strike\",\n    21: \"underline2\",\n    22: \"\
    not dim not bold\",\n    23: \"not italic\",\n    24: \"not underline\",\n   \
    \ 25: \"not blink\",\n    26: \"not blink2\",\n    27: \"not reverse\",\n    28:\
    \ \"not conceal\",\n    29: \"not strike\",\n    30: \"color(0)\",\n    31: \"\
    color(1)\",\n    32: \"color(2)\",\n    33: \"color(3)\",\n    34: \"color(4)\"\
    ,\n    35: \"color(5)\",\n    36: \"color(6)\",\n    37: \"color(7)\",\n    39:\
    \ \"default\",\n    40: \"on color(0)\",\n    41: \"on color(1)\",\n    42: \"\
    on color(2)\",\n    43: \"on color(3)\",\n    44: \"on color(4)\",\n    45: \"\
    on color(5)\",\n    46: \"on color(6)\",\n    47: \"on color(7)\",\n    49: \"\
    on default\",\n    51: \"frame\",\n    52: \"encircle\",\n    53: \"overline\"\
    ,\n    54: \"not frame not encircle\",\n    55: \"not overline\",\n    90: \"\
    color(8)\",\n    91: \"color(9)\",\n    92: \"color(10)\",\n    93: \"color(11)\"\
    ,\n    94: \"color(12)\",\n    95: \"color(13)\",\n    96: \"color(14)\",\n  \
    \  97: \"color(15)\",\n    100: \"on color(8)\",\n    101: \"on color(9)\",\n\
    \    102: \"on color(10)\",\n    103: \"on color(11)\",\n    104: \"on color(12)\"\
    ,\n    105: \"on color(13)\",\n    106: \"on color(14)\",\n    107: \"on color(15)\"\
    ,\n}\n\n\nclass AnsiDecoder:\n    \"\"\"Translate ANSI code in to styled Text.\"\
    \"\"\n\n    def __init__(self) -> None:\n        self.style = Style.null()\n\n\
    \    def decode(self, terminal_text: str) -> Iterable[Text]:\n        \"\"\"Decode\
    \ ANSI codes in an iterable of lines.\n\n        Args:\n            lines (Iterable[str]):\
    \ An iterable of lines of terminal output.\n\n        Yields:\n            Text:\
    \ Marked up Text.\n        \"\"\"\n        for line in terminal_text.splitlines():\n\
    \            yield self.decode_line(line)\n\n    def decode_line(self, line: str)\
    \ -> Text:\n        \"\"\"Decode a line containing ansi codes.\n\n        Args:\n\
    \            line (str): A line of terminal output.\n\n        Returns:\n    \
    \        Text: A Text instance marked up according to ansi codes.\n        \"\"\
    \"\n        from_ansi = Color.from_ansi\n        from_rgb = Color.from_rgb\n \
    \       _Style = Style\n        text = Text()\n        append = text.append\n\
    \        line = line.rsplit(\"\\r\", 1)[-1]\n        for plain_text, sgr, osc\
    \ in _ansi_tokenize(line):\n            if plain_text:\n                append(plain_text,\
    \ self.style or None)\n            elif osc is not None:\n                if osc.startswith(\"\
    8;\"):\n                    _params, semicolon, link = osc[2:].partition(\";\"\
    )\n                    if semicolon:\n                        self.style = self.style.update_link(link\
    \ or None)\n            elif sgr is not None:\n                # Translate in\
    \ to semi-colon separated codes\n                # Ignore invalid codes, because\
    \ we want to be lenient\n                codes = [\n                    min(255,\
    \ int(_code) if _code else 0)\n                    for _code in sgr.split(\";\"\
    )\n                    if _code.isdigit() or _code == \"\"\n                ]\n\
    \                iter_codes = iter(codes)\n                for code in iter_codes:\n\
    \                    if code == 0:\n                        # reset\n        \
    \                self.style = _Style.null()\n                    elif code in\
    \ SGR_STYLE_MAP:\n                        # styles\n                        self.style\
    \ += _Style.parse(SGR_STYLE_MAP[code])\n                    elif code == 38:\n\
    \                        # Â Foreground\n                        with suppress(StopIteration):\n\
    \                            color_type = next(iter_codes)\n                 \
    \           if color_type == 5:\n                                self.style +=\
    \ _Style.from_color(\n                                    from_ansi(next(iter_codes))\n\
    \                                )\n                            elif color_type\
    \ == 2:\n                                self.style += _Style.from_color(\n  \
    \                                  from_rgb(\n                               \
    \         next(iter_codes),\n                                        next(iter_codes),\n\
    \                                        next(iter_codes),\n                 \
    \                   )\n                                )\n                   \
    \ elif code == 48:\n                        # Background\n                   \
    \     with suppress(StopIteration):\n                            color_type =\
    \ next(iter_codes)\n                            if color_type == 5:\n        \
    \                        self.style += _Style.from_color(\n                  \
    \                  None, from_ansi(next(iter_codes))\n                       \
    \         )\n                            elif color_type == 2:\n             \
    \                   self.style += _Style.from_color(\n                       \
    \             None,\n                                    from_rgb(\n         \
    \                               next(iter_codes),\n                          \
    \              next(iter_codes),\n                                        next(iter_codes),\n\
    \                                    ),\n                                )\n\n\
    \        return text\n\n\nif sys.platform != \"win32\" and __name__ == \"__main__\"\
    :  # pragma: no cover\n    import io\n    import os\n    import pty\n    import\
    \ sys\n\n    decoder = AnsiDecoder()\n\n    stdout = io.BytesIO()\n\n    def read(fd:\
    \ int) -> bytes:\n        data = os.read(fd, 1024)\n        stdout.write(data)\n\
    \        return data\n\n    pty.spawn(sys.argv[1:], read)\n\n    from .console\
    \ import Console\n\n    console = Console(record=True)\n\n    stdout_result =\
    \ stdout.getvalue().decode(\"utf-8\")\n    print(stdout_result)\n\n    for line\
    \ in decoder.decode(stdout_result):\n        console.print(line)\n\n    console.save_html(\"\
    stdout.html\")\n\n\n### Dependency File: console.py\nimport inspect\nimport os\n\
    import sys\nimport threading\nimport zlib\nfrom abc import ABC, abstractmethod\n\
    from dataclasses import dataclass, field\nfrom datetime import datetime\nfrom\
    \ functools import wraps\nfrom getpass import getpass\nfrom html import escape\n\
    from inspect import isclass\nfrom itertools import islice\nfrom math import ceil\n\
    from time import monotonic\nfrom types import FrameType, ModuleType, TracebackType\n\
    from typing import (\n    IO,\n    TYPE_CHECKING,\n    Any,\n    Callable,\n \
    \   Dict,\n    Iterable,\n    List,\n    Mapping,\n    NamedTuple,\n    Optional,\n\
    \    TextIO,\n    Tuple,\n    Type,\n    Union,\n    cast,\n)\n\nfrom rich._null_file\
    \ import NULL_FILE\n\nif sys.version_info >= (3, 8):\n    from typing import Literal,\
    \ Protocol, runtime_checkable\nelse:\n    from typing_extensions import (\n  \
    \      Literal,\n        Protocol,\n        runtime_checkable,\n    )  # pragma:\
    \ no cover\n\nfrom . import errors, themes\nfrom ._emoji_replace import _emoji_replace\n\
    from ._export_format import CONSOLE_HTML_FORMAT, CONSOLE_SVG_FORMAT\nfrom ._fileno\
    \ import get_fileno\nfrom ._log_render import FormatTimeCallable, LogRender\n\
    from .align import Align, AlignMethod\nfrom .color import ColorSystem, blend_rgb\n\
    from .control import Control\nfrom .emoji import EmojiVariant\nfrom .highlighter\
    \ import NullHighlighter, ReprHighlighter\nfrom .markup import render as render_markup\n\
    from .measure import Measurement, measure_renderables\nfrom .pager import Pager,\
    \ SystemPager\nfrom .pretty import Pretty, is_expandable\nfrom .protocol import\
    \ rich_cast\nfrom .region import Region\nfrom .scope import render_scope\nfrom\
    \ .screen import Screen\nfrom .segment import Segment\nfrom .style import Style,\
    \ StyleType\nfrom .styled import Styled\nfrom .terminal_theme import DEFAULT_TERMINAL_THEME,\
    \ SVG_EXPORT_THEME, TerminalTheme\nfrom .text import Text, TextType\nfrom .theme\
    \ import Theme, ThemeStack\n\nif TYPE_CHECKING:\n    from ._windows import WindowsConsoleFeatures\n\
    \    from .live import Live\n    from .status import Status\n\nJUPYTER_DEFAULT_COLUMNS\
    \ = 115\nJUPYTER_DEFAULT_LINES = 100\nWINDOWS = sys.platform == \"win32\"\n\n\
    HighlighterType = Callable[[Union[str, \"Text\"]], \"Text\"]\nJustifyMethod =\
    \ Literal[\"default\", \"left\", \"center\", \"right\", \"full\"]\nOverflowMethod\
    \ = Literal[\"fold\", \"crop\", \"ellipsis\", \"ignore\"]\n\n\nclass NoChange:\n\
    \    pass\n\n\nNO_CHANGE = NoChange()\n\ntry:\n    _STDIN_FILENO = sys.__stdin__.fileno()\
    \  # type: ignore[union-attr]\nexcept Exception:\n    _STDIN_FILENO = 0\ntry:\n\
    \    _STDOUT_FILENO = sys.__stdout__.fileno()  # type: ignore[union-attr]\nexcept\
    \ Exception:\n    _STDOUT_FILENO = 1\ntry:\n    _STDERR_FILENO = sys.__stderr__.fileno()\
    \  # type: ignore[union-attr]\nexcept Exception:\n    _STDERR_FILENO = 2\n\n_STD_STREAMS\
    \ = (_STDIN_FILENO, _STDOUT_FILENO, _STDERR_FILENO)\n_STD_STREAMS_OUTPUT = (_STDOUT_FILENO,\
    \ _STDERR_FILENO)\n\n\n_TERM_COLORS = {\n    \"kitty\": ColorSystem.EIGHT_BIT,\n\
    \    \"256color\": ColorSystem.EIGHT_BIT,\n    \"16color\": ColorSystem.STANDARD,\n\
    }\n\n\nclass ConsoleDimensions(NamedTuple):\n    \"\"\"Size of the terminal.\"\
    \"\"\n\n    width: int\n    \"\"\"The width of the console in 'cells'.\"\"\"\n\
    \    height: int\n    \"\"\"The height of the console in lines.\"\"\"\n\n\n@dataclass\n\
    class ConsoleOptions:\n    \"\"\"Options for __rich_console__ method.\"\"\"\n\n\
    \    size: ConsoleDimensions\n    \"\"\"Size of console.\"\"\"\n    legacy_windows:\
    \ bool\n    \"\"\"legacy_windows: flag for legacy windows.\"\"\"\n    min_width:\
    \ int\n    \"\"\"Minimum width of renderable.\"\"\"\n    max_width: int\n    \"\
    \"\"Maximum width of renderable.\"\"\"\n    is_terminal: bool\n    \"\"\"True\
    \ if the target is a terminal, otherwise False.\"\"\"\n    encoding: str\n   \
    \ \"\"\"Encoding of terminal.\"\"\"\n    max_height: int\n    \"\"\"Height of\
    \ container (starts as terminal)\"\"\"\n    justify: Optional[JustifyMethod] =\
    \ None\n    \"\"\"Justify value override for renderable.\"\"\"\n    overflow:\
    \ Optional[OverflowMethod] = None\n    \"\"\"Overflow value override for renderable.\"\
    \"\"\n    no_wrap: Optional[bool] = False\n    \"\"\"Disable wrapping for text.\"\
    \"\"\n    highlight: Optional[bool] = None\n    \"\"\"Highlight override for render_str.\"\
    \"\"\n    markup: Optional[bool] = None\n    \"\"\"Enable markup when rendering\
    \ strings.\"\"\"\n    height: Optional[int] = None\n\n    @property\n    def ascii_only(self)\
    \ -> bool:\n        \"\"\"Check if renderables should use ascii only.\"\"\"\n\
    \        return not self.encoding.startswith(\"utf\")\n\n    def copy(self) ->\
    \ \"ConsoleOptions\":\n        \"\"\"Return a copy of the options.\n\n       \
    \ Returns:\n            ConsoleOptions: a copy of self.\n        \"\"\"\n    \
    \    options: ConsoleOptions = ConsoleOptions.__new__(ConsoleOptions)\n      \
    \  options.__dict__ = self.__dict__.copy()\n        return options\n\n    def\
    \ update(\n        self,\n        *,\n        width: Union[int, NoChange] = NO_CHANGE,\n\
    \        min_width: Union[int, NoChange] = NO_CHANGE,\n        max_width: Union[int,\
    \ NoChange] = NO_CHANGE,\n        justify: Union[Optional[JustifyMethod], NoChange]\
    \ = NO_CHANGE,\n        overflow: Union[Optional[OverflowMethod], NoChange] =\
    \ NO_CHANGE,\n        no_wrap: Union[Optional[bool], NoChange] = NO_CHANGE,\n\
    \        highlight: Union[Optional[bool], NoChange] = NO_CHANGE,\n        markup:\
    \ Union[Optional[bool], NoChange] = NO_CHANGE,\n        height: Union[Optional[int],\
    \ NoChange] = NO_CHANGE,\n    ) -> \"ConsoleOptions\":\n        \"\"\"Update values,\
    \ return a copy.\"\"\"\n        options = self.copy()\n        if not isinstance(width,\
    \ NoChange):\n            options.min_width = options.max_width = max(0, width)\n\
    \        if not isinstance(min_width, NoChange):\n            options.min_width\
    \ = min_width\n        if not isinstance(max_width, NoChange):\n            options.max_width\
    \ = max_width\n        if not isinstance(justify, NoChange):\n            options.justify\
    \ = justify\n        if not isinstance(overflow, NoChange):\n            options.overflow\
    \ = overflow\n        if not isinstance(no_wrap, NoChange):\n            options.no_wrap\
    \ = no_wrap\n        if not isinstance(highlight, NoChange):\n            options.highlight\
    \ = highlight\n        if not isinstance(markup, NoChange):\n            options.markup\
    \ = markup\n        if not isinstance(height, NoChange):\n            if height\
    \ is not None:\n                options.max_height = height\n            options.height\
    \ = None if height is None else max(0, height)\n        return options\n\n   \
    \ def update_width(self, width: int) -> \"ConsoleOptions\":\n        \"\"\"Update\
    \ just the width, return a copy.\n\n        Args:\n            width (int): New\
    \ width (sets both min_width and max_width)\n\n        Returns:\n            ~ConsoleOptions:\
    \ New console options instance.\n        \"\"\"\n        options = self.copy()\n\
    \        options.min_width = options.max_width = max(0, width)\n        return\
    \ options\n\n    def update_height(self, height: int) -> \"ConsoleOptions\":\n\
    \        \"\"\"Update the height, and return a copy.\n\n        Args:\n      \
    \      height (int): New height\n\n        Returns:\n            ~ConsoleOptions:\
    \ New Console options instance.\n        \"\"\"\n        options = self.copy()\n\
    \        options.max_height = options.height = height\n        return options\n\
    \n    def reset_height(self) -> \"ConsoleOptions\":\n        \"\"\"Return a copy\
    \ of the options with height set to ``None``.\n\n        Returns:\n          \
    \  ~ConsoleOptions: New console options instance.\n        \"\"\"\n        options\
    \ = self.copy()\n        options.height = None\n        return options\n\n   \
    \ def update_dimensions(self, width: int, height: int) -> \"ConsoleOptions\":\n\
    \        \"\"\"Update the width and height, and return a copy.\n\n        Args:\n\
    \            width (int): New width (sets both min_width and max_width).\n   \
    \         height (int): New height.\n\n        Returns:\n            ~ConsoleOptions:\
    \ New console options instance.\n        \"\"\"\n        options = self.copy()\n\
    \        options.min_width = options.max_width = max(0, width)\n        options.height\
    \ = options.max_height = height\n        return options\n\n\n@runtime_checkable\n\
    class RichCast(Protocol):\n    \"\"\"An object that may be 'cast' to a console\
    \ renderable.\"\"\"\n\n    def __rich__(\n        self,\n    ) -> Union[\"ConsoleRenderable\"\
    , \"RichCast\", str]:  # pragma: no cover\n        ...\n\n\n@runtime_checkable\n\
    class ConsoleRenderable(Protocol):\n    \"\"\"An object that supports the console\
    \ protocol.\"\"\"\n\n    def __rich_console__(\n        self, console: \"Console\"\
    , options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":  # pragma: no cover\n\
    \        ...\n\n\n# A type that may be rendered by Console.\nRenderableType =\
    \ Union[ConsoleRenderable, RichCast, str]\n\"\"\"A string or any object that may\
    \ be rendered by Rich.\"\"\"\n\n# The result of calling a __rich_console__ method.\n\
    RenderResult = Iterable[Union[RenderableType, Segment]]\n\n_null_highlighter =\
    \ NullHighlighter()\n\n\nclass CaptureError(Exception):\n    \"\"\"An error in\
    \ the Capture context manager.\"\"\"\n\n\nclass NewLine:\n    \"\"\"A renderable\
    \ to generate new line(s)\"\"\"\n\n    def __init__(self, count: int = 1) -> None:\n\
    \        self.count = count\n\n    def __rich_console__(\n        self, console:\
    \ \"Console\", options: \"ConsoleOptions\"\n    ) -> Iterable[Segment]:\n    \
    \    yield Segment(\"\\n\" * self.count)\n\n\nclass ScreenUpdate:\n    \"\"\"\
    Render a list of lines at a given offset.\"\"\"\n\n    def __init__(self, lines:\
    \ List[List[Segment]], x: int, y: int) -> None:\n        self._lines = lines\n\
    \        self.x = x\n        self.y = y\n\n    def __rich_console__(\n       \
    \ self, console: \"Console\", options: ConsoleOptions\n    ) -> RenderResult:\n\
    \        x = self.x\n        move_to = Control.move_to\n        for offset, line\
    \ in enumerate(self._lines, self.y):\n            yield move_to(x, offset)\n \
    \           yield from line\n\n\nclass Capture:\n    \"\"\"Context manager to\
    \ capture the result of printing to the console.\n    See :meth:`~rich.console.Console.capture`\
    \ for how to use.\n\n    Args:\n        console (Console): A console instance\
    \ to capture output.\n    \"\"\"\n\n    def __init__(self, console: \"Console\"\
    ) -> None:\n        self._console = console\n        self._result: Optional[str]\
    \ = None\n\n    def __enter__(self) -> \"Capture\":\n        self._console.begin_capture()\n\
    \        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n\
    \        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n\
    \    ) -> None:\n        self._result = self._console.end_capture()\n\n    def\
    \ get(self) -> str:\n        \"\"\"Get the result of the capture.\"\"\"\n    \
    \    if self._result is None:\n            raise CaptureError(\n             \
    \   \"Capture result is not available until context manager exits.\"\n       \
    \     )\n        return self._result\n\n\nclass ThemeContext:\n    \"\"\"A context\
    \ manager to use a temporary theme. See :meth:`~rich.console.Console.use_theme`\
    \ for usage.\"\"\"\n\n    def __init__(self, console: \"Console\", theme: Theme,\
    \ inherit: bool = True) -> None:\n        self.console = console\n        self.theme\
    \ = theme\n        self.inherit = inherit\n\n    def __enter__(self) -> \"ThemeContext\"\
    :\n        self.console.push_theme(self.theme)\n        return self\n\n    def\
    \ __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n\
    \        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n\
    \    ) -> None:\n        self.console.pop_theme()\n\n\nclass PagerContext:\n \
    \   \"\"\"A context manager that 'pages' content. See :meth:`~rich.console.Console.pager`\
    \ for usage.\"\"\"\n\n    def __init__(\n        self,\n        console: \"Console\"\
    ,\n        pager: Optional[Pager] = None,\n        styles: bool = False,\n   \
    \     links: bool = False,\n    ) -> None:\n        self._console = console\n\
    \        self.pager = SystemPager() if pager is None else pager\n        self.styles\
    \ = styles\n        self.links = links\n\n    def __enter__(self) -> \"PagerContext\"\
    :\n        self._console._enter_buffer()\n        return self\n\n    def __exit__(\n\
    \        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val:\
    \ Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) ->\
    \ None:\n        if exc_type is None:\n            with self._console._lock:\n\
    \                buffer: List[Segment] = self._console._buffer[:]\n          \
    \      del self._console._buffer[:]\n                segments: Iterable[Segment]\
    \ = buffer\n                if not self.styles:\n                    segments\
    \ = Segment.strip_styles(segments)\n                elif not self.links:\n   \
    \                 segments = Segment.strip_links(segments)\n                content\
    \ = self._console._render_buffer(segments)\n            self.pager.show(content)\n\
    \        self._console._exit_buffer()\n\n\nclass ScreenContext:\n    \"\"\"A context\
    \ manager that enables an alternative screen. See :meth:`~rich.console.Console.screen`\
    \ for usage.\"\"\"\n\n    def __init__(\n        self, console: \"Console\", hide_cursor:\
    \ bool, style: StyleType = \"\"\n    ) -> None:\n        self.console = console\n\
    \        self.hide_cursor = hide_cursor\n        self.screen = Screen(style=style)\n\
    \        self._changed = False\n\n    def update(\n        self, *renderables:\
    \ RenderableType, style: Optional[StyleType] = None\n    ) -> None:\n        \"\
    \"\"Update the screen.\n\n        Args:\n            renderable (RenderableType,\
    \ optional): Optional renderable to replace current renderable,\n            \
    \    or None for no change. Defaults to None.\n            style: (Style, optional):\
    \ Replacement style, or None for no change. Defaults to None.\n        \"\"\"\n\
    \        if renderables:\n            self.screen.renderable = (\n           \
    \     Group(*renderables) if len(renderables) > 1 else renderables[0]\n      \
    \      )\n        if style is not None:\n            self.screen.style = style\n\
    \        self.console.print(self.screen, end=\"\")\n\n    def __enter__(self)\
    \ -> \"ScreenContext\":\n        self._changed = self.console.set_alt_screen(True)\n\
    \        if self._changed and self.hide_cursor:\n            self.console.show_cursor(False)\n\
    \        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n\
    \        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n\
    \    ) -> None:\n        if self._changed:\n            self.console.set_alt_screen(False)\n\
    \            if self.hide_cursor:\n                self.console.show_cursor(True)\n\
    \n\nclass Group:\n    \"\"\"Takes a group of renderables and returns a renderable\
    \ object that renders the group.\n\n    Args:\n        renderables (Iterable[RenderableType]):\
    \ An iterable of renderable objects.\n        fit (bool, optional): Fit dimension\
    \ of group to contents, or fill available space. Defaults to True.\n    \"\"\"\
    \n\n    def __init__(self, *renderables: \"RenderableType\", fit: bool = True)\
    \ -> None:\n        self._renderables = renderables\n        self.fit = fit\n\
    \        self._render: Optional[List[RenderableType]] = None\n\n    @property\n\
    \    def renderables(self) -> List[\"RenderableType\"]:\n        if self._render\
    \ is None:\n            self._render = list(self._renderables)\n        return\
    \ self._render\n\n    def __rich_measure__(\n        self, console: \"Console\"\
    , options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        if self.fit:\n\
    \            return measure_renderables(console, options, self.renderables)\n\
    \        else:\n            return Measurement(options.max_width, options.max_width)\n\
    \n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\
    \n    ) -> RenderResult:\n        yield from self.renderables\n\n\ndef group(fit:\
    \ bool = True) -> Callable[..., Callable[..., Group]]:\n    \"\"\"A decorator\
    \ that turns an iterable of renderables in to a group.\n\n    Args:\n        fit\
    \ (bool, optional): Fit dimension of group to contents, or fill available space.\
    \ Defaults to True.\n    \"\"\"\n\n    def decorator(\n        method: Callable[...,\
    \ Iterable[RenderableType]]\n    ) -> Callable[..., Group]:\n        \"\"\"Convert\
    \ a method that returns an iterable of renderables in to a Group.\"\"\"\n\n  \
    \      @wraps(method)\n        def _replace(*args: Any, **kwargs: Any) -> Group:\n\
    \            renderables = method(*args, **kwargs)\n            return Group(*renderables,\
    \ fit=fit)\n\n        return _replace\n\n    return decorator\n\n\ndef _is_jupyter()\
    \ -> bool:  # pragma: no cover\n    \"\"\"Check if we're running in a Jupyter\
    \ notebook.\"\"\"\n    try:\n        get_ipython  # type: ignore[name-defined]\n\
    \    except NameError:\n        return False\n    ipython = get_ipython()  # type:\
    \ ignore[name-defined]\n    shell = ipython.__class__.__name__\n    if (\n   \
    \     \"google.colab\" in str(ipython.__class__)\n        or os.getenv(\"DATABRICKS_RUNTIME_VERSION\"\
    )\n        or shell == \"ZMQInteractiveShell\"\n    ):\n        return True  #\
    \ Jupyter notebook or qtconsole\n    elif shell == \"TerminalInteractiveShell\"\
    :\n        return False  # Terminal running IPython\n    else:\n        return\
    \ False  # Other type (?)\n\n\nCOLOR_SYSTEMS = {\n    \"standard\": ColorSystem.STANDARD,\n\
    \    \"256\": ColorSystem.EIGHT_BIT,\n    \"truecolor\": ColorSystem.TRUECOLOR,\n\
    \    \"windows\": ColorSystem.WINDOWS,\n}\n\n_COLOR_SYSTEMS_NAMES = {system: name\
    \ for name, system in COLOR_SYSTEMS.items()}\n\n\n@dataclass\nclass ConsoleThreadLocals(threading.local):\n\
    \    \"\"\"Thread local values for Console context.\"\"\"\n\n    theme_stack:\
    \ ThemeStack\n    buffer: List[Segment] = field(default_factory=list)\n    buffer_index:\
    \ int = 0\n\n\nclass RenderHook(ABC):\n    \"\"\"Provides hooks in to the render\
    \ process.\"\"\"\n\n    @abstractmethod\n    def process_renderables(\n      \
    \  self, renderables: List[ConsoleRenderable]\n    ) -> List[ConsoleRenderable]:\n\
    \        \"\"\"Called with a list of objects to render.\n\n        This method\
    \ can return a new list of renderables, or modify and return the same list.\n\n\
    \        Args:\n            renderables (List[ConsoleRenderable]): A number of\
    \ renderable objects.\n\n        Returns:\n            List[ConsoleRenderable]:\
    \ A replacement list of renderables.\n        \"\"\"\n\n\n_windows_console_features:\
    \ Optional[\"WindowsConsoleFeatures\"] = None\n\n\ndef get_windows_console_features()\
    \ -> \"WindowsConsoleFeatures\":  # pragma: no cover\n    global _windows_console_features\n\
    \    if _windows_console_features is not None:\n        return _windows_console_features\n\
    \    from ._windows import get_windows_console_features\n\n    _windows_console_features\
    \ = get_windows_console_features()\n    return _windows_console_features\n\n\n\
    def detect_legacy_windows() -> bool:\n    \"\"\"Detect legacy Windows.\"\"\"\n\
    \    return WINDOWS and not get_windows_console_features().vt\n\n\nclass Console:\n\
    \    \"\"\"A high level console interface.\n\n    Args:\n        color_system\
    \ (str, optional): The color system supported by your terminal,\n            either\
    \ ``\"standard\"``, ``\"256\"`` or ``\"truecolor\"``. Leave as ``\"auto\"`` to\
    \ autodetect.\n        force_terminal (Optional[bool], optional): Enable/disable\
    \ terminal control codes, or None to auto-detect terminal. Defaults to None.\n\
    \        force_jupyter (Optional[bool], optional): Enable/disable Jupyter rendering,\
    \ or None to auto-detect Jupyter. Defaults to None.\n        force_interactive\
    \ (Optional[bool], optional): Enable/disable interactive mode, or None to auto\
    \ detect. Defaults to None.\n        soft_wrap (Optional[bool], optional): Set\
    \ soft wrap default on print method. Defaults to False.\n        theme (Theme,\
    \ optional): An optional style theme object, or ``None`` for default theme.\n\
    \        stderr (bool, optional): Use stderr rather than stdout if ``file`` is\
    \ not specified. Defaults to False.\n        file (IO, optional): A file object\
    \ where the console should write to. Defaults to stdout.\n        quiet (bool,\
    \ Optional): Boolean to suppress all output. Defaults to False.\n        width\
    \ (int, optional): The width of the terminal. Leave as default to auto-detect\
    \ width.\n        height (int, optional): The height of the terminal. Leave as\
    \ default to auto-detect height.\n        style (StyleType, optional): Style to\
    \ apply to all output, or None for no style. Defaults to None.\n        no_color\
    \ (Optional[bool], optional): Enabled no color mode, or None to auto detect. Defaults\
    \ to None.\n        tab_size (int, optional): Number of spaces used to replace\
    \ a tab character. Defaults to 8.\n        record (bool, optional): Boolean to\
    \ enable recording of terminal output,\n            required to call :meth:`export_html`,\
    \ :meth:`export_svg`, and :meth:`export_text`. Defaults to False.\n        markup\
    \ (bool, optional): Boolean to enable :ref:`console_markup`. Defaults to True.\n\
    \        emoji (bool, optional): Enable emoji code. Defaults to True.\n      \
    \  emoji_variant (str, optional): Optional emoji variant, either \"text\" or \"\
    emoji\". Defaults to None.\n        highlight (bool, optional): Enable automatic\
    \ highlighting. Defaults to True.\n        log_time (bool, optional): Boolean\
    \ to enable logging of time by :meth:`log` methods. Defaults to True.\n      \
    \  log_path (bool, optional): Boolean to enable the logging of the caller by :meth:`log`.\
    \ Defaults to True.\n        log_time_format (Union[str, TimeFormatterCallable],\
    \ optional): If ``log_time`` is enabled, either string for strftime or callable\
    \ that formats the time. Defaults to \"[%X] \".\n        highlighter (HighlighterType,\
    \ optional): Default highlighter.\n        legacy_windows (bool, optional): Enable\
    \ legacy Windows mode, or ``None`` to auto detect. Defaults to ``None``.\n   \
    \     safe_box (bool, optional): Restrict box options that don't render on legacy\
    \ Windows.\n        get_datetime (Callable[[], datetime], optional): Callable\
    \ that gets the current time as a datetime.datetime object (used by Console.log),\n\
    \            or None for datetime.now.\n        get_time (Callable[[], time],\
    \ optional): Callable that gets the current time in seconds, default uses time.monotonic.\n\
    \    \"\"\"\n\n    _environ: Mapping[str, str] = os.environ\n\n    def __init__(\n\
    \        self,\n        *,\n        color_system: Optional[\n            Literal[\"\
    auto\", \"standard\", \"256\", \"truecolor\", \"windows\"]\n        ] = \"auto\"\
    ,\n        force_terminal: Optional[bool] = None,\n        force_jupyter: Optional[bool]\
    \ = None,\n        force_interactive: Optional[bool] = None,\n        soft_wrap:\
    \ bool = False,\n        theme: Optional[Theme] = None,\n        stderr: bool\
    \ = False,\n        file: Optional[IO[str]] = None,\n        quiet: bool = False,\n\
    \        width: Optional[int] = None,\n        height: Optional[int] = None,\n\
    \        style: Optional[StyleType] = None,\n        no_color: Optional[bool]\
    \ = None,\n        tab_size: int = 8,\n        record: bool = False,\n       \
    \ markup: bool = True,\n        emoji: bool = True,\n        emoji_variant: Optional[EmojiVariant]\
    \ = None,\n        highlight: bool = True,\n        log_time: bool = True,\n \
    \       log_path: bool = True,\n        log_time_format: Union[str, FormatTimeCallable]\
    \ = \"[%X]\",\n        highlighter: Optional[\"HighlighterType\"] = ReprHighlighter(),\n\
    \        legacy_windows: Optional[bool] = None,\n        safe_box: bool = True,\n\
    \        get_datetime: Optional[Callable[[], datetime]] = None,\n        get_time:\
    \ Optional[Callable[[], float]] = None,\n        _environ: Optional[Mapping[str,\
    \ str]] = None,\n    ):\n        # Copy of os.environ allows us to replace it\
    \ for testing\n        if _environ is not None:\n            self._environ = _environ\n\
    \n        self.is_jupyter = _is_jupyter() if force_jupyter is None else force_jupyter\n\
    \        if self.is_jupyter:\n            if width is None:\n                jupyter_columns\
    \ = self._environ.get(\"JUPYTER_COLUMNS\")\n                if jupyter_columns\
    \ is not None and jupyter_columns.isdigit():\n                    width = int(jupyter_columns)\n\
    \                else:\n                    width = JUPYTER_DEFAULT_COLUMNS\n\
    \            if height is None:\n                jupyter_lines = self._environ.get(\"\
    JUPYTER_LINES\")\n                if jupyter_lines is not None and jupyter_lines.isdigit():\n\
    \                    height = int(jupyter_lines)\n                else:\n    \
    \                height = JUPYTER_DEFAULT_LINES\n\n        self.tab_size = tab_size\n\
    \        self.record = record\n        self._markup = markup\n        self._emoji\
    \ = emoji\n        self._emoji_variant: Optional[EmojiVariant] = emoji_variant\n\
    \        self._highlight = highlight\n        self.legacy_windows: bool = (\n\
    \            (detect_legacy_windows() and not self.is_jupyter)\n            if\
    \ legacy_windows is None\n            else legacy_windows\n        )\n\n     \
    \   if width is None:\n            columns = self._environ.get(\"COLUMNS\")\n\
    \            if columns is not None and columns.isdigit():\n                width\
    \ = int(columns) - self.legacy_windows\n        if height is None:\n         \
    \   lines = self._environ.get(\"LINES\")\n            if lines is not None and\
    \ lines.isdigit():\n                height = int(lines)\n\n        self.soft_wrap\
    \ = soft_wrap\n        self._width = width\n        self._height = height\n\n\
    \        self._color_system: Optional[ColorSystem]\n\n        self._force_terminal\
    \ = None\n        if force_terminal is not None:\n            self._force_terminal\
    \ = force_terminal\n\n        self._file = file\n        self.quiet = quiet\n\
    \        self.stderr = stderr\n\n        if color_system is None:\n          \
    \  self._color_system = None\n        elif color_system == \"auto\":\n       \
    \     self._color_system = self._detect_color_system()\n        else:\n      \
    \      self._color_system = COLOR_SYSTEMS[color_system]\n\n        self._lock\
    \ = threading.RLock()\n        self._log_render = LogRender(\n            show_time=log_time,\n\
    \            show_path=log_path,\n            time_format=log_time_format,\n \
    \       )\n        self.highlighter: HighlighterType = highlighter or _null_highlighter\n\
    \        self.safe_box = safe_box\n        self.get_datetime = get_datetime or\
    \ datetime.now\n        self.get_time = get_time or monotonic\n        self.style\
    \ = style\n        self.no_color = (\n            no_color if no_color is not\
    \ None else \"NO_COLOR\" in self._environ\n        )\n        self.is_interactive\
    \ = (\n            (self.is_terminal and not self.is_dumb_terminal)\n        \
    \    if force_interactive is None\n            else force_interactive\n      \
    \  )\n\n        self._record_buffer_lock = threading.RLock()\n        self._thread_locals\
    \ = ConsoleThreadLocals(\n            theme_stack=ThemeStack(themes.DEFAULT if\
    \ theme is None else theme)\n        )\n        self._record_buffer: List[Segment]\
    \ = []\n        self._render_hooks: List[RenderHook] = []\n        self._live:\
    \ Optional[\"Live\"] = None\n        self._is_alt_screen = False\n\n    def __repr__(self)\
    \ -> str:\n        return f\"<console width={self.width} {self._color_system!s}>\"\
    \n\n    @property\n    def file(self) -> IO[str]:\n        \"\"\"Get the file\
    \ object to write to.\"\"\"\n        file = self._file or (sys.stderr if self.stderr\
    \ else sys.stdout)\n        file = getattr(file, \"rich_proxied_file\", file)\n\
    \        if file is None:\n            file = NULL_FILE\n        return file\n\
    \n    @file.setter\n    def file(self, new_file: IO[str]) -> None:\n        \"\
    \"\"Set a new file object.\"\"\"\n        self._file = new_file\n\n    @property\n\
    \    def _buffer(self) -> List[Segment]:\n        \"\"\"Get a thread local buffer.\"\
    \"\"\n        return self._thread_locals.buffer\n\n    @property\n    def _buffer_index(self)\
    \ -> int:\n        \"\"\"Get a thread local buffer.\"\"\"\n        return self._thread_locals.buffer_index\n\
    \n    @_buffer_index.setter\n    def _buffer_index(self, value: int) -> None:\n\
    \        self._thread_locals.buffer_index = value\n\n    @property\n    def _theme_stack(self)\
    \ -> ThemeStack:\n        \"\"\"Get the thread local theme stack.\"\"\"\n    \
    \    return self._thread_locals.theme_stack\n\n    def _detect_color_system(self)\
    \ -> Optional[ColorSystem]:\n        \"\"\"Detect color system from env vars.\"\
    \"\"\n        if self.is_jupyter:\n            return ColorSystem.TRUECOLOR\n\
    \        if not self.is_terminal or self.is_dumb_terminal:\n            return\
    \ None\n        if WINDOWS:  # pragma: no cover\n            if self.legacy_windows:\
    \  # pragma: no cover\n                return ColorSystem.WINDOWS\n          \
    \  windows_console_features = get_windows_console_features()\n            return\
    \ (\n                ColorSystem.TRUECOLOR\n                if windows_console_features.truecolor\n\
    \                else ColorSystem.EIGHT_BIT\n            )\n        else:\n  \
    \          color_term = self._environ.get(\"COLORTERM\", \"\").strip().lower()\n\
    \            if color_term in (\"truecolor\", \"24bit\"):\n                return\
    \ ColorSystem.TRUECOLOR\n            term = self._environ.get(\"TERM\", \"\").strip().lower()\n\
    \            _term_name, _hyphen, colors = term.rpartition(\"-\")\n          \
    \  color_system = _TERM_COLORS.get(colors, ColorSystem.STANDARD)\n           \
    \ return color_system\n\n    def _enter_buffer(self) -> None:\n        \"\"\"\
    Enter in to a buffer context, and buffer all output.\"\"\"\n        self._buffer_index\
    \ += 1\n\n    def _exit_buffer(self) -> None:\n        \"\"\"Leave buffer context,\
    \ and render content if required.\"\"\"\n        self._buffer_index -= 1\n   \
    \     self._check_buffer()\n\n    def set_live(self, live: \"Live\") -> None:\n\
    \        \"\"\"Set Live instance. Used by Live context manager.\n\n        Args:\n\
    \            live (Live): Live instance using this Console.\n\n        Raises:\n\
    \            errors.LiveError: If this Console has a Live context currently active.\n\
    \        \"\"\"\n        with self._lock:\n            if self._live is not None:\n\
    \                raise errors.LiveError(\"Only one live display may be active\
    \ at once\")\n            self._live = live\n\n    def clear_live(self) -> None:\n\
    \        \"\"\"Clear the Live instance.\"\"\"\n        with self._lock:\n    \
    \        self._live = None\n\n    def push_render_hook(self, hook: RenderHook)\
    \ -> None:\n        \"\"\"Add a new render hook to the stack.\n\n        Args:\n\
    \            hook (RenderHook): Render hook instance.\n        \"\"\"\n      \
    \  with self._lock:\n            self._render_hooks.append(hook)\n\n    def pop_render_hook(self)\
    \ -> None:\n        \"\"\"Pop the last renderhook from the stack.\"\"\"\n    \
    \    with self._lock:\n            self._render_hooks.pop()\n\n    def __enter__(self)\
    \ -> \"Console\":\n        \"\"\"Own context manager to enter buffer context.\"\
    \"\"\n        self._enter_buffer()\n        return self\n\n    def __exit__(self,\
    \ exc_type: Any, exc_value: Any, traceback: Any) -> None:\n        \"\"\"Exit\
    \ buffer context.\"\"\"\n        self._exit_buffer()\n\n    def begin_capture(self)\
    \ -> None:\n        \"\"\"Begin capturing console output. Call :meth:`end_capture`\
    \ to exit capture mode and return output.\"\"\"\n        self._enter_buffer()\n\
    \n    def end_capture(self) -> str:\n        \"\"\"End capture mode and return\
    \ captured string.\n\n        Returns:\n            str: Console output.\n   \
    \     \"\"\"\n        render_result = self._render_buffer(self._buffer)\n    \
    \    del self._buffer[:]\n        self._exit_buffer()\n        return render_result\n\
    \n    def push_theme(self, theme: Theme, *, inherit: bool = True) -> None:\n \
    \       \"\"\"Push a new theme on to the top of the stack, replacing the styles\
    \ from the previous theme.\n        Generally speaking, you should call :meth:`~rich.console.Console.use_theme`\
    \ to get a context manager, rather\n        than calling this method directly.\n\
    \n        Args:\n            theme (Theme): A theme instance.\n            inherit\
    \ (bool, optional): Inherit existing styles. Defaults to True.\n        \"\"\"\
    \n        self._theme_stack.push_theme(theme, inherit=inherit)\n\n    def pop_theme(self)\
    \ -> None:\n        \"\"\"Remove theme from top of stack, restoring previous theme.\"\
    \"\"\n        self._theme_stack.pop_theme()\n\n    def use_theme(self, theme:\
    \ Theme, *, inherit: bool = True) -> ThemeContext:\n        \"\"\"Use a different\
    \ theme for the duration of the context manager.\n\n        Args:\n          \
    \  theme (Theme): Theme instance to user.\n            inherit (bool, optional):\
    \ Inherit existing console styles. Defaults to True.\n\n        Returns:\n   \
    \         ThemeContext: [description]\n        \"\"\"\n        return ThemeContext(self,\
    \ theme, inherit)\n\n    @property\n    def color_system(self) -> Optional[str]:\n\
    \        \"\"\"Get color system string.\n\n        Returns:\n            Optional[str]:\
    \ \"standard\", \"256\" or \"truecolor\".\n        \"\"\"\n\n        if self._color_system\
    \ is not None:\n            return _COLOR_SYSTEMS_NAMES[self._color_system]\n\
    \        else:\n            return None\n\n    @property\n    def encoding(self)\
    \ -> str:\n        \"\"\"Get the encoding of the console file, e.g. ``\"utf-8\"\
    ``.\n\n        Returns:\n            str: A standard encoding string.\n      \
    \  \"\"\"\n        return (getattr(self.file, \"encoding\", \"utf-8\") or \"utf-8\"\
    ).lower()\n\n    @property\n    def is_terminal(self) -> bool:\n        \"\"\"\
    Check if the console is writing to a terminal.\n\n        Returns:\n         \
    \   bool: True if the console writing to a device capable of\n            understanding\
    \ terminal codes, otherwise False.\n        \"\"\"\n        if self._force_terminal\
    \ is not None:\n            return self._force_terminal\n\n        if hasattr(sys.stdin,\
    \ \"__module__\") and sys.stdin.__module__.startswith(\n            \"idlelib\"\
    \n        ):\n            # Return False for Idle which claims to be a tty but\
    \ can't handle ansi codes\n            return False\n\n        if self.is_jupyter:\n\
    \            # return False for Jupyter, which may have FORCE_COLOR set\n    \
    \        return False\n\n        # If FORCE_COLOR env var has any value at all,\
    \ we assume a terminal.\n        force_color = self._environ.get(\"FORCE_COLOR\"\
    )\n        if force_color is not None:\n            self._force_terminal = True\n\
    \            return True\n\n        isatty: Optional[Callable[[], bool]] = getattr(self.file,\
    \ \"isatty\", None)\n        try:\n            return False if isatty is None\
    \ else isatty()\n        except ValueError:\n            # in some situation (at\
    \ the end of a pytest run for example) isatty() can raise\n            # ValueError:\
    \ I/O operation on closed file\n            # return False because we aren't in\
    \ a terminal anymore\n            return False\n\n    @property\n    def is_dumb_terminal(self)\
    \ -> bool:\n        \"\"\"Detect dumb terminal.\n\n        Returns:\n        \
    \    bool: True if writing to a dumb terminal, otherwise False.\n\n        \"\"\
    \"\n        _term = self._environ.get(\"TERM\", \"\")\n        is_dumb = _term.lower()\
    \ in (\"dumb\", \"unknown\")\n        return self.is_terminal and is_dumb\n\n\
    \    @property\n    def options(self) -> ConsoleOptions:\n        \"\"\"Get default\
    \ console options.\"\"\"\n        return ConsoleOptions(\n            max_height=self.size.height,\n\
    \            size=self.size,\n            legacy_windows=self.legacy_windows,\n\
    \            min_width=1,\n            max_width=self.width,\n            encoding=self.encoding,\n\
    \            is_terminal=self.is_terminal,\n        )\n\n    @property\n    def\
    \ size(self) -> ConsoleDimensions:\n        \"\"\"Get the size of the console.\n\
    \n        Returns:\n            ConsoleDimensions: A named tuple containing the\
    \ dimensions.\n        \"\"\"\n\n        if self._width is not None and self._height\
    \ is not None:\n            return ConsoleDimensions(self._width - self.legacy_windows,\
    \ self._height)\n\n        if self.is_dumb_terminal:\n            return ConsoleDimensions(80,\
    \ 25)\n\n        width: Optional[int] = None\n        height: Optional[int] =\
    \ None\n\n        streams = _STD_STREAMS_OUTPUT if WINDOWS else _STD_STREAMS\n\
    \        for file_descriptor in streams:\n            try:\n                width,\
    \ height = os.get_terminal_size(file_descriptor)\n            except (AttributeError,\
    \ ValueError, OSError):  # Probably not a terminal\n                pass\n   \
    \         else:\n                break\n\n        columns = self._environ.get(\"\
    COLUMNS\")\n        if columns is not None and columns.isdigit():\n          \
    \  width = int(columns)\n        lines = self._environ.get(\"LINES\")\n      \
    \  if lines is not None and lines.isdigit():\n            height = int(lines)\n\
    \n        # get_terminal_size can report 0, 0 if run from pseudo-terminal\n  \
    \      width = width or 80\n        height = height or 25\n        return ConsoleDimensions(\n\
    \            width - self.legacy_windows if self._width is None else self._width,\n\
    \            height if self._height is None else self._height,\n        )\n\n\
    \    @size.setter\n    def size(self, new_size: Tuple[int, int]) -> None:\n  \
    \      \"\"\"Set a new size for the terminal.\n\n        Args:\n            new_size\
    \ (Tuple[int, int]): New width and height.\n        \"\"\"\n        width, height\
    \ = new_size\n        self._width = width\n        self._height = height\n\n \
    \   @property\n    def width(self) -> int:\n        \"\"\"Get the width of the\
    \ console.\n\n        Returns:\n            int: The width (in characters) of\
    \ the console.\n        \"\"\"\n        return self.size.width\n\n    @width.setter\n\
    \    def width(self, width: int) -> None:\n        \"\"\"Set width.\n\n      \
    \  Args:\n            width (int): New width.\n        \"\"\"\n        self._width\
    \ = width\n\n    @property\n    def height(self) -> int:\n        \"\"\"Get the\
    \ height of the console.\n\n        Returns:\n            int: The height (in\
    \ lines) of the console.\n        \"\"\"\n        return self.size.height\n\n\
    \    @height.setter\n    def height(self, height: int) -> None:\n        \"\"\"\
    Set height.\n\n        Args:\n            height (int): new height.\n        \"\
    \"\"\n        self._height = height\n\n    def bell(self) -> None:\n        \"\
    \"\"Play a 'bell' sound (if supported by the terminal).\"\"\"\n        self.control(Control.bell())\n\
    \n    def capture(self) -> Capture:\n        \"\"\"A context manager to *capture*\
    \ the result of print() or log() in a string,\n        rather than writing it\
    \ to the console.\n\n        Example:\n            >>> from rich.console import\
    \ Console\n            >>> console = Console()\n            >>> with console.capture()\
    \ as capture:\n            ...     console.print(\"[bold magenta]Hello World[/]\"\
    )\n            >>> print(capture.get())\n\n        Returns:\n            Capture:\
    \ Context manager with disables writing to the terminal.\n        \"\"\"\n   \
    \     capture = Capture(self)\n        return capture\n\n    def pager(\n    \
    \    self, pager: Optional[Pager] = None, styles: bool = False, links: bool =\
    \ False\n    ) -> PagerContext:\n        \"\"\"A context manager to display anything\
    \ printed within a \"pager\". The pager application\n        is defined by the\
    \ system and will typically support at least pressing a key to scroll.\n\n   \
    \     Args:\n            pager (Pager, optional): A pager object, or None to use\
    \ :class:`~rich.pager.SystemPager`. Defaults to None.\n            styles (bool,\
    \ optional): Show styles in pager. Defaults to False.\n            links (bool,\
    \ optional): Show links in pager. Defaults to False.\n\n        Example:\n   \
    \         >>> from rich.console import Console\n            >>> from rich.__main__\
    \ import make_test_card\n            >>> console = Console()\n            >>>\
    \ with console.pager():\n                    console.print(make_test_card())\n\
    \n        Returns:\n            PagerContext: A context manager.\n        \"\"\
    \"\n        return PagerContext(self, pager=pager, styles=styles, links=links)\n\
    \n    def line(self, count: int = 1) -> None:\n        \"\"\"Write new line(s).\n\
    \n        Args:\n            count (int, optional): Number of new lines. Defaults\
    \ to 1.\n        \"\"\"\n\n        assert count >= 0, \"count must be >= 0\"\n\
    \        self.print(NewLine(count))\n\n    def clear(self, home: bool = True)\
    \ -> None:\n        \"\"\"Clear the screen.\n\n        Args:\n            home\
    \ (bool, optional): Also move the cursor to 'home' position. Defaults to True.\n\
    \        \"\"\"\n        if home:\n            self.control(Control.clear(), Control.home())\n\
    \        else:\n            self.control(Control.clear())\n\n    def status(\n\
    \        self,\n        status: RenderableType,\n        *,\n        spinner:\
    \ str = \"dots\",\n        spinner_style: StyleType = \"status.spinner\",\n  \
    \      speed: float = 1.0,\n        refresh_per_second: float = 12.5,\n    ) ->\
    \ \"Status\":\n        \"\"\"Display a status and spinner.\n\n        Args:\n\
    \            status (RenderableType): A status renderable (str or Text typically).\n\
    \            spinner (str, optional): Name of spinner animation (see python -m\
    \ rich.spinner). Defaults to \"dots\".\n            spinner_style (StyleType,\
    \ optional): Style of spinner. Defaults to \"status.spinner\".\n            speed\
    \ (float, optional): Speed factor for spinner animation. Defaults to 1.0.\n  \
    \          refresh_per_second (float, optional): Number of refreshes per second.\
    \ Defaults to 12.5.\n\n        Returns:\n            Status: A Status object that\
    \ may be used as a context manager.\n        \"\"\"\n        from .status import\
    \ Status\n\n        status_renderable = Status(\n            status,\n       \
    \     console=self,\n            spinner=spinner,\n            spinner_style=spinner_style,\n\
    \            speed=speed,\n            refresh_per_second=refresh_per_second,\n\
    \        )\n        return status_renderable\n\n    def show_cursor(self, show:\
    \ bool = True) -> bool:\n        \"\"\"Show or hide the cursor.\n\n        Args:\n\
    \            show (bool, optional): Set visibility of the cursor.\n        \"\"\
    \"\n        if self.is_terminal:\n            self.control(Control.show_cursor(show))\n\
    \            return True\n        return False\n\n    def set_alt_screen(self,\
    \ enable: bool = True) -> bool:\n        \"\"\"Enables alternative screen mode.\n\
    \n        Note, if you enable this mode, you should ensure that is disabled before\n\
    \        the application exits. See :meth:`~rich.Console.screen` for a context\
    \ manager\n        that handles this for you.\n\n        Args:\n            enable\
    \ (bool, optional): Enable (True) or disable (False) alternate screen. Defaults\
    \ to True.\n\n        Returns:\n            bool: True if the control codes were\
    \ written.\n\n        \"\"\"\n        changed = False\n        if self.is_terminal\
    \ and not self.legacy_windows:\n            self.control(Control.alt_screen(enable))\n\
    \            changed = True\n            self._is_alt_screen = enable\n      \
    \  return changed\n\n    @property\n    def is_alt_screen(self) -> bool:\n   \
    \     \"\"\"Check if the alt screen was enabled.\n\n        Returns:\n       \
    \     bool: True if the alt screen was enabled, otherwise False.\n        \"\"\
    \"\n        return self._is_alt_screen\n\n    def set_window_title(self, title:\
    \ str) -> bool:\n        \"\"\"Set the title of the console terminal window.\n\
    \n        Warning: There is no means within Rich of \"resetting\" the window title\
    \ to its\n        previous value, meaning the title you set will persist even\
    \ after your application\n        exits.\n\n        ``fish`` shell resets the\
    \ window title before and after each command by default,\n        negating this\
    \ issue. Windows Terminal and command prompt will also reset the title for you.\n\
    \        Most other shells and terminals, however, do not do this.\n\n       \
    \ Some terminals may require configuration changes before you can set the title.\n\
    \        Some terminals may not support setting the title at all.\n\n        Other\
    \ software (including the terminal itself, the shell, custom prompts, plugins,\
    \ etc.)\n        may also set the terminal window title. This could result in\
    \ whatever value you write\n        using this method being overwritten.\n\n \
    \       Args:\n            title (str): The new title of the terminal window.\n\
    \n        Returns:\n            bool: True if the control code to change the terminal\
    \ title was\n                written, otherwise False. Note that a return value\
    \ of True\n                does not guarantee that the window title has actually\
    \ changed,\n                since the feature may be unsupported/disabled in some\
    \ terminals.\n        \"\"\"\n        if self.is_terminal:\n            self.control(Control.title(title))\n\
    \            return True\n        return False\n\n    def screen(\n        self,\
    \ hide_cursor: bool = True, style: Optional[StyleType] = None\n    ) -> \"ScreenContext\"\
    :\n        \"\"\"Context manager to enable and disable 'alternative screen' mode.\n\
    \n        Args:\n            hide_cursor (bool, optional): Also hide the cursor.\
    \ Defaults to False.\n            style (Style, optional): Optional style for\
    \ screen. Defaults to None.\n\n        Returns:\n            ~ScreenContext: Context\
    \ which enables alternate screen on enter, and disables it on exit.\n        \"\
    \"\"\n        return ScreenContext(self, hide_cursor=hide_cursor, style=style\
    \ or \"\")\n\n    def measure(\n        self, renderable: RenderableType, *, options:\
    \ Optional[ConsoleOptions] = None\n    ) -> Measurement:\n        \"\"\"Measure\
    \ a renderable. Returns a :class:`~rich.measure.Measurement` object which contains\n\
    \        information regarding the number of characters required to print the\
    \ renderable.\n\n        Args:\n            renderable (RenderableType): Any renderable\
    \ or string.\n            options (Optional[ConsoleOptions], optional): Options\
    \ to use when measuring, or None\n                to use default options. Defaults\
    \ to None.\n\n        Returns:\n            Measurement: A measurement of the\
    \ renderable.\n        \"\"\"\n        measurement = Measurement.get(self, options\
    \ or self.options, renderable)\n        return measurement\n\n    def render(\n\
    \        self, renderable: RenderableType, options: Optional[ConsoleOptions] =\
    \ None\n    ) -> Iterable[Segment]:\n        \"\"\"Render an object in to an iterable\
    \ of `Segment` instances.\n\n        This method contains the logic for rendering\
    \ objects with the console protocol.\n        You are unlikely to need to use\
    \ it directly, unless you are extending the library.\n\n        Args:\n      \
    \      renderable (RenderableType): An object supporting the console protocol,\
    \ or\n                an object that may be converted to a string.\n         \
    \   options (ConsoleOptions, optional): An options object, or None to use self.options.\
    \ Defaults to None.\n\n        Returns:\n            Iterable[Segment]: An iterable\
    \ of segments that may be rendered.\n        \"\"\"\n\n        _options = options\
    \ or self.options\n        if _options.max_width < 1:\n            # No space\
    \ to render anything. This prevents potential recursion errors.\n            return\n\
    \        render_iterable: RenderResult\n\n        renderable = rich_cast(renderable)\n\
    \        if hasattr(renderable, \"__rich_console__\") and not isclass(renderable):\n\
    \            render_iterable = renderable.__rich_console__(self, _options)\n \
    \       elif isinstance(renderable, str):\n            text_renderable = self.render_str(\n\
    \                renderable, highlight=_options.highlight, markup=_options.markup\n\
    \            )\n            render_iterable = text_renderable.__rich_console__(self,\
    \ _options)\n        else:\n            raise errors.NotRenderableError(\n   \
    \             f\"Unable to render {renderable!r}; \"\n                \"A str,\
    \ Segment or object with __rich_console__ method is required\"\n            )\n\
    \n        try:\n            iter_render = iter(render_iterable)\n        except\
    \ TypeError:\n            raise errors.NotRenderableError(\n                f\"\
    object {render_iterable!r} is not renderable\"\n            )\n        _Segment\
    \ = Segment\n        _options = _options.reset_height()\n        for render_output\
    \ in iter_render:\n            if isinstance(render_output, _Segment):\n     \
    \           yield render_output\n            else:\n                yield from\
    \ self.render(render_output, _options)\n\n    def render_lines(\n        self,\n\
    \        renderable: RenderableType,\n        options: Optional[ConsoleOptions]\
    \ = None,\n        *,\n        style: Optional[Style] = None,\n        pad: bool\
    \ = True,\n        new_lines: bool = False,\n    ) -> List[List[Segment]]:\n \
    \       \"\"\"Render objects in to a list of lines.\n\n        The output of render_lines\
    \ is useful when further formatting of rendered console text\n        is required,\
    \ such as the Panel class which draws a border around any renderable object.\n\
    \n        Args:\n            renderable (RenderableType): Any object renderable\
    \ in the console.\n            options (Optional[ConsoleOptions], optional): Console\
    \ options, or None to use self.options. Default to ``None``.\n            style\
    \ (Style, optional): Optional style to apply to renderables. Defaults to ``None``.\n\
    \            pad (bool, optional): Pad lines shorter than render width. Defaults\
    \ to ``True``.\n            new_lines (bool, optional): Include \"\\n\" characters\
    \ at end of lines.\n\n        Returns:\n            List[List[Segment]]: A list\
    \ of lines, where a line is a list of Segment objects.\n        \"\"\"\n     \
    \   with self._lock:\n            render_options = options or self.options\n \
    \           _rendered = self.render(renderable, render_options)\n            if\
    \ style:\n                _rendered = Segment.apply_style(_rendered, style)\n\n\
    \            render_height = render_options.height\n            if render_height\
    \ is not None:\n                render_height = max(0, render_height)\n\n    \
    \        lines = list(\n                islice(\n                    Segment.split_and_crop_lines(\n\
    \                        _rendered,\n                        render_options.max_width,\n\
    \                        include_new_lines=new_lines,\n                      \
    \  pad=pad,\n                        style=style,\n                    ),\n  \
    \                  None,\n                    render_height,\n               \
    \ )\n            )\n            if render_options.height is not None:\n      \
    \          extra_lines = render_options.height - len(lines)\n                if\
    \ extra_lines > 0:\n                    pad_line = [\n                       \
    \ (\n                            [\n                                Segment(\"\
    \ \" * render_options.max_width, style),\n                                Segment(\"\
    \\n\"),\n                            ]\n                            if new_lines\n\
    \                            else [Segment(\" \" * render_options.max_width, style)]\n\
    \                        )\n                    ]\n                    lines.extend(pad_line\
    \ * extra_lines)\n\n            return lines\n\n    def render_str(\n        self,\n\
    \        text: str,\n        *,\n        style: Union[str, Style] = \"\",\n  \
    \      justify: Optional[JustifyMethod] = None,\n        overflow: Optional[OverflowMethod]\
    \ = None,\n        emoji: Optional[bool] = None,\n        markup: Optional[bool]\
    \ = None,\n        highlight: Optional[bool] = None,\n        highlighter: Optional[HighlighterType]\
    \ = None,\n    ) -> \"Text\":\n        \"\"\"Convert a string to a Text instance.\
    \ This is called automatically if\n        you print or log a string.\n\n    \
    \    Args:\n            text (str): Text to render.\n            style (Union[str,\
    \ Style], optional): Style to apply to rendered text.\n            justify (str,\
    \ optional): Justify method: \"default\", \"left\", \"center\", \"full\", or \"\
    right\". Defaults to ``None``.\n            overflow (str, optional): Overflow\
    \ method: \"crop\", \"fold\", or \"ellipsis\". Defaults to ``None``.\n       \
    \     emoji (Optional[bool], optional): Enable emoji, or ``None`` to use Console\
    \ default.\n            markup (Optional[bool], optional): Enable markup, or ``None``\
    \ to use Console default.\n            highlight (Optional[bool], optional): Enable\
    \ highlighting, or ``None`` to use Console default.\n            highlighter (HighlighterType,\
    \ optional): Optional highlighter to apply.\n        Returns:\n            ConsoleRenderable:\
    \ Renderable object.\n\n        \"\"\"\n        emoji_enabled = emoji or (emoji\
    \ is None and self._emoji)\n        markup_enabled = markup or (markup is None\
    \ and self._markup)\n        highlight_enabled = highlight or (highlight is None\
    \ and self._highlight)\n\n        if markup_enabled:\n            rich_text =\
    \ render_markup(\n                text,\n                style=style,\n      \
    \          emoji=emoji_enabled,\n                emoji_variant=self._emoji_variant,\n\
    \            )\n            rich_text.justify = justify\n            rich_text.overflow\
    \ = overflow\n        else:\n            rich_text = Text(\n                (\n\
    \                    _emoji_replace(text, default_variant=self._emoji_variant)\n\
    \                    if emoji_enabled\n                    else text\n       \
    \         ),\n                justify=justify,\n                overflow=overflow,\n\
    \                style=style,\n            )\n\n        _highlighter = (highlighter\
    \ or self.highlighter) if highlight_enabled else None\n        if _highlighter\
    \ is not None:\n            highlight_text = _highlighter(str(rich_text))\n  \
    \          highlight_text.copy_styles(rich_text)\n            return highlight_text\n\
    \n        return rich_text\n\n    def get_style(\n        self, name: Union[str,\
    \ Style], *, default: Optional[Union[Style, str]] = None\n    ) -> Style:\n  \
    \      \"\"\"Get a Style instance by its theme name or parse a definition.\n\n\
    \        Args:\n            name (str): The name of a style or a style definition.\n\
    \n        Returns:\n            Style: A Style object.\n\n        Raises:\n  \
    \          MissingStyle: If no style could be parsed from name.\n\n        \"\"\
    \"\n        if isinstance(name, Style):\n            return name\n\n        try:\n\
    \            style = self._theme_stack.get(name)\n            if style is None:\n\
    \                style = Style.parse(name)\n            return style.copy() if\
    \ style.link else style\n        except errors.StyleSyntaxError as error:\n  \
    \          if default is not None:\n                return self.get_style(default)\n\
    \            raise errors.MissingStyle(\n                f\"Failed to get style\
    \ {name!r}; {error}\"\n            ) from None\n\n    def _collect_renderables(\n\
    \        self,\n        objects: Iterable[Any],\n        sep: str,\n        end:\
    \ str,\n        *,\n        justify: Optional[JustifyMethod] = None,\n       \
    \ emoji: Optional[bool] = None,\n        markup: Optional[bool] = None,\n    \
    \    highlight: Optional[bool] = None,\n    ) -> List[ConsoleRenderable]:\n  \
    \      \"\"\"Combine a number of renderables and text into one renderable.\n\n\
    \        Args:\n            objects (Iterable[Any]): Anything that Rich can render.\n\
    \            sep (str): String to write between print data.\n            end (str):\
    \ String to write at end of print data.\n            justify (str, optional):\
    \ One of \"left\", \"right\", \"center\", or \"full\". Defaults to ``None``.\n\
    \            emoji (Optional[bool], optional): Enable emoji code, or ``None``\
    \ to use console default.\n            markup (Optional[bool], optional): Enable\
    \ markup, or ``None`` to use console default.\n            highlight (Optional[bool],\
    \ optional): Enable automatic highlighting, or ``None`` to use console default.\n\
    \n        Returns:\n            List[ConsoleRenderable]: A list of things to render.\n\
    \        \"\"\"\n        renderables: List[ConsoleRenderable] = []\n        _append\
    \ = renderables.append\n        text: List[Text] = []\n        append_text = text.append\n\
    \n        append = _append\n        if justify in (\"left\", \"center\", \"right\"\
    ):\n\n            def align_append(renderable: RenderableType) -> None:\n    \
    \            _append(Align(renderable, cast(AlignMethod, justify)))\n\n      \
    \      append = align_append\n\n        _highlighter: HighlighterType = _null_highlighter\n\
    \        if highlight or (highlight is None and self._highlight):\n          \
    \  _highlighter = self.highlighter\n\n        def check_text() -> None:\n    \
    \        if text:\n                sep_text = Text(sep, justify=justify, end=end)\n\
    \                append(sep_text.join(text))\n                text.clear()\n\n\
    \        for renderable in objects:\n            renderable = rich_cast(renderable)\n\
    \            if isinstance(renderable, str):\n                append_text(\n \
    \                   self.render_str(\n                        renderable,\n  \
    \                      emoji=emoji,\n                        markup=markup,\n\
    \                        highlight=highlight,\n                        highlighter=_highlighter,\n\
    \                    )\n                )\n            elif isinstance(renderable,\
    \ Text):\n                append_text(renderable)\n            elif isinstance(renderable,\
    \ ConsoleRenderable):\n                check_text()\n                append(renderable)\n\
    \            elif is_expandable(renderable):\n                check_text()\n \
    \               append(Pretty(renderable, highlighter=_highlighter))\n       \
    \     else:\n                append_text(_highlighter(str(renderable)))\n\n  \
    \      check_text()\n\n        if self.style is not None:\n            style =\
    \ self.get_style(self.style)\n            renderables = [Styled(renderable, style)\
    \ for renderable in renderables]\n\n        return renderables\n\n    def rule(\n\
    \        self,\n        title: TextType = \"\",\n        *,\n        characters:\
    \ str = \"â\",\n        style: Union[str, Style] = \"rule.line\",\n        align:\
    \ AlignMethod = \"center\",\n    ) -> None:\n        \"\"\"Draw a line with optional\
    \ centered title.\n\n        Args:\n            title (str, optional): Text to\
    \ render over the rule. Defaults to \"\".\n            characters (str, optional):\
    \ Character(s) to form the line. Defaults to \"â\".\n            style (str, optional):\
    \ Style of line. Defaults to \"rule.line\".\n            align (str, optional):\
    \ How to align the title, one of \"left\", \"center\", or \"right\". Defaults\
    \ to \"center\".\n        \"\"\"\n        from .rule import Rule\n\n        rule\
    \ = Rule(title=title, characters=characters, style=style, align=align)\n     \
    \   self.print(rule)\n\n    def control(self, *control: Control) -> None:\n  \
    \      \"\"\"Insert non-printing control codes.\n\n        Args:\n           \
    \ control_codes (str): Control codes, such as those that may move the cursor.\n\
    \        \"\"\"\n        if not self.is_dumb_terminal:\n            with self:\n\
    \                self._buffer.extend(_control.segment for _control in control)\n\
    \n    def out(\n        self,\n        *objects: Any,\n        sep: str = \" \"\
    ,\n        end: str = \"\\n\",\n        style: Optional[Union[str, Style]] = None,\n\
    \        highlight: Optional[bool] = None,\n    ) -> None:\n        \"\"\"Output\
    \ to the terminal. This is a low-level way of writing to the terminal which unlike\n\
    \        :meth:`~rich.console.Console.print` won't pretty print, wrap text, or\
    \ apply markup, but will\n        optionally apply highlighting and a basic style.\n\
    \n        Args:\n            sep (str, optional): String to write between print\
    \ data. Defaults to \" \".\n            end (str, optional): String to write at\
    \ end of print data. Defaults to \"\\\\\\\\n\".\n            style (Union[str,\
    \ Style], optional): A style to apply to output. Defaults to None.\n         \
    \   highlight (Optional[bool], optional): Enable automatic highlighting, or ``None``\
    \ to use\n                console default. Defaults to ``None``.\n        \"\"\
    \"\n        raw_output: str = sep.join(str(_object) for _object in objects)\n\
    \        self.print(\n            raw_output,\n            style=style,\n    \
    \        highlight=highlight,\n            emoji=False,\n            markup=False,\n\
    \            no_wrap=True,\n            overflow=\"ignore\",\n            crop=False,\n\
    \            end=end,\n        )\n\n    def print(\n        self,\n        *objects:\
    \ Any,\n        sep: str = \" \",\n        end: str = \"\\n\",\n        style:\
    \ Optional[Union[str, Style]] = None,\n        justify: Optional[JustifyMethod]\
    \ = None,\n        overflow: Optional[OverflowMethod] = None,\n        no_wrap:\
    \ Optional[bool] = None,\n        emoji: Optional[bool] = None,\n        markup:\
    \ Optional[bool] = None,\n        highlight: Optional[bool] = None,\n        width:\
    \ Optional[int] = None,\n        height: Optional[int] = None,\n        crop:\
    \ bool = True,\n        soft_wrap: Optional[bool] = None,\n        new_line_start:\
    \ bool = False,\n    ) -> None:\n        \"\"\"Print to the console.\n\n     \
    \   Args:\n            objects (positional args): Objects to log to the terminal.\n\
    \            sep (str, optional): String to write between print data. Defaults\
    \ to \" \".\n            end (str, optional): String to write at end of print\
    \ data. Defaults to \"\\\\\\\\n\".\n            style (Union[str, Style], optional):\
    \ A style to apply to output. Defaults to None.\n            justify (str, optional):\
    \ Justify method: \"default\", \"left\", \"right\", \"center\", or \"full\". Defaults\
    \ to ``None``.\n            overflow (str, optional): Overflow method: \"ignore\"\
    , \"crop\", \"fold\", or \"ellipsis\". Defaults to None.\n            no_wrap\
    \ (Optional[bool], optional): Disable word wrapping. Defaults to None.\n     \
    \       emoji (Optional[bool], optional): Enable emoji code, or ``None`` to use\
    \ console default. Defaults to ``None``.\n            markup (Optional[bool],\
    \ optional): Enable markup, or ``None`` to use console default. Defaults to ``None``.\n\
    \            highlight (Optional[bool], optional): Enable automatic highlighting,\
    \ or ``None`` to use console default. Defaults to ``None``.\n            width\
    \ (Optional[int], optional): Width of output, or ``None`` to auto-detect. Defaults\
    \ to ``None``.\n            crop (Optional[bool], optional): Crop output to width\
    \ of terminal. Defaults to True.\n            soft_wrap (bool, optional): Enable\
    \ soft wrap mode which disables word wrapping and cropping of text or ``None``\
    \ for\n                Console default. Defaults to ``None``.\n            new_line_start\
    \ (bool, False): Insert a new line at the start if the output contains more than\
    \ one line. Defaults to ``False``.\n        \"\"\"\n        if not objects:\n\
    \            objects = (NewLine(),)\n\n        if soft_wrap is None:\n       \
    \     soft_wrap = self.soft_wrap\n        if soft_wrap:\n            if no_wrap\
    \ is None:\n                no_wrap = True\n            if overflow is None:\n\
    \                overflow = \"ignore\"\n            crop = False\n        render_hooks\
    \ = self._render_hooks[:]\n        with self:\n            renderables = self._collect_renderables(\n\
    \                objects,\n                sep,\n                end,\n      \
    \          justify=justify,\n                emoji=emoji,\n                markup=markup,\n\
    \                highlight=highlight,\n            )\n            for hook in\
    \ render_hooks:\n                renderables = hook.process_renderables(renderables)\n\
    \            render_options = self.options.update(\n                justify=justify,\n\
    \                overflow=overflow,\n                width=min(width, self.width)\
    \ if width is not None else NO_CHANGE,\n                height=height,\n     \
    \           no_wrap=no_wrap,\n                markup=markup,\n               \
    \ highlight=highlight,\n            )\n\n            new_segments: List[Segment]\
    \ = []\n            extend = new_segments.extend\n            render = self.render\n\
    \            if style is None:\n                for renderable in renderables:\n\
    \                    extend(render(renderable, render_options))\n            else:\n\
    \                for renderable in renderables:\n                    extend(\n\
    \                        Segment.apply_style(\n                            render(renderable,\
    \ render_options), self.get_style(style)\n                        )\n        \
    \            )\n            if new_line_start:\n                if (\n       \
    \             len(\"\".join(segment.text for segment in new_segments).splitlines())\n\
    \                    > 1\n                ):\n                    new_segments.insert(0,\
    \ Segment.line())\n            if crop:\n                buffer_extend = self._buffer.extend\n\
    \                for line in Segment.split_and_crop_lines(\n                 \
    \   new_segments, self.width, pad=False\n                ):\n                \
    \    buffer_extend(line)\n            else:\n                self._buffer.extend(new_segments)\n\
    \n    def print_json(\n        self,\n        json: Optional[str] = None,\n  \
    \      *,\n        data: Any = None,\n        indent: Union[None, int, str] =\
    \ 2,\n        highlight: bool = True,\n        skip_keys: bool = False,\n    \
    \    ensure_ascii: bool = False,\n        check_circular: bool = True,\n     \
    \   allow_nan: bool = True,\n        default: Optional[Callable[[Any], Any]] =\
    \ None,\n        sort_keys: bool = False,\n    ) -> None:\n        \"\"\"Pretty\
    \ prints JSON. Output will be valid JSON.\n\n        Args:\n            json (Optional[str]):\
    \ A string containing JSON.\n            data (Any): If json is not supplied,\
    \ then encode this data.\n            indent (Union[None, int, str], optional):\
    \ Number of spaces to indent. Defaults to 2.\n            highlight (bool, optional):\
    \ Enable highlighting of output: Defaults to True.\n            skip_keys (bool,\
    \ optional): Skip keys not of a basic type. Defaults to False.\n            ensure_ascii\
    \ (bool, optional): Escape all non-ascii characters. Defaults to False.\n    \
    \        check_circular (bool, optional): Check for circular references. Defaults\
    \ to True.\n            allow_nan (bool, optional): Allow NaN and Infinity values.\
    \ Defaults to True.\n            default (Callable, optional): A callable that\
    \ converts values that can not be encoded\n                in to something that\
    \ can be JSON encoded. Defaults to None.\n            sort_keys (bool, optional):\
    \ Sort dictionary keys. Defaults to False.\n        \"\"\"\n        from rich.json\
    \ import JSON\n\n        if json is None:\n            json_renderable = JSON.from_data(\n\
    \                data,\n                indent=indent,\n                highlight=highlight,\n\
    \                skip_keys=skip_keys,\n                ensure_ascii=ensure_ascii,\n\
    \                check_circular=check_circular,\n                allow_nan=allow_nan,\n\
    \                default=default,\n                sort_keys=sort_keys,\n    \
    \        )\n        else:\n            if not isinstance(json, str):\n       \
    \         raise TypeError(\n                    f\"json must be str. Did you mean\
    \ print_json(data={json!r}) ?\"\n                )\n            json_renderable\
    \ = JSON(\n                json,\n                indent=indent,\n           \
    \     highlight=highlight,\n                skip_keys=skip_keys,\n           \
    \     ensure_ascii=ensure_ascii,\n                check_circular=check_circular,\n\
    \                allow_nan=allow_nan,\n                default=default,\n    \
    \            sort_keys=sort_keys,\n            )\n        self.print(json_renderable,\
    \ soft_wrap=True)\n\n    def update_screen(\n        self,\n        renderable:\
    \ RenderableType,\n        *,\n        region: Optional[Region] = None,\n    \
    \    options: Optional[ConsoleOptions] = None,\n    ) -> None:\n        \"\"\"\
    Update the screen at a given offset.\n\n        Args:\n            renderable\
    \ (RenderableType): A Rich renderable.\n            region (Region, optional):\
    \ Region of screen to update, or None for entire screen. Defaults to None.\n \
    \           x (int, optional): x offset. Defaults to 0.\n            y (int, optional):\
    \ y offset. Defaults to 0.\n\n        Raises:\n            errors.NoAltScreen:\
    \ If the Console isn't in alt screen mode.\n\n        \"\"\"\n        if not self.is_alt_screen:\n\
    \            raise errors.NoAltScreen(\"Alt screen must be enabled to call update_screen\"\
    )\n        render_options = options or self.options\n        if region is None:\n\
    \            x = y = 0\n            render_options = render_options.update_dimensions(\n\
    \                render_options.max_width, render_options.height or self.height\n\
    \            )\n        else:\n            x, y, width, height = region\n    \
    \        render_options = render_options.update_dimensions(width, height)\n\n\
    \        lines = self.render_lines(renderable, options=render_options)\n     \
    \   self.update_screen_lines(lines, x, y)\n\n    def update_screen_lines(\n  \
    \      self, lines: List[List[Segment]], x: int = 0, y: int = 0\n    ) -> None:\n\
    \        \"\"\"Update lines of the screen at a given offset.\n\n        Args:\n\
    \            lines (List[List[Segment]]): Rendered lines (as produced by :meth:`~rich.Console.render_lines`).\n\
    \            x (int, optional): x offset (column no). Defaults to 0.\n       \
    \     y (int, optional): y offset (column no). Defaults to 0.\n\n        Raises:\n\
    \            errors.NoAltScreen: If the Console isn't in alt screen mode.\n  \
    \      \"\"\"\n        if not self.is_alt_screen:\n            raise errors.NoAltScreen(\"\
    Alt screen must be enabled to call update_screen\")\n        screen_update = ScreenUpdate(lines,\
    \ x, y)\n        segments = self.render(screen_update)\n        self._buffer.extend(segments)\n\
    \        self._check_buffer()\n\n    def print_exception(\n        self,\n   \
    \     *,\n        width: Optional[int] = 100,\n        extra_lines: int = 3,\n\
    \        theme: Optional[str] = None,\n        word_wrap: bool = False,\n    \
    \    show_locals: bool = False,\n        suppress: Iterable[Union[str, ModuleType]]\
    \ = (),\n        max_frames: int = 100,\n    ) -> None:\n        \"\"\"Prints\
    \ a rich render of the last exception and traceback.\n\n        Args:\n      \
    \      width (Optional[int], optional): Number of characters used to render code.\
    \ Defaults to 100.\n            extra_lines (int, optional): Additional lines\
    \ of code to render. Defaults to 3.\n            theme (str, optional): Override\
    \ pygments theme used in traceback\n            word_wrap (bool, optional): Enable\
    \ word wrapping of long lines. Defaults to False.\n            show_locals (bool,\
    \ optional): Enable display of local variables. Defaults to False.\n         \
    \   suppress (Iterable[Union[str, ModuleType]]): Optional sequence of modules\
    \ or paths to exclude from traceback.\n            max_frames (int): Maximum number\
    \ of frames to show in a traceback, 0 for no maximum. Defaults to 100.\n     \
    \   \"\"\"\n        from .traceback import Traceback\n\n        traceback = Traceback(\n\
    \            width=width,\n            extra_lines=extra_lines,\n            theme=theme,\n\
    \            word_wrap=word_wrap,\n            show_locals=show_locals,\n    \
    \        suppress=suppress,\n            max_frames=max_frames,\n        )\n \
    \       self.print(traceback)\n\n    @staticmethod\n    def _caller_frame_info(\n\
    \        offset: int,\n        currentframe: Callable[[], Optional[FrameType]]\
    \ = inspect.currentframe,\n    ) -> Tuple[str, int, Dict[str, Any]]:\n       \
    \ \"\"\"Get caller frame information.\n\n        Args:\n            offset (int):\
    \ the caller offset within the current frame stack.\n            currentframe\
    \ (Callable[[], Optional[FrameType]], optional): the callable to use to\n    \
    \            retrieve the current frame. Defaults to ``inspect.currentframe``.\n\
    \n        Returns:\n            Tuple[str, int, Dict[str, Any]]: A tuple containing\
    \ the filename, the line number and\n                the dictionary of local variables\
    \ associated with the caller frame.\n\n        Raises:\n            RuntimeError:\
    \ If the stack offset is invalid.\n        \"\"\"\n        # Ignore the frame\
    \ of this local helper\n        offset += 1\n\n        frame = currentframe()\n\
    \        if frame is not None:\n            # Use the faster currentframe where\
    \ implemented\n            while offset and frame is not None:\n             \
    \   frame = frame.f_back\n                offset -= 1\n            assert frame\
    \ is not None\n            return frame.f_code.co_filename, frame.f_lineno, frame.f_locals\n\
    \        else:\n            # Fallback to the slower stack\n            frame_info\
    \ = inspect.stack()[offset]\n            return frame_info.filename, frame_info.lineno,\
    \ frame_info.frame.f_locals\n\n    def log(\n        self,\n        *objects:\
    \ Any,\n        sep: str = \" \",\n        end: str = \"\\n\",\n        style:\
    \ Optional[Union[str, Style]] = None,\n        justify: Optional[JustifyMethod]\
    \ = None,\n        emoji: Optional[bool] = None,\n        markup: Optional[bool]\
    \ = None,\n        highlight: Optional[bool] = None,\n        log_locals: bool\
    \ = False,\n        _stack_offset: int = 1,\n    ) -> None:\n        \"\"\"Log\
    \ rich content to the terminal.\n\n        Args:\n            objects (positional\
    \ args): Objects to log to the terminal.\n            sep (str, optional): String\
    \ to write between print data. Defaults to \" \".\n            end (str, optional):\
    \ String to write at end of print data. Defaults to \"\\\\\\\\n\".\n         \
    \   style (Union[str, Style], optional): A style to apply to output. Defaults\
    \ to None.\n            justify (str, optional): One of \"left\", \"right\", \"\
    center\", or \"full\". Defaults to ``None``.\n            emoji (Optional[bool],\
    \ optional): Enable emoji code, or ``None`` to use console default. Defaults to\
    \ None.\n            markup (Optional[bool], optional): Enable markup, or ``None``\
    \ to use console default. Defaults to None.\n            highlight (Optional[bool],\
    \ optional): Enable automatic highlighting, or ``None`` to use console default.\
    \ Defaults to None.\n            log_locals (bool, optional): Boolean to enable\
    \ logging of locals where ``log()``\n                was called. Defaults to False.\n\
    \            _stack_offset (int, optional): Offset of caller from end of call\
    \ stack. Defaults to 1.\n        \"\"\"\n        if not objects:\n           \
    \ objects = (NewLine(),)\n\n        render_hooks = self._render_hooks[:]\n\n \
    \       with self:\n            renderables = self._collect_renderables(\n   \
    \             objects,\n                sep,\n                end,\n         \
    \       justify=justify,\n                emoji=emoji,\n                markup=markup,\n\
    \                highlight=highlight,\n            )\n            if style is\
    \ not None:\n                renderables = [Styled(renderable, style) for renderable\
    \ in renderables]\n\n            filename, line_no, locals = self._caller_frame_info(_stack_offset)\n\
    \            link_path = None if filename.startswith(\"<\") else os.path.abspath(filename)\n\
    \            path = filename.rpartition(os.sep)[-1]\n            if log_locals:\n\
    \                locals_map = {\n                    key: value\n            \
    \        for key, value in locals.items()\n                    if not key.startswith(\"\
    __\")\n                }\n                renderables.append(render_scope(locals_map,\
    \ title=\"[i]locals\"))\n\n            renderables = [\n                self._log_render(\n\
    \                    self,\n                    renderables,\n               \
    \     log_time=self.get_datetime(),\n                    path=path,\n        \
    \            line_no=line_no,\n                    link_path=link_path,\n    \
    \            )\n            ]\n            for hook in render_hooks:\n       \
    \         renderables = hook.process_renderables(renderables)\n            new_segments:\
    \ List[Segment] = []\n            extend = new_segments.extend\n            render\
    \ = self.render\n            render_options = self.options\n            for renderable\
    \ in renderables:\n                extend(render(renderable, render_options))\n\
    \            buffer_extend = self._buffer.extend\n            for line in Segment.split_and_crop_lines(\n\
    \                new_segments, self.width, pad=False\n            ):\n       \
    \         buffer_extend(line)\n\n    def on_broken_pipe(self) -> None:\n     \
    \   \"\"\"This function is called when a `BrokenPipeError` is raised.\n\n    \
    \    This can occur when piping Textual output in Linux and macOS.\n        The\
    \ default implementation is to exit the app, but you could implement\n       \
    \ this method in a subclass to change the behavior.\n\n        See https://docs.python.org/3/library/signal.html#note-on-sigpipe\
    \ for details.\n        \"\"\"\n        self.quiet = True\n        devnull = os.open(os.devnull,\
    \ os.O_WRONLY)\n        os.dup2(devnull, sys.stdout.fileno())\n        raise SystemExit(1)\n\
    \n    def _check_buffer(self) -> None:\n        \"\"\"Check if the buffer may\
    \ be rendered. Render it if it can (e.g. Console.quiet is False)\n        Rendering\
    \ is supported on Windows, Unix and Jupyter environments. For\n        legacy\
    \ Windows consoles, the win32 API is called directly.\n        This method will\
    \ also record what it renders if recording is enabled via Console.record.\n  \
    \      \"\"\"\n        if self.quiet:\n            del self._buffer[:]\n     \
    \       return\n\n        try:\n            self._write_buffer()\n        except\
    \ BrokenPipeError:\n            self.on_broken_pipe()\n\n    def _write_buffer(self)\
    \ -> None:\n        \"\"\"Write the buffer to the output file.\"\"\"\n\n     \
    \   with self._lock:\n            if self.record and not self._buffer_index:\n\
    \                with self._record_buffer_lock:\n                    self._record_buffer.extend(self._buffer[:])\n\
    \n            if self._buffer_index == 0:\n                if self.is_jupyter:\
    \  # pragma: no cover\n                    from .jupyter import display\n\n  \
    \                  display(self._buffer, self._render_buffer(self._buffer[:]))\n\
    \                    del self._buffer[:]\n                else:\n            \
    \        if WINDOWS:\n                        use_legacy_windows_render = False\n\
    \                        if self.legacy_windows:\n                           \
    \ fileno = get_fileno(self.file)\n                            if fileno is not\
    \ None:\n                                use_legacy_windows_render = (\n     \
    \                               fileno in _STD_STREAMS_OUTPUT\n              \
    \                  )\n\n                        if use_legacy_windows_render:\n\
    \                            from rich._win32_console import LegacyWindowsTerm\n\
    \                            from rich._windows_renderer import legacy_windows_render\n\
    \n                            buffer = self._buffer[:]\n                     \
    \       if self.no_color and self._color_system:\n                           \
    \     buffer = list(Segment.remove_color(buffer))\n\n                        \
    \    legacy_windows_render(buffer, LegacyWindowsTerm(self.file))\n           \
    \             else:\n                            # Either a non-std stream on\
    \ legacy Windows, or modern Windows.\n                            text = self._render_buffer(self._buffer[:])\n\
    \                            # https://bugs.python.org/issue37871\n          \
    \                  # https://github.com/python/cpython/issues/82052\n        \
    \                    # We need to avoid writing more than 32Kb in a single write,\
    \ due to the above bug\n                            write = self.file.write\n\
    \                            # Worse case scenario, every character is 4 bytes\
    \ of utf-8\n                            MAX_WRITE = 32 * 1024 // 4\n         \
    \                   try:\n                                if len(text) <= MAX_WRITE:\n\
    \                                    write(text)\n                           \
    \     else:\n                                    batch: List[str] = []\n     \
    \                               batch_append = batch.append\n                \
    \                    size = 0\n                                    for line in\
    \ text.splitlines(True):\n                                        if size + len(line)\
    \ > MAX_WRITE and batch:\n                                            write(\"\
    \".join(batch))\n                                            batch.clear()\n \
    \                                           size = 0\n                       \
    \                 batch_append(line)\n                                       \
    \ size += len(line)\n                                    if batch:\n         \
    \                               write(\"\".join(batch))\n                    \
    \                    batch.clear()\n                            except UnicodeEncodeError\
    \ as error:\n                                error.reason = f\"{error.reason}\\\
    n*** You may need to add PYTHONIOENCODING=utf-8 to your environment ***\"\n  \
    \                              raise\n                    else:\n            \
    \            text = self._render_buffer(self._buffer[:])\n                   \
    \     try:\n                            self.file.write(text)\n              \
    \          except UnicodeEncodeError as error:\n                            error.reason\
    \ = f\"{error.reason}\\n*** You may need to add PYTHONIOENCODING=utf-8 to your\
    \ environment ***\"\n                            raise\n\n                   \
    \ self.file.flush()\n                    del self._buffer[:]\n\n    def _render_buffer(self,\
    \ buffer: Iterable[Segment]) -> str:\n        \"\"\"Render buffered output, and\
    \ clear buffer.\"\"\"\n        output: List[str] = []\n        append = output.append\n\
    \        color_system = self._color_system\n        legacy_windows = self.legacy_windows\n\
    \        not_terminal = not self.is_terminal\n        if self.no_color and color_system:\n\
    \            buffer = Segment.remove_color(buffer)\n        for text, style, control\
    \ in buffer:\n            if style:\n                append(\n               \
    \     style.render(\n                        text,\n                        color_system=color_system,\n\
    \                        legacy_windows=legacy_windows,\n                    )\n\
    \                )\n            elif not (not_terminal and control):\n       \
    \         append(text)\n\n        rendered = \"\".join(output)\n        return\
    \ rendered\n\n    def input(\n        self,\n        prompt: TextType = \"\",\n\
    \        *,\n        markup: bool = True,\n        emoji: bool = True,\n     \
    \   password: bool = False,\n        stream: Optional[TextIO] = None,\n    ) ->\
    \ str:\n        \"\"\"Displays a prompt and waits for input from the user. The\
    \ prompt may contain color / style.\n\n        It works in the same way as Python's\
    \ builtin :func:`input` function and provides elaborate line editing and history\
    \ features if Python's builtin :mod:`readline` module is previously loaded.\n\n\
    \        Args:\n            prompt (Union[str, Text]): Text to render in the prompt.\n\
    \            markup (bool, optional): Enable console markup (requires a str prompt).\
    \ Defaults to True.\n            emoji (bool, optional): Enable emoji (requires\
    \ a str prompt). Defaults to True.\n            password: (bool, optional): Hide\
    \ typed text. Defaults to False.\n            stream: (TextIO, optional): Optional\
    \ file to read input from (rather than stdin). Defaults to None.\n\n        Returns:\n\
    \            str: Text read from stdin.\n        \"\"\"\n        if prompt:\n\
    \            self.print(prompt, markup=markup, emoji=emoji, end=\"\")\n      \
    \  if password:\n            result = getpass(\"\", stream=stream)\n        else:\n\
    \            if stream:\n                result = stream.readline()\n        \
    \    else:\n                result = input()\n        return result\n\n    def\
    \ export_text(self, *, clear: bool = True, styles: bool = False) -> str:\n   \
    \     \"\"\"Generate text from console contents (requires record=True argument\
    \ in constructor).\n\n        Args:\n            clear (bool, optional): Clear\
    \ record buffer after exporting. Defaults to ``True``.\n            styles (bool,\
    \ optional): If ``True``, ansi escape codes will be included. ``False`` for plain\
    \ text.\n                Defaults to ``False``.\n\n        Returns:\n        \
    \    str: String containing console contents.\n\n        \"\"\"\n        assert\
    \ (\n            self.record\n        ), \"To export console contents set record=True\
    \ in the constructor or instance\"\n\n        with self._record_buffer_lock:\n\
    \            if styles:\n                text = \"\".join(\n                 \
    \   (style.render(text) if style else text)\n                    for text, style,\
    \ _ in self._record_buffer\n                )\n            else:\n           \
    \     text = \"\".join(\n                    segment.text\n                  \
    \  for segment in self._record_buffer\n                    if not segment.control\n\
    \                )\n            if clear:\n                del self._record_buffer[:]\n\
    \        return text\n\n    def save_text(self, path: str, *, clear: bool = True,\
    \ styles: bool = False) -> None:\n        \"\"\"Generate text from console and\
    \ save to a given location (requires record=True argument in constructor).\n\n\
    \        Args:\n            path (str): Path to write text files.\n          \
    \  clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.\n\
    \            styles (bool, optional): If ``True``, ansi style codes will be included.\
    \ ``False`` for plain text.\n                Defaults to ``False``.\n\n      \
    \  \"\"\"\n        text = self.export_text(clear=clear, styles=styles)\n     \
    \   with open(path, \"w\", encoding=\"utf-8\") as write_file:\n            write_file.write(text)\n\
    \n    def export_html(\n        self,\n        *,\n        theme: Optional[TerminalTheme]\
    \ = None,\n        clear: bool = True,\n        code_format: Optional[str] = None,\n\
    \        inline_styles: bool = False,\n    ) -> str:\n        \"\"\"Generate HTML\
    \ from console contents (requires record=True argument in constructor).\n\n  \
    \      Args:\n            theme (TerminalTheme, optional): TerminalTheme object\
    \ containing console colors.\n            clear (bool, optional): Clear record\
    \ buffer after exporting. Defaults to ``True``.\n            code_format (str,\
    \ optional): Format string to render HTML. In addition to '{foreground}',\n  \
    \              '{background}', and '{code}', should contain '{stylesheet}' if\
    \ inline_styles is ``False``.\n            inline_styles (bool, optional): If\
    \ ``True`` styles will be inlined in to spans, which makes files\n           \
    \     larger but easier to cut and paste markup. If ``False``, styles will be\
    \ embedded in a style tag.\n                Defaults to False.\n\n        Returns:\n\
    \            str: String containing console contents as HTML.\n        \"\"\"\n\
    \        assert (\n            self.record\n        ), \"To export console contents\
    \ set record=True in the constructor or instance\"\n        fragments: List[str]\
    \ = []\n        append = fragments.append\n        _theme = theme or DEFAULT_TERMINAL_THEME\n\
    \        stylesheet = \"\"\n\n        render_code_format = CONSOLE_HTML_FORMAT\
    \ if code_format is None else code_format\n\n        with self._record_buffer_lock:\n\
    \            if inline_styles:\n                for text, style, _ in Segment.filter_control(\n\
    \                    Segment.simplify(self._record_buffer)\n                ):\n\
    \                    text = escape(text)\n                    if style:\n    \
    \                    rule = style.get_html_style(_theme)\n                   \
    \     if style.link:\n                            text = f'<a href=\"{style.link}\"\
    >{text}</a>'\n                        text = f'<span style=\"{rule}\">{text}</span>'\
    \ if rule else text\n                    append(text)\n            else:\n   \
    \             styles: Dict[str, int] = {}\n                for text, style, _\
    \ in Segment.filter_control(\n                    Segment.simplify(self._record_buffer)\n\
    \                ):\n                    text = escape(text)\n               \
    \     if style:\n                        rule = style.get_html_style(_theme)\n\
    \                        style_number = styles.setdefault(rule, len(styles) +\
    \ 1)\n                        if style.link:\n                            text\
    \ = f'<a class=\"r{style_number}\" href=\"{style.link}\">{text}</a>'\n       \
    \                 else:\n                            text = f'<span class=\"r{style_number}\"\
    >{text}</span>'\n                    append(text)\n                stylesheet_rules:\
    \ List[str] = []\n                stylesheet_append = stylesheet_rules.append\n\
    \                for style_rule, style_number in styles.items():\n           \
    \         if style_rule:\n                        stylesheet_append(f\".r{style_number}\
    \ {{{style_rule}}}\")\n                stylesheet = \"\\n\".join(stylesheet_rules)\n\
    \n            rendered_code = render_code_format.format(\n                code=\"\
    \".join(fragments),\n                stylesheet=stylesheet,\n                foreground=_theme.foreground_color.hex,\n\
    \                background=_theme.background_color.hex,\n            )\n    \
    \        if clear:\n                del self._record_buffer[:]\n        return\
    \ rendered_code\n\n    def save_html(\n        self,\n        path: str,\n   \
    \     *,\n        theme: Optional[TerminalTheme] = None,\n        clear: bool\
    \ = True,\n        code_format: str = CONSOLE_HTML_FORMAT,\n        inline_styles:\
    \ bool = False,\n    ) -> None:\n        \"\"\"Generate HTML from console contents\
    \ and write to a file (requires record=True argument in constructor).\n\n    \
    \    Args:\n            path (str): Path to write html file.\n            theme\
    \ (TerminalTheme, optional): TerminalTheme object containing console colors.\n\
    \            clear (bool, optional): Clear record buffer after exporting. Defaults\
    \ to ``True``.\n            code_format (str, optional): Format string to render\
    \ HTML. In addition to '{foreground}',\n                '{background}', and '{code}',\
    \ should contain '{stylesheet}' if inline_styles is ``False``.\n            inline_styles\
    \ (bool, optional): If ``True`` styles will be inlined in to spans, which makes\
    \ files\n                larger but easier to cut and paste markup. If ``False``,\
    \ styles will be embedded in a style tag.\n                Defaults to False.\n\
    \n        \"\"\"\n        html = self.export_html(\n            theme=theme,\n\
    \            clear=clear,\n            code_format=code_format,\n            inline_styles=inline_styles,\n\
    \        )\n        with open(path, \"w\", encoding=\"utf-8\") as write_file:\n\
    \            write_file.write(html)\n\n    def export_svg(\n        self,\n  \
    \      *,\n        title: str = \"Rich\",\n        theme: Optional[TerminalTheme]\
    \ = None,\n        clear: bool = True,\n        code_format: str = CONSOLE_SVG_FORMAT,\n\
    \        font_aspect_ratio: float = 0.61,\n        unique_id: Optional[str] =\
    \ None,\n    ) -> str:\n        \"\"\"\n        Generate an SVG from the console\
    \ contents (requires record=True in Console constructor).\n\n        Args:\n \
    \           title (str, optional): The title of the tab in the output image\n\
    \            theme (TerminalTheme, optional): The ``TerminalTheme`` object to\
    \ use to style the terminal\n            clear (bool, optional): Clear record\
    \ buffer after exporting. Defaults to ``True``\n            code_format (str,\
    \ optional): Format string used to generate the SVG. Rich will inject a number\
    \ of variables\n                into the string in order to form the final SVG\
    \ output. The default template used and the variables\n                injected\
    \ by Rich can be found by inspecting the ``console.CONSOLE_SVG_FORMAT`` variable.\n\
    \            font_aspect_ratio (float, optional): The width to height ratio of\
    \ the font used in the ``code_format``\n                string. Defaults to 0.61,\
    \ which is the width to height ratio of Fira Code (the default font).\n      \
    \          If you aren't specifying a different font inside ``code_format``, you\
    \ probably don't need this.\n            unique_id (str, optional): unique id\
    \ that is used as the prefix for various elements (CSS styles, node\n        \
    \        ids). If not set, this defaults to a computed value based on the recorded\
    \ content.\n        \"\"\"\n\n        from rich.cells import cell_len\n\n    \
    \    style_cache: Dict[Style, str] = {}\n\n        def get_svg_style(style: Style)\
    \ -> str:\n            \"\"\"Convert a Style to CSS rules for SVG.\"\"\"\n   \
    \         if style in style_cache:\n                return style_cache[style]\n\
    \            css_rules = []\n            color = (\n                _theme.foreground_color\n\
    \                if (style.color is None or style.color.is_default)\n        \
    \        else style.color.get_truecolor(_theme)\n            )\n            bgcolor\
    \ = (\n                _theme.background_color\n                if (style.bgcolor\
    \ is None or style.bgcolor.is_default)\n                else style.bgcolor.get_truecolor(_theme)\n\
    \            )\n            if style.reverse:\n                color, bgcolor\
    \ = bgcolor, color\n            if style.dim:\n                color = blend_rgb(color,\
    \ bgcolor, 0.4)\n            css_rules.append(f\"fill: {color.hex}\")\n      \
    \      if style.bold:\n                css_rules.append(\"font-weight: bold\"\
    )\n            if style.italic:\n                css_rules.append(\"font-style:\
    \ italic;\")\n            if style.underline:\n                css_rules.append(\"\
    text-decoration: underline;\")\n            if style.strike:\n               \
    \ css_rules.append(\"text-decoration: line-through;\")\n\n            css = \"\
    ;\".join(css_rules)\n            style_cache[style] = css\n            return\
    \ css\n\n        _theme = theme or SVG_EXPORT_THEME\n\n        width = self.width\n\
    \        char_height = 20\n        char_width = char_height * font_aspect_ratio\n\
    \        line_height = char_height * 1.22\n\n        margin_top = 1\n        margin_right\
    \ = 1\n        margin_bottom = 1\n        margin_left = 1\n\n        padding_top\
    \ = 40\n        padding_right = 8\n        padding_bottom = 8\n        padding_left\
    \ = 8\n\n        padding_width = padding_left + padding_right\n        padding_height\
    \ = padding_top + padding_bottom\n        margin_width = margin_left + margin_right\n\
    \        margin_height = margin_top + margin_bottom\n\n        text_backgrounds:\
    \ List[str] = []\n        text_group: List[str] = []\n        classes: Dict[str,\
    \ int] = {}\n        style_no = 1\n\n        def escape_text(text: str) -> str:\n\
    \            \"\"\"HTML escape text and replace spaces with nbsp.\"\"\"\n    \
    \        return escape(text).replace(\" \", \"&#160;\")\n\n        def make_tag(\n\
    \            name: str, content: Optional[str] = None, **attribs: object\n   \
    \     ) -> str:\n            \"\"\"Make a tag from name, content, and attributes.\"\
    \"\"\n\n            def stringify(value: object) -> str:\n                if isinstance(value,\
    \ (float)):\n                    return format(value, \"g\")\n               \
    \ return str(value)\n\n            tag_attribs = \" \".join(\n               \
    \ f'{k.lstrip(\"_\").replace(\"_\", \"-\")}=\"{stringify(v)}\"'\n            \
    \    for k, v in attribs.items()\n            )\n            return (\n      \
    \          f\"<{name} {tag_attribs}>{content}</{name}>\"\n                if content\n\
    \                else f\"<{name} {tag_attribs}/>\"\n            )\n\n        with\
    \ self._record_buffer_lock:\n            segments = list(Segment.filter_control(self._record_buffer))\n\
    \            if clear:\n                self._record_buffer.clear()\n\n      \
    \  if unique_id is None:\n            unique_id = \"terminal-\" + str(\n     \
    \           zlib.adler32(\n                    (\"\".join(repr(segment) for segment\
    \ in segments)).encode(\n                        \"utf-8\",\n                \
    \        \"ignore\",\n                    )\n                    + title.encode(\"\
    utf-8\", \"ignore\")\n                )\n            )\n        y = 0\n      \
    \  for y, line in enumerate(Segment.split_and_crop_lines(segments, length=width)):\n\
    \            x = 0\n            for text, style, _control in line:\n         \
    \       style = style or Style()\n                rules = get_svg_style(style)\n\
    \                if rules not in classes:\n                    classes[rules]\
    \ = style_no\n                    style_no += 1\n                class_name =\
    \ f\"r{classes[rules]}\"\n\n                if style.reverse:\n              \
    \      has_background = True\n                    background = (\n           \
    \             _theme.foreground_color.hex\n                        if style.color\
    \ is None\n                        else style.color.get_truecolor(_theme).hex\n\
    \                    )\n                else:\n                    bgcolor = style.bgcolor\n\
    \                    has_background = bgcolor is not None and not bgcolor.is_default\n\
    \                    background = (\n                        _theme.background_color.hex\n\
    \                        if style.bgcolor is None\n                        else\
    \ style.bgcolor.get_truecolor(_theme).hex\n                    )\n\n         \
    \       text_length = cell_len(text)\n                if has_background:\n   \
    \                 text_backgrounds.append(\n                        make_tag(\n\
    \                            \"rect\",\n                            fill=background,\n\
    \                            x=x * char_width,\n                            y=y\
    \ * line_height + 1.5,\n                            width=char_width * text_length,\n\
    \                            height=line_height + 0.25,\n                    \
    \        shape_rendering=\"crispEdges\",\n                        )\n        \
    \            )\n\n                if text != \" \" * len(text):\n            \
    \        text_group.append(\n                        make_tag(\n             \
    \               \"text\",\n                            escape_text(text),\n  \
    \                          _class=f\"{unique_id}-{class_name}\",\n           \
    \                 x=x * char_width,\n                            y=y * line_height\
    \ + char_height,\n                            textLength=char_width * len(text),\n\
    \                            clip_path=f\"url(#{unique_id}-line-{y})\",\n    \
    \                    )\n                    )\n                x += cell_len(text)\n\
    \n        line_offsets = [line_no * line_height + 1.5 for line_no in range(y)]\n\
    \        lines = \"\\n\".join(\n            f\"\"\"<clipPath id=\"{unique_id}-line-{line_no}\"\
    >\n    {make_tag(\"rect\", x=0, y=offset, width=char_width * width, height=line_height\
    \ + 0.25)}\n            </clipPath>\"\"\"\n            for line_no, offset in\
    \ enumerate(line_offsets)\n        )\n\n        styles = \"\\n\".join(\n     \
    \       f\".{unique_id}-r{rule_no} {{ {css} }}\" for css, rule_no in classes.items()\n\
    \        )\n        backgrounds = \"\".join(text_backgrounds)\n        matrix\
    \ = \"\".join(text_group)\n\n        terminal_width = ceil(width * char_width\
    \ + padding_width)\n        terminal_height = (y + 1) * line_height + padding_height\n\
    \        chrome = make_tag(\n            \"rect\",\n            fill=_theme.background_color.hex,\n\
    \            stroke=\"rgba(255,255,255,0.35)\",\n            stroke_width=\"1\"\
    ,\n            x=margin_left,\n            y=margin_top,\n            width=terminal_width,\n\
    \            height=terminal_height,\n            rx=8,\n        )\n\n       \
    \ title_color = _theme.foreground_color.hex\n        if title:\n            chrome\
    \ += make_tag(\n                \"text\",\n                escape_text(title),\n\
    \                _class=f\"{unique_id}-title\",\n                fill=title_color,\n\
    \                text_anchor=\"middle\",\n                x=terminal_width //\
    \ 2,\n                y=margin_top + char_height + 6,\n            )\n       \
    \ chrome += f\"\"\"\n            <g transform=\"translate(26,22)\">\n        \
    \    <circle cx=\"0\" cy=\"0\" r=\"7\" fill=\"#ff5f57\"/>\n            <circle\
    \ cx=\"22\" cy=\"0\" r=\"7\" fill=\"#febc2e\"/>\n            <circle cx=\"44\"\
    \ cy=\"0\" r=\"7\" fill=\"#28c840\"/>\n            </g>\n        \"\"\"\n\n  \
    \      svg = code_format.format(\n            unique_id=unique_id,\n         \
    \   char_width=char_width,\n            char_height=char_height,\n           \
    \ line_height=line_height,\n            terminal_width=char_width * width - 1,\n\
    \            terminal_height=(y + 1) * line_height - 1,\n            width=terminal_width\
    \ + margin_width,\n            height=terminal_height + margin_height,\n     \
    \       terminal_x=margin_left + padding_left,\n            terminal_y=margin_top\
    \ + padding_top,\n            styles=styles,\n            chrome=chrome,\n   \
    \         backgrounds=backgrounds,\n            matrix=matrix,\n            lines=lines,\n\
    \        )\n        return svg\n\n    def save_svg(\n        self,\n        path:\
    \ str,\n        *,\n        title: str = \"Rich\",\n        theme: Optional[TerminalTheme]\
    \ = None,\n        clear: bool = True,\n        code_format: str = CONSOLE_SVG_FORMAT,\n\
    \        font_aspect_ratio: float = 0.61,\n        unique_id: Optional[str] =\
    \ None,\n    ) -> None:\n        \"\"\"Generate an SVG file from the console contents\
    \ (requires record=True in Console constructor).\n\n        Args:\n          \
    \  path (str): The path to write the SVG to.\n            title (str, optional):\
    \ The title of the tab in the output image\n            theme (TerminalTheme,\
    \ optional): The ``TerminalTheme`` object to use to style the terminal\n     \
    \       clear (bool, optional): Clear record buffer after exporting. Defaults\
    \ to ``True``\n            code_format (str, optional): Format string used to\
    \ generate the SVG. Rich will inject a number of variables\n                into\
    \ the string in order to form the final SVG output. The default template used\
    \ and the variables\n                injected by Rich can be found by inspecting\
    \ the ``console.CONSOLE_SVG_FORMAT`` variable.\n            font_aspect_ratio\
    \ (float, optional): The width to height ratio of the font used in the ``code_format``\n\
    \                string. Defaults to 0.61, which is the width to height ratio\
    \ of Fira Code (the default font).\n                If you aren't specifying a\
    \ different font inside ``code_format``, you probably don't need this.\n     \
    \       unique_id (str, optional): unique id that is used as the prefix for various\
    \ elements (CSS styles, node\n                ids). If not set, this defaults\
    \ to a computed value based on the recorded content.\n        \"\"\"\n       \
    \ svg = self.export_svg(\n            title=title,\n            theme=theme,\n\
    \            clear=clear,\n            code_format=code_format,\n            font_aspect_ratio=font_aspect_ratio,\n\
    \            unique_id=unique_id,\n        )\n        with open(path, \"w\", encoding=\"\
    utf-8\") as write_file:\n            write_file.write(svg)\n\n\ndef _svg_hash(svg_main_code:\
    \ str) -> str:\n    \"\"\"Returns a unique hash for the given SVG main code.\n\
    \n    Args:\n        svg_main_code (str): The content we're going to inject in\
    \ the SVG envelope.\n\n    Returns:\n        str: a hash of the given content\n\
    \    \"\"\"\n    return str(zlib.adler32(svg_main_code.encode()))\n\n\nif __name__\
    \ == \"__main__\":  # pragma: no cover\n    console = Console(record=True)\n\n\
    \    console.log(\n        \"JSONRPC [i]request[/i]\",\n        5,\n        1.3,\n\
    \        True,\n        False,\n        None,\n        {\n            \"jsonrpc\"\
    : \"2.0\",\n            \"method\": \"subtract\",\n            \"params\": {\"\
    minuend\": 42, \"subtrahend\": 23},\n            \"id\": 3,\n        },\n    )\n\
    \n    console.log(\"Hello, World!\", \"{'a': 1}\", repr(console))\n\n    console.print(\n\
    \        {\n            \"name\": None,\n            \"empty\": [],\n        \
    \    \"quiz\": {\n                \"sport\": {\n                    \"answered\"\
    : True,\n                    \"q1\": {\n                        \"question\":\
    \ \"Which one is correct team name in NBA?\",\n                        \"options\"\
    : [\n                            \"New York Bulls\",\n                       \
    \     \"Los Angeles Kings\",\n                            \"Golden State Warriors\"\
    ,\n                            \"Huston Rocket\",\n                        ],\n\
    \                        \"answer\": \"Huston Rocket\",\n                    },\n\
    \                },\n                \"maths\": {\n                    \"answered\"\
    : False,\n                    \"q1\": {\n                        \"question\"\
    : \"5 + 7 = ?\",\n                        \"options\": [10, 11, 12, 13],\n   \
    \                     \"answer\": 12,\n                    },\n              \
    \      \"q2\": {\n                        \"question\": \"12 - 8 = ?\",\n    \
    \                    \"options\": [1, 2, 3, 4],\n                        \"answer\"\
    : 4,\n                    },\n                },\n            },\n        }\n\
    \    )\n\n\n### Dependency File: text.py\nimport re\nfrom functools import partial,\
    \ reduce\nfrom math import gcd\nfrom operator import itemgetter\nfrom typing import\
    \ (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Dict,\n    Iterable,\n \
    \   List,\n    NamedTuple,\n    Optional,\n    Pattern,\n    Tuple,\n    Union,\n\
    )\n\nfrom ._loop import loop_last\nfrom ._pick import pick_bool\nfrom ._wrap import\
    \ divide_line\nfrom .align import AlignMethod\nfrom .cells import cell_len, set_cell_size\n\
    from .containers import Lines\nfrom .control import strip_control_codes\nfrom\
    \ .emoji import EmojiVariant\nfrom .jupyter import JupyterMixin\nfrom .measure\
    \ import Measurement\nfrom .segment import Segment\nfrom .style import Style,\
    \ StyleType\n\nif TYPE_CHECKING:  # pragma: no cover\n    from .console import\
    \ Console, ConsoleOptions, JustifyMethod, OverflowMethod\n\nDEFAULT_JUSTIFY: \"\
    JustifyMethod\" = \"default\"\nDEFAULT_OVERFLOW: \"OverflowMethod\" = \"fold\"\
    \n\n\n_re_whitespace = re.compile(r\"\\s+$\")\n\nTextType = Union[str, \"Text\"\
    ]\n\"\"\"A plain string or a :class:`Text` instance.\"\"\"\n\nGetStyleCallable\
    \ = Callable[[str], Optional[StyleType]]\n\n\nclass Span(NamedTuple):\n    \"\"\
    \"A marked up region in some text.\"\"\"\n\n    start: int\n    \"\"\"Span start\
    \ index.\"\"\"\n    end: int\n    \"\"\"Span end index.\"\"\"\n    style: Union[str,\
    \ Style]\n    \"\"\"Style associated with the span.\"\"\"\n\n    def __repr__(self)\
    \ -> str:\n        return f\"Span({self.start}, {self.end}, {self.style!r})\"\n\
    \n    def __bool__(self) -> bool:\n        return self.end > self.start\n\n  \
    \  def split(self, offset: int) -> Tuple[\"Span\", Optional[\"Span\"]]:\n    \
    \    \"\"\"Split a span in to 2 from a given offset.\"\"\"\n\n        if offset\
    \ < self.start:\n            return self, None\n        if offset >= self.end:\n\
    \            return self, None\n\n        start, end, style = self\n        span1\
    \ = Span(start, min(end, offset), style)\n        span2 = Span(span1.end, end,\
    \ style)\n        return span1, span2\n\n    def move(self, offset: int) -> \"\
    Span\":\n        \"\"\"Move start and end by a given offset.\n\n        Args:\n\
    \            offset (int): Number of characters to add to start and end.\n\n \
    \       Returns:\n            TextSpan: A new TextSpan with adjusted position.\n\
    \        \"\"\"\n        start, end, style = self\n        return Span(start +\
    \ offset, end + offset, style)\n\n    def right_crop(self, offset: int) -> \"\
    Span\":\n        \"\"\"Crop the span at the given offset.\n\n        Args:\n \
    \           offset (int): A value between start and end.\n\n        Returns:\n\
    \            Span: A new (possibly smaller) span.\n        \"\"\"\n        start,\
    \ end, style = self\n        if offset >= end:\n            return self\n    \
    \    return Span(start, min(offset, end), style)\n\n    def extend(self, cells:\
    \ int) -> \"Span\":\n        \"\"\"Extend the span by the given number of cells.\n\
    \n        Args:\n            cells (int): Additional space to add to end of span.\n\
    \n        Returns:\n            Span: A span.\n        \"\"\"\n        if cells:\n\
    \            start, end, style = self\n            return Span(start, end + cells,\
    \ style)\n        else:\n            return self\n\n\nclass Text(JupyterMixin):\n\
    \    \"\"\"Text with color / style.\n\n    Args:\n        text (str, optional):\
    \ Default unstyled text. Defaults to \"\".\n        style (Union[str, Style],\
    \ optional): Base style for text. Defaults to \"\".\n        justify (str, optional):\
    \ Justify method: \"left\", \"center\", \"full\", \"right\". Defaults to None.\n\
    \        overflow (str, optional): Overflow method: \"crop\", \"fold\", \"ellipsis\"\
    . Defaults to None.\n        no_wrap (bool, optional): Disable text wrapping,\
    \ or None for default. Defaults to None.\n        end (str, optional): Character\
    \ to end text with. Defaults to \"\\\\\\\\n\".\n        tab_size (int): Number\
    \ of spaces per tab, or ``None`` to use ``console.tab_size``. Defaults to None.\n\
    \        spans (List[Span], optional). A list of predefined style spans. Defaults\
    \ to None.\n    \"\"\"\n\n    __slots__ = [\n        \"_text\",\n        \"style\"\
    ,\n        \"justify\",\n        \"overflow\",\n        \"no_wrap\",\n       \
    \ \"end\",\n        \"tab_size\",\n        \"_spans\",\n        \"_length\",\n\
    \    ]\n\n    def __init__(\n        self,\n        text: str = \"\",\n      \
    \  style: Union[str, Style] = \"\",\n        *,\n        justify: Optional[\"\
    JustifyMethod\"] = None,\n        overflow: Optional[\"OverflowMethod\"] = None,\n\
    \        no_wrap: Optional[bool] = None,\n        end: str = \"\\n\",\n      \
    \  tab_size: Optional[int] = None,\n        spans: Optional[List[Span]] = None,\n\
    \    ) -> None:\n        sanitized_text = strip_control_codes(text)\n        self._text\
    \ = [sanitized_text]\n        self.style = style\n        self.justify: Optional[\"\
    JustifyMethod\"] = justify\n        self.overflow: Optional[\"OverflowMethod\"\
    ] = overflow\n        self.no_wrap = no_wrap\n        self.end = end\n       \
    \ self.tab_size = tab_size\n        self._spans: List[Span] = spans or []\n  \
    \      self._length: int = len(sanitized_text)\n\n    def __len__(self) -> int:\n\
    \        return self._length\n\n    def __bool__(self) -> bool:\n        return\
    \ bool(self._length)\n\n    def __str__(self) -> str:\n        return self.plain\n\
    \n    def __repr__(self) -> str:\n        return f\"<text {self.plain!r} {self._spans!r}\
    \ {self.style!r}>\"\n\n    def __add__(self, other: Any) -> \"Text\":\n      \
    \  if isinstance(other, (str, Text)):\n            result = self.copy()\n    \
    \        result.append(other)\n            return result\n        return NotImplemented\n\
    \n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other,\
    \ Text):\n            return NotImplemented\n        return self.plain == other.plain\
    \ and self._spans == other._spans\n\n    def __contains__(self, other: object)\
    \ -> bool:\n        if isinstance(other, str):\n            return other in self.plain\n\
    \        elif isinstance(other, Text):\n            return other.plain in self.plain\n\
    \        return False\n\n    def __getitem__(self, slice: Union[int, slice]) ->\
    \ \"Text\":\n        def get_text_at(offset: int) -> \"Text\":\n            _Span\
    \ = Span\n            text = Text(\n                self.plain[offset],\n    \
    \            spans=[\n                    _Span(0, 1, style)\n               \
    \     for start, end, style in self._spans\n                    if end > offset\
    \ >= start\n                ],\n                end=\"\",\n            )\n   \
    \         return text\n\n        if isinstance(slice, int):\n            return\
    \ get_text_at(slice)\n        else:\n            start, stop, step = slice.indices(len(self.plain))\n\
    \            if step == 1:\n                lines = self.divide([start, stop])\n\
    \                return lines[1]\n            else:\n                # This would\
    \ be a bit of work to implement efficiently\n                # For now, its not\
    \ required\n                raise TypeError(\"slices with step!=1 are not supported\"\
    )\n\n    @property\n    def cell_len(self) -> int:\n        \"\"\"Get the number\
    \ of cells required to render this text.\"\"\"\n        return cell_len(self.plain)\n\
    \n    @property\n    def markup(self) -> str:\n        \"\"\"Get console markup\
    \ to render this Text.\n\n        Returns:\n            str: A string potentially\
    \ creating markup tags.\n        \"\"\"\n        from .markup import escape\n\n\
    \        output: List[str] = []\n\n        plain = self.plain\n        markup_spans\
    \ = [\n            (0, False, self.style),\n            *((span.start, False,\
    \ span.style) for span in self._spans),\n            *((span.end, True, span.style)\
    \ for span in self._spans),\n            (len(plain), True, self.style),\n   \
    \     ]\n        markup_spans.sort(key=itemgetter(0, 1))\n        position = 0\n\
    \        append = output.append\n        for offset, closing, style in markup_spans:\n\
    \            if offset > position:\n                append(escape(plain[position:offset]))\n\
    \                position = offset\n            if style:\n                append(f\"\
    [/{style}]\" if closing else f\"[{style}]\")\n        markup = \"\".join(output)\n\
    \        return markup\n\n    @classmethod\n    def from_markup(\n        cls,\n\
    \        text: str,\n        *,\n        style: Union[str, Style] = \"\",\n  \
    \      emoji: bool = True,\n        emoji_variant: Optional[EmojiVariant] = None,\n\
    \        justify: Optional[\"JustifyMethod\"] = None,\n        overflow: Optional[\"\
    OverflowMethod\"] = None,\n        end: str = \"\\n\",\n    ) -> \"Text\":\n \
    \       \"\"\"Create Text instance from markup.\n\n        Args:\n           \
    \ text (str): A string containing console markup.\n            style (Union[str,\
    \ Style], optional): Base style for text. Defaults to \"\".\n            emoji\
    \ (bool, optional): Also render emoji code. Defaults to True.\n            emoji_variant\
    \ (str, optional): Optional emoji variant, either \"text\" or \"emoji\". Defaults\
    \ to None.\n            justify (str, optional): Justify method: \"left\", \"\
    center\", \"full\", \"right\". Defaults to None.\n            overflow (str, optional):\
    \ Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.\n     \
    \       end (str, optional): Character to end text with. Defaults to \"\\\\\\\\\
    n\".\n\n        Returns:\n            Text: A Text instance with markup rendered.\n\
    \        \"\"\"\n        from .markup import render\n\n        rendered_text =\
    \ render(text, style, emoji=emoji, emoji_variant=emoji_variant)\n        rendered_text.justify\
    \ = justify\n        rendered_text.overflow = overflow\n        rendered_text.end\
    \ = end\n        return rendered_text\n\n    @classmethod\n    def from_ansi(\n\
    \        cls,\n        text: str,\n        *,\n        style: Union[str, Style]\
    \ = \"\",\n        justify: Optional[\"JustifyMethod\"] = None,\n        overflow:\
    \ Optional[\"OverflowMethod\"] = None,\n        no_wrap: Optional[bool] = None,\n\
    \        end: str = \"\\n\",\n        tab_size: Optional[int] = 8,\n    ) -> \"\
    Text\":\n        \"\"\"Create a Text object from a string containing ANSI escape\
    \ codes.\n\n        Args:\n            text (str): A string containing escape\
    \ codes.\n            style (Union[str, Style], optional): Base style for text.\
    \ Defaults to \"\".\n            justify (str, optional): Justify method: \"left\"\
    , \"center\", \"full\", \"right\". Defaults to None.\n            overflow (str,\
    \ optional): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.\n\
    \            no_wrap (bool, optional): Disable text wrapping, or None for default.\
    \ Defaults to None.\n            end (str, optional): Character to end text with.\
    \ Defaults to \"\\\\\\\\n\".\n            tab_size (int): Number of spaces per\
    \ tab, or ``None`` to use ``console.tab_size``. Defaults to None.\n        \"\"\
    \"\n        from .ansi import AnsiDecoder\n\n        joiner = Text(\n        \
    \    \"\\n\",\n            justify=justify,\n            overflow=overflow,\n\
    \            no_wrap=no_wrap,\n            end=end,\n            tab_size=tab_size,\n\
    \            style=style,\n        )\n        decoder = AnsiDecoder()\n      \
    \  result = joiner.join(line for line in decoder.decode(text))\n        return\
    \ result\n\n    @classmethod\n    def styled(\n        cls,\n        text: str,\n\
    \        style: StyleType = \"\",\n        *,\n        justify: Optional[\"JustifyMethod\"\
    ] = None,\n        overflow: Optional[\"OverflowMethod\"] = None,\n    ) -> \"\
    Text\":\n        \"\"\"Construct a Text instance with a pre-applied styled. A\
    \ style applied in this way won't be used\n        to pad the text when it is\
    \ justified.\n\n        Args:\n            text (str): A string containing console\
    \ markup.\n            style (Union[str, Style]): Style to apply to the text.\
    \ Defaults to \"\".\n            justify (str, optional): Justify method: \"left\"\
    , \"center\", \"full\", \"right\". Defaults to None.\n            overflow (str,\
    \ optional): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.\n\
    \n        Returns:\n            Text: A text instance with a style applied to\
    \ the entire string.\n        \"\"\"\n        styled_text = cls(text, justify=justify,\
    \ overflow=overflow)\n        styled_text.stylize(style)\n        return styled_text\n\
    \n    @classmethod\n    def assemble(\n        cls,\n        *parts: Union[str,\
    \ \"Text\", Tuple[str, StyleType]],\n        style: Union[str, Style] = \"\",\n\
    \        justify: Optional[\"JustifyMethod\"] = None,\n        overflow: Optional[\"\
    OverflowMethod\"] = None,\n        no_wrap: Optional[bool] = None,\n        end:\
    \ str = \"\\n\",\n        tab_size: int = 8,\n        meta: Optional[Dict[str,\
    \ Any]] = None,\n    ) -> \"Text\":\n        \"\"\"Construct a text instance by\
    \ combining a sequence of strings with optional styles.\n        The positional\
    \ arguments should be either strings, or a tuple of string + style.\n\n      \
    \  Args:\n            style (Union[str, Style], optional): Base style for text.\
    \ Defaults to \"\".\n            justify (str, optional): Justify method: \"left\"\
    , \"center\", \"full\", \"right\". Defaults to None.\n            overflow (str,\
    \ optional): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.\n\
    \            no_wrap (bool, optional): Disable text wrapping, or None for default.\
    \ Defaults to None.\n            end (str, optional): Character to end text with.\
    \ Defaults to \"\\\\\\\\n\".\n            tab_size (int): Number of spaces per\
    \ tab, or ``None`` to use ``console.tab_size``. Defaults to None.\n          \
    \  meta (Dict[str, Any], optional). Meta data to apply to text, or None for no\
    \ meta data. Default to None\n\n        Returns:\n            Text: A new text\
    \ instance.\n        \"\"\"\n        text = cls(\n            style=style,\n \
    \           justify=justify,\n            overflow=overflow,\n            no_wrap=no_wrap,\n\
    \            end=end,\n            tab_size=tab_size,\n        )\n        append\
    \ = text.append\n        _Text = Text\n        for part in parts:\n          \
    \  if isinstance(part, (_Text, str)):\n                append(part)\n        \
    \    else:\n                append(*part)\n        if meta:\n            text.apply_meta(meta)\n\
    \        return text\n\n    @property\n    def plain(self) -> str:\n        \"\
    \"\"Get the text as a single string.\"\"\"\n        if len(self._text) != 1:\n\
    \            self._text[:] = [\"\".join(self._text)]\n        return self._text[0]\n\
    \n    @plain.setter\n    def plain(self, new_text: str) -> None:\n        \"\"\
    \"Set the text to a new value.\"\"\"\n        if new_text != self.plain:\n   \
    \         sanitized_text = strip_control_codes(new_text)\n            self._text[:]\
    \ = [sanitized_text]\n            old_length = self._length\n            self._length\
    \ = len(sanitized_text)\n            if old_length > self._length:\n         \
    \       self._trim_spans()\n\n    @property\n    def spans(self) -> List[Span]:\n\
    \        \"\"\"Get a reference to the internal list of spans.\"\"\"\n        return\
    \ self._spans\n\n    @spans.setter\n    def spans(self, spans: List[Span]) ->\
    \ None:\n        \"\"\"Set spans.\"\"\"\n        self._spans = spans[:]\n\n  \
    \  def blank_copy(self, plain: str = \"\") -> \"Text\":\n        \"\"\"Return\
    \ a new Text instance with copied metadata (but not the string or spans).\"\"\"\
    \n        copy_self = Text(\n            plain,\n            style=self.style,\n\
    \            justify=self.justify,\n            overflow=self.overflow,\n    \
    \        no_wrap=self.no_wrap,\n            end=self.end,\n            tab_size=self.tab_size,\n\
    \        )\n        return copy_self\n\n    def copy(self) -> \"Text\":\n    \
    \    \"\"\"Return a copy of this instance.\"\"\"\n        copy_self = Text(\n\
    \            self.plain,\n            style=self.style,\n            justify=self.justify,\n\
    \            overflow=self.overflow,\n            no_wrap=self.no_wrap,\n    \
    \        end=self.end,\n            tab_size=self.tab_size,\n        )\n     \
    \   copy_self._spans[:] = self._spans\n        return copy_self\n\n    def stylize(\n\
    \        self,\n        style: Union[str, Style],\n        start: int = 0,\n \
    \       end: Optional[int] = None,\n    ) -> None:\n        \"\"\"Apply a style\
    \ to the text, or a portion of the text.\n\n        Args:\n            style (Union[str,\
    \ Style]): Style instance or style definition to apply.\n            start (int):\
    \ Start offset (negative indexing is supported). Defaults to 0.\n            end\
    \ (Optional[int], optional): End offset (negative indexing is supported), or None\
    \ for end of text. Defaults to None.\n        \"\"\"\n        if style:\n    \
    \        length = len(self)\n            if start < 0:\n                start\
    \ = length + start\n            if end is None:\n                end = length\n\
    \            if end < 0:\n                end = length + end\n            if start\
    \ >= length or end <= start:\n                # Span not in text or not valid\n\
    \                return\n            self._spans.append(Span(start, min(length,\
    \ end), style))\n\n    def stylize_before(\n        self,\n        style: Union[str,\
    \ Style],\n        start: int = 0,\n        end: Optional[int] = None,\n    )\
    \ -> None:\n        \"\"\"Apply a style to the text, or a portion of the text.\
    \ Styles will be applied before other styles already present.\n\n        Args:\n\
    \            style (Union[str, Style]): Style instance or style definition to\
    \ apply.\n            start (int): Start offset (negative indexing is supported).\
    \ Defaults to 0.\n            end (Optional[int], optional): End offset (negative\
    \ indexing is supported), or None for end of text. Defaults to None.\n       \
    \ \"\"\"\n        if style:\n            length = len(self)\n            if start\
    \ < 0:\n                start = length + start\n            if end is None:\n\
    \                end = length\n            if end < 0:\n                end =\
    \ length + end\n            if start >= length or end <= start:\n            \
    \    # Span not in text or not valid\n                return\n            self._spans.insert(0,\
    \ Span(start, min(length, end), style))\n\n    def apply_meta(\n        self,\
    \ meta: Dict[str, Any], start: int = 0, end: Optional[int] = None\n    ) -> None:\n\
    \        \"\"\"Apply metadata to the text, or a portion of the text.\n\n     \
    \   Args:\n            meta (Dict[str, Any]): A dict of meta information.\n  \
    \          start (int): Start offset (negative indexing is supported). Defaults\
    \ to 0.\n            end (Optional[int], optional): End offset (negative indexing\
    \ is supported), or None for end of text. Defaults to None.\n\n        \"\"\"\n\
    \        style = Style.from_meta(meta)\n        self.stylize(style, start=start,\
    \ end=end)\n\n    def on(self, meta: Optional[Dict[str, Any]] = None, **handlers:\
    \ Any) -> \"Text\":\n        \"\"\"Apply event handlers (used by Textual project).\n\
    \n        Example:\n            >>> from rich.text import Text\n            >>>\
    \ text = Text(\"hello world\")\n            >>> text.on(click=\"view.toggle('world')\"\
    )\n\n        Args:\n            meta (Dict[str, Any]): Mapping of meta information.\n\
    \            **handlers: Keyword args are prefixed with \"@\" to defined handlers.\n\
    \n        Returns:\n            Text: Self is returned to method may be chained.\n\
    \        \"\"\"\n        meta = {} if meta is None else meta\n        meta.update({f\"\
    @{key}\": value for key, value in handlers.items()})\n        self.stylize(Style.from_meta(meta))\n\
    \        return self\n\n    def remove_suffix(self, suffix: str) -> None:\n  \
    \      \"\"\"Remove a suffix if it exists.\n\n        Args:\n            suffix\
    \ (str): Suffix to remove.\n        \"\"\"\n        if self.plain.endswith(suffix):\n\
    \            self.right_crop(len(suffix))\n\n    def get_style_at_offset(self,\
    \ console: \"Console\", offset: int) -> Style:\n        \"\"\"Get the style of\
    \ a character at give offset.\n\n        Args:\n            console (~Console):\
    \ Console where text will be rendered.\n            offset (int): Offset in to\
    \ text (negative indexing supported)\n\n        Returns:\n            Style: A\
    \ Style instance.\n        \"\"\"\n        # TODO: This is a little inefficient,\
    \ it is only used by full justify\n        if offset < 0:\n            offset\
    \ = len(self) + offset\n        get_style = console.get_style\n        style =\
    \ get_style(self.style).copy()\n        for start, end, span_style in self._spans:\n\
    \            if end > offset >= start:\n                style += get_style(span_style,\
    \ default=\"\")\n        return style\n\n    def extend_style(self, spaces: int)\
    \ -> None:\n        \"\"\"Extend the Text given number of spaces where the spaces\
    \ have the same style as the last character.\n\n        Args:\n            spaces\
    \ (int): Number of spaces to add to the Text.\n        \"\"\"\n        if spaces\
    \ <= 0:\n            return\n        spans = self.spans\n        new_spaces =\
    \ \" \" * spaces\n        if spans:\n            end_offset = len(self)\n    \
    \        self._spans[:] = [\n                span.extend(spaces) if span.end >=\
    \ end_offset else span\n                for span in spans\n            ]\n   \
    \         self._text.append(new_spaces)\n            self._length += spaces\n\
    \        else:\n            self.plain += new_spaces\n\n    def highlight_regex(\n\
    \        self,\n        re_highlight: Union[Pattern[str], str],\n        style:\
    \ Optional[Union[GetStyleCallable, StyleType]] = None,\n        *,\n        style_prefix:\
    \ str = \"\",\n    ) -> int:\n        \"\"\"Highlight text with a regular expression,\
    \ where group names are\n        translated to styles.\n\n        Args:\n    \
    \        re_highlight (Union[re.Pattern, str]): A regular expression object or\
    \ string.\n            style (Union[GetStyleCallable, StyleType]): Optional style\
    \ to apply to whole match, or a callable\n                which accepts the matched\
    \ text and returns a style. Defaults to None.\n            style_prefix (str,\
    \ optional): Optional prefix to add to style group names.\n\n        Returns:\n\
    \            int: Number of regex matches\n        \"\"\"\n        count = 0\n\
    \        append_span = self._spans.append\n        _Span = Span\n        plain\
    \ = self.plain\n        if isinstance(re_highlight, str):\n            re_highlight\
    \ = re.compile(re_highlight)\n        for match in re_highlight.finditer(plain):\n\
    \            get_span = match.span\n            if style:\n                start,\
    \ end = get_span()\n                match_style = style(plain[start:end]) if callable(style)\
    \ else style\n                if match_style is not None and end > start:\n  \
    \                  append_span(_Span(start, end, match_style))\n\n           \
    \ count += 1\n            for name in match.groupdict().keys():\n            \
    \    start, end = get_span(name)\n                if start != -1 and end > start:\n\
    \                    append_span(_Span(start, end, f\"{style_prefix}{name}\"))\n\
    \        return count\n\n    def highlight_words(\n        self,\n        words:\
    \ Iterable[str],\n        style: Union[str, Style],\n        *,\n        case_sensitive:\
    \ bool = True,\n    ) -> int:\n        \"\"\"Highlight words with a style.\n\n\
    \        Args:\n            words (Iterable[str]): Words to highlight.\n     \
    \       style (Union[str, Style]): Style to apply.\n            case_sensitive\
    \ (bool, optional): Enable case sensitive matching. Defaults to True.\n\n    \
    \    Returns:\n            int: Number of words highlighted.\n        \"\"\"\n\
    \        re_words = \"|\".join(re.escape(word) for word in words)\n        add_span\
    \ = self._spans.append\n        count = 0\n        _Span = Span\n        for match\
    \ in re.finditer(\n            re_words, self.plain, flags=0 if case_sensitive\
    \ else re.IGNORECASE\n        ):\n            start, end = match.span(0)\n   \
    \         add_span(_Span(start, end, style))\n            count += 1\n       \
    \ return count\n\n    def rstrip(self) -> None:\n        \"\"\"Strip whitespace\
    \ from end of text.\"\"\"\n        self.plain = self.plain.rstrip()\n\n    def\
    \ rstrip_end(self, size: int) -> None:\n        \"\"\"Remove whitespace beyond\
    \ a certain width at the end of the text.\n\n        Args:\n            size (int):\
    \ The desired size of the text.\n        \"\"\"\n        text_length = len(self)\n\
    \        if text_length > size:\n            excess = text_length - size\n   \
    \         whitespace_match = _re_whitespace.search(self.plain)\n            if\
    \ whitespace_match is not None:\n                whitespace_count = len(whitespace_match.group(0))\n\
    \                self.right_crop(min(whitespace_count, excess))\n\n    def set_length(self,\
    \ new_length: int) -> None:\n        \"\"\"Set new length of the text, clipping\
    \ or padding is required.\"\"\"\n        length = len(self)\n        if length\
    \ != new_length:\n            if length < new_length:\n                self.pad_right(new_length\
    \ - length)\n            else:\n                self.right_crop(length - new_length)\n\
    \n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\
    \n    ) -> Iterable[Segment]:\n        tab_size: int = console.tab_size if self.tab_size\
    \ is None else self.tab_size\n        justify = self.justify or options.justify\
    \ or DEFAULT_JUSTIFY\n\n        overflow = self.overflow or options.overflow or\
    \ DEFAULT_OVERFLOW\n\n        lines = self.wrap(\n            console,\n     \
    \       options.max_width,\n            justify=justify,\n            overflow=overflow,\n\
    \            tab_size=tab_size or 8,\n            no_wrap=pick_bool(self.no_wrap,\
    \ options.no_wrap, False),\n        )\n        all_lines = Text(\"\\n\").join(lines)\n\
    \        yield from all_lines.render(console, end=self.end)\n\n    def __rich_measure__(\n\
    \        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Measurement:\n\
    \        text = self.plain\n        lines = text.splitlines()\n        max_text_width\
    \ = max(cell_len(line) for line in lines) if lines else 0\n        words = text.split()\n\
    \        min_text_width = (\n            max(cell_len(word) for word in words)\
    \ if words else max_text_width\n        )\n        return Measurement(min_text_width,\
    \ max_text_width)\n\n    def render(self, console: \"Console\", end: str = \"\"\
    ) -> Iterable[\"Segment\"]:\n        \"\"\"Render the text as Segments.\n\n  \
    \      Args:\n            console (Console): Console instance.\n            end\
    \ (Optional[str], optional): Optional end character.\n\n        Returns:\n   \
    \         Iterable[Segment]: Result of render that may be written to the console.\n\
    \        \"\"\"\n        _Segment = Segment\n        text = self.plain\n     \
    \   if not self._spans:\n            yield Segment(text)\n            if end:\n\
    \                yield _Segment(end)\n            return\n        get_style =\
    \ partial(console.get_style, default=Style.null())\n\n        enumerated_spans\
    \ = list(enumerate(self._spans, 1))\n        style_map = {index: get_style(span.style)\
    \ for index, span in enumerated_spans}\n        style_map[0] = get_style(self.style)\n\
    \n        spans = [\n            (0, False, 0),\n            *((span.start, False,\
    \ index) for index, span in enumerated_spans),\n            *((span.end, True,\
    \ index) for index, span in enumerated_spans),\n            (len(text), True,\
    \ 0),\n        ]\n        spans.sort(key=itemgetter(0, 1))\n\n        stack: List[int]\
    \ = []\n        stack_append = stack.append\n        stack_pop = stack.remove\n\
    \n        style_cache: Dict[Tuple[Style, ...], Style] = {}\n        style_cache_get\
    \ = style_cache.get\n        combine = Style.combine\n\n        def get_current_style()\
    \ -> Style:\n            \"\"\"Construct current style from stack.\"\"\"\n   \
    \         styles = tuple(style_map[_style_id] for _style_id in sorted(stack))\n\
    \            cached_style = style_cache_get(styles)\n            if cached_style\
    \ is not None:\n                return cached_style\n            current_style\
    \ = combine(styles)\n            style_cache[styles] = current_style\n       \
    \     return current_style\n\n        for (offset, leaving, style_id), (next_offset,\
    \ _, _) in zip(spans, spans[1:]):\n            if leaving:\n                stack_pop(style_id)\n\
    \            else:\n                stack_append(style_id)\n            if next_offset\
    \ > offset:\n                yield _Segment(text[offset:next_offset], get_current_style())\n\
    \        if end:\n            yield _Segment(end)\n\n    def join(self, lines:\
    \ Iterable[\"Text\"]) -> \"Text\":\n        \"\"\"Join text together with this\
    \ instance as the separator.\n\n        Args:\n            lines (Iterable[Text]):\
    \ An iterable of Text instances to join.\n\n        Returns:\n            Text:\
    \ A new text instance containing join text.\n        \"\"\"\n\n        new_text\
    \ = self.blank_copy()\n\n        def iter_text() -> Iterable[\"Text\"]:\n    \
    \        if self.plain:\n                for last, line in loop_last(lines):\n\
    \                    yield line\n                    if not last:\n          \
    \              yield self\n            else:\n                yield from lines\n\
    \n        extend_text = new_text._text.extend\n        append_span = new_text._spans.append\n\
    \        extend_spans = new_text._spans.extend\n        offset = 0\n        _Span\
    \ = Span\n\n        for text in iter_text():\n            extend_text(text._text)\n\
    \            if text.style:\n                append_span(_Span(offset, offset\
    \ + len(text), text.style))\n            extend_spans(\n                _Span(offset\
    \ + start, offset + end, style)\n                for start, end, style in text._spans\n\
    \            )\n            offset += len(text)\n        new_text._length = offset\n\
    \        return new_text\n\n    def expand_tabs(self, tab_size: Optional[int]\
    \ = None) -> None:\n        \"\"\"Converts tabs to spaces.\n\n        Args:\n\
    \            tab_size (int, optional): Size of tabs. Defaults to 8.\n\n      \
    \  \"\"\"\n        if \"\\t\" not in self.plain:\n            return\n       \
    \ if tab_size is None:\n            tab_size = self.tab_size\n        if tab_size\
    \ is None:\n            tab_size = 8\n\n        new_text: List[Text] = []\n  \
    \      append = new_text.append\n\n        for line in self.split(\"\\n\", include_separator=True):\n\
    \            if \"\\t\" not in line.plain:\n                append(line)\n   \
    \         else:\n                cell_position = 0\n                parts = line.split(\"\
    \\t\", include_separator=True)\n                for part in parts:\n         \
    \           if part.plain.endswith(\"\\t\"):\n                        part._text[-1]\
    \ = part._text[-1][:-1] + \" \"\n                        cell_position += part.cell_len\n\
    \                        tab_remainder = cell_position % tab_size\n          \
    \              if tab_remainder:\n                            spaces = tab_size\
    \ - tab_remainder\n                            part.extend_style(spaces)\n   \
    \                         cell_position += spaces\n                    else:\n\
    \                        cell_position += part.cell_len\n                    append(part)\n\
    \n        result = Text(\"\").join(new_text)\n\n        self._text = [result.plain]\n\
    \        self._length = len(self.plain)\n        self._spans[:] = result._spans\n\
    \n    def truncate(\n        self,\n        max_width: int,\n        *,\n    \
    \    overflow: Optional[\"OverflowMethod\"] = None,\n        pad: bool = False,\n\
    \    ) -> None:\n        \"\"\"Truncate text if it is longer that a given width.\n\
    \n        Args:\n            max_width (int): Maximum number of characters in\
    \ text.\n            overflow (str, optional): Overflow method: \"crop\", \"fold\"\
    , or \"ellipsis\". Defaults to None, to use self.overflow.\n            pad (bool,\
    \ optional): Pad with spaces if the length is less than max_width. Defaults to\
    \ False.\n        \"\"\"\n        _overflow = overflow or self.overflow or DEFAULT_OVERFLOW\n\
    \        if _overflow != \"ignore\":\n            length = cell_len(self.plain)\n\
    \            if length > max_width:\n                if _overflow == \"ellipsis\"\
    :\n                    self.plain = set_cell_size(self.plain, max_width - 1) +\
    \ \"â¦\"\n                else:\n                    self.plain = set_cell_size(self.plain,\
    \ max_width)\n            if pad and length < max_width:\n                spaces\
    \ = max_width - length\n                self._text = [f\"{self.plain}{' ' * spaces}\"\
    ]\n                self._length = len(self.plain)\n\n    def _trim_spans(self)\
    \ -> None:\n        \"\"\"Remove or modify any spans that are over the end of\
    \ the text.\"\"\"\n        max_offset = len(self.plain)\n        _Span = Span\n\
    \        self._spans[:] = [\n            (\n                span\n           \
    \     if span.end < max_offset\n                else _Span(span.start, min(max_offset,\
    \ span.end), span.style)\n            )\n            for span in self._spans\n\
    \            if span.start < max_offset\n        ]\n\n    def pad(self, count:\
    \ int, character: str = \" \") -> None:\n        \"\"\"Pad left and right with\
    \ a given number of characters.\n\n        Args:\n            count (int): Width\
    \ of padding.\n            character (str): The character to pad with. Must be\
    \ a string of length 1.\n        \"\"\"\n        assert len(character) == 1, \"\
    Character must be a string of length 1\"\n        if count:\n            pad_characters\
    \ = character * count\n            self.plain = f\"{pad_characters}{self.plain}{pad_characters}\"\
    \n            _Span = Span\n            self._spans[:] = [\n                _Span(start\
    \ + count, end + count, style)\n                for start, end, style in self._spans\n\
    \            ]\n\n    def pad_left(self, count: int, character: str = \" \") ->\
    \ None:\n        \"\"\"Pad the left with a given character.\n\n        Args:\n\
    \            count (int): Number of characters to pad.\n            character\
    \ (str, optional): Character to pad with. Defaults to \" \".\n        \"\"\"\n\
    \        assert len(character) == 1, \"Character must be a string of length 1\"\
    \n        if count:\n            self.plain = f\"{character * count}{self.plain}\"\
    \n            _Span = Span\n            self._spans[:] = [\n                _Span(start\
    \ + count, end + count, style)\n                for start, end, style in self._spans\n\
    \            ]\n\n    def pad_right(self, count: int, character: str = \" \")\
    \ -> None:\n        \"\"\"Pad the right with a given character.\n\n        Args:\n\
    \            count (int): Number of characters to pad.\n            character\
    \ (str, optional): Character to pad with. Defaults to \" \".\n        \"\"\"\n\
    \        assert len(character) == 1, \"Character must be a string of length 1\"\
    \n        if count:\n            self.plain = f\"{self.plain}{character * count}\"\
    \n\n    def align(self, align: AlignMethod, width: int, character: str = \" \"\
    ) -> None:\n        \"\"\"Align text to a given width.\n\n        Args:\n    \
    \        align (AlignMethod): One of \"left\", \"center\", or \"right\".\n   \
    \         width (int): Desired width.\n            character (str, optional):\
    \ Character to pad with. Defaults to \" \".\n        \"\"\"\n        self.truncate(width)\n\
    \        excess_space = width - cell_len(self.plain)\n        if excess_space:\n\
    \            if align == \"left\":\n                self.pad_right(excess_space,\
    \ character)\n            elif align == \"center\":\n                left = excess_space\
    \ // 2\n                self.pad_left(left, character)\n                self.pad_right(excess_space\
    \ - left, character)\n            else:\n                self.pad_left(excess_space,\
    \ character)\n\n    def append(\n        self, text: Union[\"Text\", str], style:\
    \ Optional[Union[str, \"Style\"]] = None\n    ) -> \"Text\":\n        \"\"\"Add\
    \ text with an optional style.\n\n        Args:\n            text (Union[Text,\
    \ str]): A str or Text to append.\n            style (str, optional): A style\
    \ name. Defaults to None.\n\n        Returns:\n            Text: Returns self\
    \ for chaining.\n        \"\"\"\n\n        if not isinstance(text, (str, Text)):\n\
    \            raise TypeError(\"Only str or Text can be appended to Text\")\n\n\
    \        if len(text):\n            if isinstance(text, str):\n              \
    \  sanitized_text = strip_control_codes(text)\n                self._text.append(sanitized_text)\n\
    \                offset = len(self)\n                text_length = len(sanitized_text)\n\
    \                if style:\n                    self._spans.append(Span(offset,\
    \ offset + text_length, style))\n                self._length += text_length\n\
    \            elif isinstance(text, Text):\n                _Span = Span\n    \
    \            if style is not None:\n                    raise ValueError(\n  \
    \                      \"style must not be set when appending Text instance\"\n\
    \                    )\n                text_length = self._length\n         \
    \       if text.style:\n                    self._spans.append(\n            \
    \            _Span(text_length, text_length + len(text), text.style)\n       \
    \             )\n                self._text.append(text.plain)\n             \
    \   self._spans.extend(\n                    _Span(start + text_length, end +\
    \ text_length, style)\n                    for start, end, style in text._spans.copy()\n\
    \                )\n                self._length += len(text)\n        return\
    \ self\n\n    def append_text(self, text: \"Text\") -> \"Text\":\n        \"\"\
    \"Append another Text instance. This method is more performant that Text.append,\
    \ but\n        only works for Text.\n\n        Args:\n            text (Text):\
    \ The Text instance to append to this instance.\n\n        Returns:\n        \
    \    Text: Returns self for chaining.\n        \"\"\"\n        _Span = Span\n\
    \        text_length = self._length\n        if text.style:\n            self._spans.append(_Span(text_length,\
    \ text_length + len(text), text.style))\n        self._text.append(text.plain)\n\
    \        self._spans.extend(\n            _Span(start + text_length, end + text_length,\
    \ style)\n            for start, end, style in text._spans.copy()\n        )\n\
    \        self._length += len(text)\n        return self\n\n    def append_tokens(\n\
    \        self, tokens: Iterable[Tuple[str, Optional[StyleType]]]\n    ) -> \"\
    Text\":\n        \"\"\"Append iterable of str and style. Style may be a Style\
    \ instance or a str style definition.\n\n        Args:\n            tokens (Iterable[Tuple[str,\
    \ Optional[StyleType]]]): An iterable of tuples containing str content and style.\n\
    \n        Returns:\n            Text: Returns self for chaining.\n        \"\"\
    \"\n        append_text = self._text.append\n        append_span = self._spans.append\n\
    \        _Span = Span\n        offset = len(self)\n        for content, style\
    \ in tokens:\n            content = strip_control_codes(content)\n           \
    \ append_text(content)\n            if style:\n                append_span(_Span(offset,\
    \ offset + len(content), style))\n            offset += len(content)\n       \
    \ self._length = offset\n        return self\n\n    def copy_styles(self, text:\
    \ \"Text\") -> None:\n        \"\"\"Copy styles from another Text instance.\n\n\
    \        Args:\n            text (Text): A Text instance to copy styles from,\
    \ must be the same length.\n        \"\"\"\n        self._spans.extend(text._spans)\n\
    \n    def split(\n        self,\n        separator: str = \"\\n\",\n        *,\n\
    \        include_separator: bool = False,\n        allow_blank: bool = False,\n\
    \    ) -> Lines:\n        \"\"\"Split rich text in to lines, preserving styles.\n\
    \n        Args:\n            separator (str, optional): String to split on. Defaults\
    \ to \"\\\\\\\\n\".\n            include_separator (bool, optional): Include the\
    \ separator in the lines. Defaults to False.\n            allow_blank (bool, optional):\
    \ Return a blank line if the text ends with a separator. Defaults to False.\n\n\
    \        Returns:\n            List[RichText]: A list of rich text, one per line\
    \ of the original.\n        \"\"\"\n        assert separator, \"separator must\
    \ not be empty\"\n\n        text = self.plain\n        if separator not in text:\n\
    \            return Lines([self.copy()])\n\n        if include_separator:\n  \
    \          lines = self.divide(\n                match.end() for match in re.finditer(re.escape(separator),\
    \ text)\n            )\n        else:\n\n            def flatten_spans() -> Iterable[int]:\n\
    \                for match in re.finditer(re.escape(separator), text):\n     \
    \               start, end = match.span()\n                    yield start\n \
    \                   yield end\n\n            lines = Lines(\n                line\
    \ for line in self.divide(flatten_spans()) if line.plain != separator\n      \
    \      )\n\n        if not allow_blank and text.endswith(separator):\n       \
    \     lines.pop()\n\n        return lines\n\n    def divide(self, offsets: Iterable[int])\
    \ -> Lines:\n        \"\"\"Divide text in to a number of lines at given offsets.\n\
    \n        Args:\n            offsets (Iterable[int]): Offsets used to divide text.\n\
    \n        Returns:\n            Lines: New RichText instances between offsets.\n\
    \        \"\"\"\n        _offsets = list(offsets)\n\n        if not _offsets:\n\
    \            return Lines([self.copy()])\n\n        text = self.plain\n      \
    \  text_length = len(text)\n        divide_offsets = [0, *_offsets, text_length]\n\
    \        line_ranges = list(zip(divide_offsets, divide_offsets[1:]))\n\n     \
    \   style = self.style\n        justify = self.justify\n        overflow = self.overflow\n\
    \        _Text = Text\n        new_lines = Lines(\n            _Text(\n      \
    \          text[start:end],\n                style=style,\n                justify=justify,\n\
    \                overflow=overflow,\n            )\n            for start, end\
    \ in line_ranges\n        )\n        if not self._spans:\n            return new_lines\n\
    \n        _line_appends = [line._spans.append for line in new_lines._lines]\n\
    \        line_count = len(line_ranges)\n        _Span = Span\n\n        for span_start,\
    \ span_end, style in self._spans:\n            lower_bound = 0\n            upper_bound\
    \ = line_count\n            start_line_no = (lower_bound + upper_bound) // 2\n\
    \n            while True:\n                line_start, line_end = line_ranges[start_line_no]\n\
    \                if span_start < line_start:\n                    upper_bound\
    \ = start_line_no - 1\n                elif span_start > line_end:\n         \
    \           lower_bound = start_line_no + 1\n                else:\n         \
    \           break\n                start_line_no = (lower_bound + upper_bound)\
    \ // 2\n\n            if span_end < line_end:\n                end_line_no = start_line_no\n\
    \            else:\n                end_line_no = lower_bound = start_line_no\n\
    \                upper_bound = line_count\n\n                while True:\n   \
    \                 line_start, line_end = line_ranges[end_line_no]\n          \
    \          if span_end < line_start:\n                        upper_bound = end_line_no\
    \ - 1\n                    elif span_end > line_end:\n                       \
    \ lower_bound = end_line_no + 1\n                    else:\n                 \
    \       break\n                    end_line_no = (lower_bound + upper_bound) //\
    \ 2\n\n            for line_no in range(start_line_no, end_line_no + 1):\n   \
    \             line_start, line_end = line_ranges[line_no]\n                new_start\
    \ = max(0, span_start - line_start)\n                new_end = min(span_end -\
    \ line_start, line_end - line_start)\n                if new_end > new_start:\n\
    \                    _line_appends[line_no](_Span(new_start, new_end, style))\n\
    \n        return new_lines\n\n    def right_crop(self, amount: int = 1) -> None:\n\
    \        \"\"\"Remove a number of characters from the end of the text.\"\"\"\n\
    \        max_offset = len(self.plain) - amount\n        _Span = Span\n       \
    \ self._spans[:] = [\n            (\n                span\n                if\
    \ span.end < max_offset\n                else _Span(span.start, min(max_offset,\
    \ span.end), span.style)\n            )\n            for span in self._spans\n\
    \            if span.start < max_offset\n        ]\n        self._text = [self.plain[:-amount]]\n\
    \        self._length -= amount\n\n    def wrap(\n        self,\n        console:\
    \ \"Console\",\n        width: int,\n        *,\n        justify: Optional[\"\
    JustifyMethod\"] = None,\n        overflow: Optional[\"OverflowMethod\"] = None,\n\
    \        tab_size: int = 8,\n        no_wrap: Optional[bool] = None,\n    ) ->\
    \ Lines:\n        \"\"\"Word wrap the text.\n\n        Args:\n            console\
    \ (Console): Console instance.\n            width (int): Number of cells available\
    \ per line.\n            justify (str, optional): Justify method: \"default\"\
    , \"left\", \"center\", \"full\", \"right\". Defaults to \"default\".\n      \
    \      overflow (str, optional): Overflow method: \"crop\", \"fold\", or \"ellipsis\"\
    . Defaults to None.\n            tab_size (int, optional): Default tab size. Defaults\
    \ to 8.\n            no_wrap (bool, optional): Disable wrapping, Defaults to False.\n\
    \n        Returns:\n            Lines: Number of lines.\n        \"\"\"\n    \
    \    wrap_justify = justify or self.justify or DEFAULT_JUSTIFY\n        wrap_overflow\
    \ = overflow or self.overflow or DEFAULT_OVERFLOW\n\n        no_wrap = pick_bool(no_wrap,\
    \ self.no_wrap, False) or overflow == \"ignore\"\n\n        lines = Lines()\n\
    \        for line in self.split(allow_blank=True):\n            if \"\\t\" in\
    \ line:\n                line.expand_tabs(tab_size)\n            if no_wrap:\n\
    \                new_lines = Lines([line])\n            else:\n              \
    \  offsets = divide_line(str(line), width, fold=wrap_overflow == \"fold\")\n \
    \               new_lines = line.divide(offsets)\n            for line in new_lines:\n\
    \                line.rstrip_end(width)\n            if wrap_justify:\n      \
    \          new_lines.justify(\n                    console, width, justify=wrap_justify,\
    \ overflow=wrap_overflow\n                )\n            for line in new_lines:\n\
    \                line.truncate(width, overflow=wrap_overflow)\n            lines.extend(new_lines)\n\
    \        return lines\n\n    def fit(self, width: int) -> Lines:\n        \"\"\
    \"Fit the text in to given width by chopping in to lines.\n\n        Args:\n \
    \           width (int): Maximum characters in a line.\n\n        Returns:\n \
    \           Lines: Lines container.\n        \"\"\"\n        lines: Lines = Lines()\n\
    \        append = lines.append\n        for line in self.split():\n          \
    \  line.set_length(width)\n            append(line)\n        return lines\n\n\
    \    def detect_indentation(self) -> int:\n        \"\"\"Auto-detect indentation\
    \ of code.\n\n        Returns:\n            int: Number of spaces used to indent\
    \ code.\n        \"\"\"\n\n        _indentations = {\n            len(match.group(1))\n\
    \            for match in re.finditer(r\"^( *)(.*)$\", self.plain, flags=re.MULTILINE)\n\
    \        }\n\n        try:\n            indentation = (\n                reduce(gcd,\
    \ [indent for indent in _indentations if not indent % 2]) or 1\n            )\n\
    \        except TypeError:\n            indentation = 1\n\n        return indentation\n\
    \n    def with_indent_guides(\n        self,\n        indent_size: Optional[int]\
    \ = None,\n        *,\n        character: str = \"â\",\n        style: StyleType\
    \ = \"dim green\",\n    ) -> \"Text\":\n        \"\"\"Adds indent guide lines\
    \ to text.\n\n        Args:\n            indent_size (Optional[int]): Size of\
    \ indentation, or None to auto detect. Defaults to None.\n            character\
    \ (str, optional): Character to use for indentation. Defaults to \"â\".\n    \
    \        style (Union[Style, str], optional): Style of indent guides.\n\n    \
    \    Returns:\n            Text: New text with indentation guides.\n        \"\
    \"\"\n\n        _indent_size = self.detect_indentation() if indent_size is None\
    \ else indent_size\n\n        text = self.copy()\n        text.expand_tabs()\n\
    \        indent_line = f\"{character}{' ' * (_indent_size - 1)}\"\n\n        re_indent\
    \ = re.compile(r\"^( *)(.*)$\")\n        new_lines: List[Text] = []\n        add_line\
    \ = new_lines.append\n        blank_lines = 0\n        for line in text.split(allow_blank=True):\n\
    \            match = re_indent.match(line.plain)\n            if not match or\
    \ not match.group(2):\n                blank_lines += 1\n                continue\n\
    \            indent = match.group(1)\n            full_indents, remaining_space\
    \ = divmod(len(indent), _indent_size)\n            new_indent = f\"{indent_line\
    \ * full_indents}{' ' * remaining_space}\"\n            line.plain = new_indent\
    \ + line.plain[len(new_indent) :]\n            line.stylize(style, 0, len(new_indent))\n\
    \            if blank_lines:\n                new_lines.extend([Text(new_indent,\
    \ style=style)] * blank_lines)\n                blank_lines = 0\n            add_line(line)\n\
    \        if blank_lines:\n            new_lines.extend([Text(\"\", style=style)]\
    \ * blank_lines)\n\n        new_text = text.blank_copy(\"\\n\").join(new_lines)\n\
    \        return new_text\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n\
    \    from rich.console import Console\n\n    text = Text(\n        \"\"\"\\nLorem\
    \ ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt\
    \ ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation\
    \ ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor\
    \ in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.\
    \ Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\
    \ mollit anim id est laborum.\\n\"\"\"\n    )\n    text.highlight_words([\"Lorem\"\
    ], \"bold\")\n    text.highlight_words([\"ipsum\"], \"italic\")\n\n    console\
    \ = Console()\n\n    console.rule(\"justify='left'\")\n    console.print(text,\
    \ style=\"red\")\n    console.print()\n\n    console.rule(\"justify='center'\"\
    )\n    console.print(text, style=\"green\", justify=\"center\")\n    console.print()\n\
    \n    console.rule(\"justify='right'\")\n    console.print(text, style=\"blue\"\
    , justify=\"right\")\n    console.print()\n\n    console.rule(\"justify='full'\"\
    )\n    console.print(text, style=\"magenta\", justify=\"full\")\n    console.print()\n\
    \nOutput the complete test file, code only, no explanations.\n### Time\nCurrent\
    \ time: 2025-03-17 01:50:13\n"
  role: user
