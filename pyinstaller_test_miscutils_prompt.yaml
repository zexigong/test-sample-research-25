messages:
- content: You are an AI agent expert in writing unit tests. Your task is to write
    unit tests for the given code files of the repository. Make sure the tests can
    be executed without lint or compile errors.
  role: system
- content: "### Task Information\nBased on the source code, write/rewrite tests to\
    \ cover the source code.\nRepository: pyinstaller\nTest File Path: pyinstaller\\\
    test_miscutils\\test_miscutils.py\nProject Programming Language: Python\nTesting\
    \ Framework: pytest\n### Source File Content\n### Source File Content:\n#-----------------------------------------------------------------------------\n\
    # Copyright (c) 2013-2023, PyInstaller Development Team.\n#\n# Distributed under\
    \ the terms of the GNU General Public License (version 2\n# or later) with exception\
    \ for distributing the bootloader.\n#\n# The full license is in the file COPYING.txt,\
    \ distributed with this software.\n#\n# SPDX-License-Identifier: (GPL-2.0-or-later\
    \ WITH Bootloader-exception)\n#-----------------------------------------------------------------------------\n\
    \"\"\"\nThis module contains miscellaneous functions that do not fit anywhere\
    \ else.\n\"\"\"\n\nimport glob\nimport os\nimport pprint\nimport codecs\nimport\
    \ re\nimport tokenize\nimport io\nimport pathlib\n\nfrom PyInstaller import log\
    \ as logging\nfrom PyInstaller.compat import is_win\n\nlogger = logging.getLogger(__name__)\n\
    \n\ndef dlls_in_subdirs(directory):\n    \"\"\"\n    Returns a list *.dll, *.so,\
    \ *.dylib in the given directory and its subdirectories.\n    \"\"\"\n    filelist\
    \ = []\n    for root, dirs, files in os.walk(directory):\n        filelist.extend(dlls_in_dir(root))\n\
    \    return filelist\n\n\ndef dlls_in_dir(directory):\n    \"\"\"\n    Returns\
    \ a list of *.dll, *.so, *.dylib in the given directory.\n    \"\"\"\n    return\
    \ files_in_dir(directory, [\"*.so\", \"*.dll\", \"*.dylib\"])\n\n\ndef files_in_dir(directory,\
    \ file_patterns=None):\n    \"\"\"\n    Returns a list of files in the given directory\
    \ that match the given pattern.\n    \"\"\"\n\n    file_patterns = file_patterns\
    \ or []\n\n    files = []\n    for file_pattern in file_patterns:\n        files.extend(glob.glob(os.path.join(directory,\
    \ file_pattern)))\n    return files\n\n\ndef get_path_to_toplevel_modules(filename):\n\
    \    \"\"\"\n    Return the path to top-level directory that contains Python modules.\n\
    \n    It will look in parent directories for __init__.py files. The first parent\
    \ directory without __init__.py is the\n    top-level directory.\n\n    Returned\
    \ directory might be used to extend the PYTHONPATH.\n    \"\"\"\n    curr_dir\
    \ = os.path.dirname(os.path.abspath(filename))\n    pattern = '__init__.py'\n\n\
    \    # Try max. 10 levels up.\n    try:\n        for i in range(10):\n       \
    \     files = set(os.listdir(curr_dir))\n            # 'curr_dir' is still not\
    \ top-level; go to parent dir.\n            if pattern in files:\n           \
    \     curr_dir = os.path.dirname(curr_dir)\n            # Top-level dir found;\
    \ return it.\n            else:\n                return curr_dir\n    except IOError:\n\
    \        pass\n    # No top-level directory found, or error was encountered.\n\
    \    return None\n\n\ndef mtime(fnm):\n    try:\n        # TODO: explain why this\
    \ does not use os.path.getmtime() ?\n        #       - It is probably not used\
    \ because it returns float and not int.\n        return os.stat(fnm)[8]\n    except\
    \ Exception:\n        return 0\n\n\ndef save_py_data_struct(filename, data):\n\
    \    \"\"\"\n    Save data into text file as Python data structure.\n    :param\
    \ filename:\n    :param data:\n    :return:\n    \"\"\"\n    dirname = os.path.dirname(filename)\n\
    \    if not os.path.exists(dirname):\n        os.makedirs(dirname)\n    with open(filename,\
    \ 'w', encoding='utf-8') as f:\n        pprint.pprint(data, f)\n\n\ndef load_py_data_struct(filename):\n\
    \    \"\"\"\n    Load data saved as python code and interpret that code.\n   \
    \ :param filename:\n    :return:\n    \"\"\"\n    with open(filename, 'r', encoding='utf-8')\
    \ as f:\n        if is_win:\n            # import versioninfo so that VSVersionInfo\
    \ can parse correctly.\n            from PyInstaller.utils.win32 import versioninfo\
    \  # noqa: F401\n\n        return eval(f.read())\n\n\ndef absnormpath(apath):\n\
    \    return os.path.abspath(os.path.normpath(apath))\n\n\ndef module_parent_packages(full_modname):\n\
    \    \"\"\"\n    Return list of parent package names.\n        'aaa.bb.c.dddd'\
    \ ->  ['aaa', 'aaa.bb', 'aaa.bb.c']\n    :param full_modname: Full name of a module.\n\
    \    :return: List of parent module names.\n    \"\"\"\n    prefix = ''\n    parents\
    \ = []\n    # Ignore the last component in module name and get really just parent,\
    \ grandparent, great grandparent, etc.\n    for pkg in full_modname.split('.')[0:-1]:\n\
    \        # Ensure that first item does not start with dot '.'\n        prefix\
    \ += '.' + pkg if prefix else pkg\n        parents.append(prefix)\n    return\
    \ parents\n\n\ndef is_file_qt_plugin(filename):\n    \"\"\"\n    Check if the\
    \ given file is a Qt plugin file.\n    :param filename: Full path to file to check.\n\
    \    :return: True if given file is a Qt plugin file, False if not.\n    \"\"\"\
    \n\n    # Check the file contents; scan for QTMETADATA string. The scan is based\
    \ on the brute-force Windows codepath of\n    # findPatternUnloaded() from qtbase/src/corelib/plugin/qlibrary.cpp\
    \ in Qt5.\n    with open(filename, 'rb') as fp:\n        fp.seek(0, os.SEEK_END)\n\
    \        end_pos = fp.tell()\n\n        SEARCH_CHUNK_SIZE = 8192\n        QTMETADATA_MAGIC\
    \ = b'QTMETADATA '\n\n        magic_offset = -1\n        while end_pos >= len(QTMETADATA_MAGIC):\n\
    \            start_pos = max(end_pos - SEARCH_CHUNK_SIZE, 0)\n            chunk_size\
    \ = end_pos - start_pos\n            # Is the remaining chunk large enough to\
    \ hold the pattern?\n            if chunk_size < len(QTMETADATA_MAGIC):\n    \
    \            break\n            # Read and scan the chunk\n            fp.seek(start_pos,\
    \ os.SEEK_SET)\n            buf = fp.read(chunk_size)\n            pos = buf.rfind(QTMETADATA_MAGIC)\n\
    \            if pos != -1:\n                magic_offset = start_pos + pos\n \
    \               break\n            # Adjust search location for next chunk; ensure\
    \ proper overlap.\n            end_pos = start_pos + len(QTMETADATA_MAGIC) - 1\n\
    \        if magic_offset == -1:\n            return False\n\n        return True\n\
    \n\nBOM_MARKERS_TO_DECODERS = {\n    codecs.BOM_UTF32_LE: codecs.utf_32_le_decode,\n\
    \    codecs.BOM_UTF32_BE: codecs.utf_32_be_decode,\n    codecs.BOM_UTF32: codecs.utf_32_decode,\n\
    \    codecs.BOM_UTF16_LE: codecs.utf_16_le_decode,\n    codecs.BOM_UTF16_BE: codecs.utf_16_be_decode,\n\
    \    codecs.BOM_UTF16: codecs.utf_16_decode,\n    codecs.BOM_UTF8: codecs.utf_8_decode,\n\
    }\nBOM_RE = re.compile(rb\"\\A(%s)?(.*)\" % b\"|\".join(map(re.escape, BOM_MARKERS_TO_DECODERS)),\
    \ re.DOTALL)\n\n\ndef decode(raw: bytes):\n    \"\"\"\n    Decode bytes to string,\
    \ respecting and removing any byte-order marks if present, or respecting but not\
    \ removing any\n    PEP263 encoding comments (# encoding: cp1252).\n    \"\"\"\
    \n    bom, raw = BOM_RE.match(raw).groups()\n    if bom:\n        return BOM_MARKERS_TO_DECODERS[bom](raw)[0]\n\
    \n    encoding, _ = tokenize.detect_encoding(io.BytesIO(raw).readline)\n    return\
    \ raw.decode(encoding)\n\n\ndef is_iterable(arg):\n    \"\"\"\n    Check if the\
    \ passed argument is an iterable.\"\n    \"\"\"\n    try:\n        iter(arg)\n\
    \    except TypeError:\n        return False\n    return True\n\n\ndef path_to_parent_archive(filename):\n\
    \    \"\"\"\n    Check if the given file path points to a file inside an existing\
    \ archive file. Returns first path from the set of\n    parent paths that points\
    \ to an existing file, or `None` if no such path exists (i.e., file is an actual\
    \ stand-alone\n    file).\n    \"\"\"\n    for parent in pathlib.Path(filename).parents:\n\
    \        if parent.is_file():\n            return parent\n    return None\n\n\
    ### Source File Dependency Files Content\n### Dependency File: compat.py\n# ----------------------------------------------------------------------------\n\
    # Copyright (c) 2005-2023, PyInstaller Development Team.\n#\n# Distributed under\
    \ the terms of the GNU General Public License (version 2\n# or later) with exception\
    \ for distributing the bootloader.\n#\n# The full license is in the file COPYING.txt,\
    \ distributed with this software.\n#\n# SPDX-License-Identifier: (GPL-2.0-or-later\
    \ WITH Bootloader-exception)\n# ----------------------------------------------------------------------------\n\
    \"\"\"\nVarious classes and functions to provide some backwards-compatibility\
    \ with previous versions of Python onward.\n\"\"\"\nfrom __future__ import annotations\n\
    \nimport errno\n\nimport importlib.machinery\nimport importlib.util\nimport os\n\
    import platform\nimport site\nimport subprocess\nimport sys\nimport sysconfig\n\
    import shutil\nimport types\n\nfrom PyInstaller._shared_with_waf import _pyi_machine\n\
    from PyInstaller.exceptions import ExecCommandFailed\n\n# setup.py sets this environment\
    \ variable to avoid errors due to unmet run-time dependencies. The PyInstaller.compat\n\
    # module is imported by setup.py to build wheels, and some dependencies that are\
    \ otherwise required at run-time\n# (importlib-metadata on python < 3.10, pywin32-ctypes\
    \ on Windows) might not be present while building wheels,\n# nor are they required\
    \ during that phase.\n_setup_py_mode = os.environ.get('_PYINSTALLER_SETUP_PY',\
    \ '0') != '0'\n\n# PyInstaller requires importlib.metadata from python >= 3.10\
    \ stdlib, or equivalent importlib-metadata >= 4.6.\nif _setup_py_mode:\n    importlib_metadata\
    \ = None\nelse:\n    if sys.version_info >= (3, 10):\n        import importlib.metadata\
    \ as importlib_metadata\n    else:\n        try:\n            import importlib_metadata\n\
    \        except ImportError as e:\n            from PyInstaller.exceptions import\
    \ ImportlibMetadataError\n            raise ImportlibMetadataError() from e\n\n\
    \        import packaging.version  # For importlib_metadata version check\n\n\
    \        # Validate the version\n        if packaging.version.parse(importlib_metadata.version(\"\
    importlib-metadata\")) < packaging.version.parse(\"4.6\"):\n            from PyInstaller.exceptions\
    \ import ImportlibMetadataError\n            raise ImportlibMetadataError()\n\n\
    # Strict collect mode, which raises error when trying to collect duplicate files\
    \ into PKG/CArchive or COLLECT.\nstrict_collect_mode = os.environ.get(\"PYINSTALLER_STRICT_COLLECT_MODE\"\
    , \"0\") != \"0\"\n\n# Copied from https://docs.python.org/3/library/platform.html#cross-platform.\n\
    is_64bits: bool = sys.maxsize > 2**32\n\n# Distinguish specific code for various\
    \ Python versions. Variables 'is_pyXY' mean that Python X.Y and up is supported.\n\
    # Keep even unsupported versions here to keep 3rd-party hooks working.\nis_py35\
    \ = sys.version_info >= (3, 5)\nis_py36 = sys.version_info >= (3, 6)\nis_py37\
    \ = sys.version_info >= (3, 7)\nis_py38 = sys.version_info >= (3, 8)\nis_py39\
    \ = sys.version_info >= (3, 9)\nis_py310 = sys.version_info >= (3, 10)\nis_py311\
    \ = sys.version_info >= (3, 11)\nis_py312 = sys.version_info >= (3, 12)\nis_py313\
    \ = sys.version_info >= (3, 13)\n\nis_win = sys.platform.startswith('win')\nis_win_10\
    \ = is_win and (platform.win32_ver()[0] == '10')\nis_win_11 = is_win and (platform.win32_ver()[0]\
    \ == '11')\nis_win_wine = False  # Running under Wine; determined later on.\n\
    is_cygwin = sys.platform == 'cygwin'\nis_darwin = sys.platform == 'darwin'  #\
    \ macOS\n\n# Unix platforms\nis_linux = sys.platform.startswith('linux')\nis_solar\
    \ = sys.platform.startswith('sun')  # Solaris\nis_aix = sys.platform.startswith('aix')\n\
    is_freebsd = sys.platform.startswith('freebsd')\nis_openbsd = sys.platform.startswith('openbsd')\n\
    is_hpux = sys.platform.startswith('hp-ux')\n\n# Some code parts are similar to\
    \ several unix platforms (e.g. Linux, Solaris, AIX).\n# macOS is not considered\
    \ as unix since there are many platform-specific details for Mac in PyInstaller.\n\
    is_unix = is_linux or is_solar or is_aix or is_freebsd or is_hpux or is_openbsd\n\
    \n# Linux distributions such as Alpine or OpenWRT use musl as their libc implementation\
    \ and resultantly need specially\n# compiled bootloaders. On musl systems, ldd\
    \ with no arguments prints 'musl' and its version.\nis_musl = is_linux and \"\
    musl\" in subprocess.run([\"ldd\"], capture_output=True, encoding=\"utf-8\").stderr\n\
    \n# macOS version\n_macos_ver = tuple(int(x) for x in platform.mac_ver()[0].split('.'))\
    \ if is_darwin else None\n\n# macOS 11 (Big Sur): if python is not compiled with\
    \ Big Sur support, it ends up in compatibility mode by default, which\n# is indicated\
    \ by platform.mac_ver() returning '10.16'. The lack of proper Big Sur support\
    \ breaks find_library()\n# function from ctypes.util module, as starting with\
    \ Big Sur, shared libraries are not visible on disk anymore. Support\n# for the\
    \ new library search mechanism was added in python 3.9 when compiled with Big\
    \ Sur support. In such cases,\n# platform.mac_ver() reports version as '11.x'.\
    \ The behavior can be further modified via SYSTEM_VERSION_COMPAT\n# environment\
    \ variable; which allows explicitly enabling or disabling the compatibility mode.\
    \ However, note that\n# disabling the compatibility mode and using python that\
    \ does not properly support Big Sur still leaves find_library()\n# broken (which\
    \ is a scenario that we ignore at the moment).\n# The same logic applies to macOS\
    \ 12 (Monterey).\nis_macos_11_compat = bool(_macos_ver) and _macos_ver[0:2] ==\
    \ (10, 16)  # Big Sur or newer in compat mode\nis_macos_11_native = bool(_macos_ver)\
    \ and _macos_ver[0:2] >= (11, 0)  # Big Sur or newer in native mode\nis_macos_11\
    \ = is_macos_11_compat or is_macos_11_native  # Big Sur or newer\n\n# Check if\
    \ python >= 3.13 was built with Py_GIL_DISABLED / free-threading (PEP703).\n#\n\
    # This affects the shared library name, which has the \"t\" ABI suffix, as per:\n\
    # https://github.com/python/steering-council/issues/221#issuecomment-1841593283\n\
    #\n# It also affects the layout of PyConfig structure used by bootloader; consequently\n\
    #  a) we need to inform bootloader what kind of build it is dealing with\n#  b)\
    \ we must not mix up shared libraries, in case multiple builds are present on\
    \ the system. Thus, strictly enforce the\n#     \"t\" ABI suffix in the PYDYLIB_NAMES,\
    \ if applicable.\nis_nogil = bool(sysconfig.get_config_var('Py_GIL_DISABLED'))\n\
    \n_py_suffix = \"t\" if is_nogil else \"\"\n\n# On different platforms is different\
    \ file for dynamic python library.\n_py_major, _py_minor = sys.version_info[:2]\n\
    if is_win or is_cygwin:\n    PYDYLIB_NAMES = {\n        f'python{_py_major}{_py_minor}{_py_suffix}.dll',\n\
    \        f'libpython{_py_major}{_py_minor}{_py_suffix}.dll',\n        f'libpython{_py_major}.{_py_minor}{_py_suffix}.dll',\n\
    \    }  # For MSYS2 environment\nelif is_darwin:\n    # The suffix in .framework\
    \ library name is capitalized, e.g., PythonT for freethreading-enabled build.\n\
    \    # The `libpython%d.%d%s.dylib` is there primarily for Anaconda installations,\
    \ but it also serves as a fallback in\n    # .framework builds, where `/Library/Frameworks/Python.framework/Versions/3.X/lib/libpython3.13.dylib`\
    \ is a symbolic\n    # link that points to `../Python`.\n    PYDYLIB_NAMES = {\n\
    \        f'Python{_py_suffix.upper()}',\n        f'.Python{_py_suffix.upper()}',\n\
    \        f'Python{_py_major}{_py_suffix.upper()}',\n        f'libpython{_py_major}.{_py_minor}{_py_suffix}.dylib',\n\
    \    }\nelif is_aix:\n    # Shared libs on AIX may be archives with shared object\
    \ members, hence the \".a\" suffix. However, starting with\n    # python 2.7.11\
    \ libpython?.?.so and Python3 libpython?.?m.so files are produced.\n    PYDYLIB_NAMES\
    \ = {\n        f'libpython{_py_major}.{_py_minor}{_py_suffix}.a',\n        f'libpython{_py_major}.{_py_minor}{_py_suffix}.so',\n\
    \    }\nelif is_freebsd:\n    PYDYLIB_NAMES = {\n        f'libpython{_py_major}.{_py_minor}{_py_suffix}.so.1',\n\
    \        f'libpython{_py_major}.{_py_minor}{_py_suffix}.so.1.0',\n    }\nelif\
    \ is_openbsd:\n    PYDYLIB_NAMES = {\n        f'libpython{_py_major}.{_py_minor}{_py_suffix}.so.0.0',\n\
    \    }\nelif is_hpux:\n    PYDYLIB_NAMES = {\n        f'libpython{_py_major}.{_py_minor}{_py_suffix}.so',\n\
    \    }\nelif is_unix:\n    # Other *nix platforms.\n    # Python 2 .so library\
    \ on Linux is: libpython2.7.so.1.0\n    # Python 3 .so library on Linux is: libpython3.3.so.1.0\n\
    \    PYDYLIB_NAMES = {\n        f'libpython{_py_major}.{_py_minor}{_py_suffix}.so.1.0',\n\
    \        f'libpython{_py_major}.{_py_minor}{_py_suffix}.so',\n    }\nelse:\n \
    \   raise SystemExit('Your platform is not yet supported. Please define constant\
    \ PYDYLIB_NAMES for your platform.')\n\ndel _py_major, _py_minor, _py_suffix\n\
    \n# In a virtual environment created by virtualenv (github.com/pypa/virtualenv)\
    \ there exists sys.real_prefix with the path\n# to the base Python installation\
    \ from which the virtual environment was created. This is true regardless of the\
    \ version\n# of Python used to execute the virtualenv command.\n#\n# In a virtual\
    \ environment created by the venv module available in the Python standard lib,\
    \ there exists sys.base_prefix\n# with the path to the base implementation. This\
    \ does not exist in a virtual environment created by virtualenv.\n#\n# The following\
    \ code creates compat.is_venv and is.virtualenv that are True when running a virtual\
    \ environment, and also\n# compat.base_prefix with the path to the base Python\
    \ installation.\n\nbase_prefix: str = os.path.abspath(getattr(sys, 'real_prefix',\
    \ getattr(sys, 'base_prefix', sys.prefix)))\n# Ensure `base_prefix` is not containing\
    \ any relative parts.\nis_venv = is_virtualenv = base_prefix != os.path.abspath(sys.prefix)\n\
    \n# Conda environments sometimes have different paths or apply patches to packages\
    \ that can affect how a hook or package\n# should access resources. Method for\
    \ determining conda taken from https://stackoverflow.com/questions/47610844#47610844\n\
    is_conda = os.path.isdir(os.path.join(base_prefix, 'conda-meta'))\n\n# Similar\
    \ to ``is_conda`` but is ``False`` using another ``venv``-like manager on top.\
    \ In this case, no packages\n# encountered will be conda packages meaning that\
    \ the default non-conda behaviour is generally desired from PyInstaller.\nis_pure_conda\
    \ = os.path.isdir(os.path.join(sys.prefix, 'conda-meta'))\n\n# Full path to python\
    \ interpreter.\npython_executable = getattr(sys, '_base_executable', sys.executable)\n\
    \n# Is this Python from Microsoft App Store (Windows only)? Python from Microsoft\
    \ App Store has executable pointing at\n# empty shims.\nis_ms_app_store = is_win\
    \ and os.path.getsize(python_executable) == 0\n\nif is_ms_app_store:\n    # Locate\
    \ the actual executable inside base_prefix.\n    python_executable = os.path.join(base_prefix,\
    \ os.path.basename(python_executable))\n    if not os.path.exists(python_executable):\n\
    \        raise SystemExit(\n            'PyInstaller cannot locate real python\
    \ executable belonging to Python from Microsoft App Store!'\n        )\n\n# Bytecode\
    \ magic value\nBYTECODE_MAGIC = importlib.util.MAGIC_NUMBER\n\n# List of suffixes\
    \ for Python C extension modules.\nEXTENSION_SUFFIXES = importlib.machinery.EXTENSION_SUFFIXES\n\
    ALL_SUFFIXES = importlib.machinery.all_suffixes()\n\n# On Windows we require pywin32-ctypes.\n\
    # -> all pyinstaller modules should use win32api from PyInstaller.compat to\n\
    #    ensure that it can work on MSYS2 (which requires pywin32-ctypes)\nif is_win:\n\
    \    if _setup_py_mode:\n        pywintypes = None\n        win32api = None\n\
    \    else:\n        try:\n            # Hide the `cffi` package from win32-ctypes\
    \ by temporarily blocking its import. This ensures that `ctypes`\n           \
    \ # backend is always used, even if `cffi` is available. The `cffi` backend uses\
    \ `pycparser`, which is\n            # incompatible with -OO mode (2nd optimization\
    \ level) due to its removal of docstrings.\n            # See https://github.com/pyinstaller/pyinstaller/issues/6345\n\
    \            # On the off chance that `cffi` has already been imported, store\
    \ the `sys.modules` entry so we can restore\n            # it after importing\
    \ `pywin32-ctypes` modules.\n            orig_cffi = sys.modules.get('cffi')\n\
    \            sys.modules['cffi'] = None\n\n            from win32ctypes.pywin32\
    \ import pywintypes  # noqa: F401, E402\n            from win32ctypes.pywin32\
    \ import win32api  # noqa: F401, E402\n        except ImportError as e:\n    \
    \        raise SystemExit(\n                'Could not import `pywintypes` or\
    \ `win32api` from `win32ctypes.pywin32`.\\n'\n                'Please make sure\
    \ that `pywin32-ctypes` is installed and importable, for example:\\n\\n'\n   \
    \             'pip install pywin32-ctypes\\n'\n            ) from e\n        finally:\n\
    \            # Unblock `cffi`.\n            if orig_cffi is not None:\n      \
    \          sys.modules['cffi'] = orig_cffi\n            else:\n              \
    \  del sys.modules['cffi']\n            del orig_cffi\n\n# macOS's platform.architecture()\
    \ can be buggy, so we do this manually here. Based off the python documentation:\n\
    # https://docs.python.org/3/library/platform.html#platform.architecture\nif is_darwin:\n\
    \    architecture = '64bit' if sys.maxsize > 2**32 else '32bit'\nelse:\n    architecture\
    \ = platform.architecture()[0]\n\n# Cygwin needs special handling, because platform.system()\
    \ contains identifiers such as MSYS_NT-10.0-19042 and\n# CYGWIN_NT-10.0-19042\
    \ that do not fit PyInstaller's OS naming scheme. Explicitly set `system` to 'Cygwin'.\n\
    system = 'Cygwin' if is_cygwin else platform.system()\n\n# Machine suffix for\
    \ bootloader.\nif is_win:\n    # On Windows ARM64 using an x64 Python environment,\
    \ platform.machine() returns ARM64 but\n    # we really want the bootloader that\
    \ matches the Python environment instead of the OS.\n    machine = _pyi_machine(os.environ.get(\"\
    PROCESSOR_ARCHITECTURE\", platform.machine()), platform.system())\nelse:\n   \
    \ machine = _pyi_machine(platform.machine(), platform.system())\n\n\n# Wine detection\
    \ and support\ndef is_wine_dll(filename: str | os.PathLike):\n    \"\"\"\n   \
    \ Check if the given PE file is a Wine DLL (PE-converted built-in, or fake/placeholder\
    \ one).\n\n    Returns True if the given file is a Wine DLL, False if not (or\
    \ if file cannot be analyzed or does not exist).\n    \"\"\"\n    _WINE_SIGNATURES\
    \ = (\n        b'Wine builtin DLL',  # PE-converted Wine DLL\n        b'Wine placeholder\
    \ DLL',  # Fake/placeholder Wine DLL\n    )\n    _MAX_LEN = max([len(sig) for\
    \ sig in _WINE_SIGNATURES])\n\n    # Wine places their DLL signature in the padding\
    \ area between the IMAGE_DOS_HEADER and IMAGE_NT_HEADERS. So we need\n    # to\
    \ compare the bytes that come right after IMAGE_DOS_HEADER, i.e., after initial\
    \ 64 bytes. We can read the file\n    # directly and avoid using the pefile library\
    \ to avoid performance penalty associated with full header parsing.\n    try:\n\
    \        with open(filename, 'rb') as fp:\n            fp.seek(64)\n         \
    \   signature = fp.read(_MAX_LEN)\n        return signature.startswith(_WINE_SIGNATURES)\n\
    \    except Exception:\n        pass\n    return False\n\n\nif is_win:\n    try:\n\
    \        import ctypes.util  # noqa: E402\n        is_win_wine = is_wine_dll(ctypes.util.find_library('kernel32'))\n\
    \    except Exception:\n        pass\n\n# Set and get environment variables does\
    \ not handle unicode strings correctly on Windows.\n\n# Acting on os.environ instead\
    \ of using getenv()/setenv()/unsetenv(), as suggested in\n# <http://docs.python.org/library/os.html#os.environ>:\
    \ \"Calling putenv() directly does not change os.environ, so it is\n# better to\
    \ modify os.environ.\" (Same for unsetenv.)\n\n\ndef getenv(name: str, default:\
    \ str | None = None):\n    \"\"\"\n    Returns unicode string containing value\
    \ of environment variable 'name'.\n    \"\"\"\n    return os.environ.get(name,\
    \ default)\n\n\ndef setenv(name: str, value: str):\n    \"\"\"\n    Accepts unicode\
    \ string and set it as environment variable 'name' containing value 'value'.\n\
    \    \"\"\"\n    os.environ[name] = value\n\n\ndef unsetenv(name: str):\n    \"\
    \"\"\n    Delete the environment variable 'name'.\n    \"\"\"\n    # Some platforms\
    \ (e.g., AIX) do not support `os.unsetenv()` and thus `del os.environ[name]` has\
    \ no effect on the\n    # real environment. For this case, we set the value to\
    \ the empty string.\n    os.environ[name] = \"\"\n    del os.environ[name]\n\n\
    \n# Exec commands in subprocesses.\n\n\ndef exec_command(\n    *cmdargs: str,\
    \ encoding: str | None = None, raise_enoent: bool | None = None, **kwargs: int\
    \ | bool | list | None\n):\n    \"\"\"\n    Run the command specified by the passed\
    \ positional arguments, optionally configured by the passed keyword arguments.\n\
    \n    .. DANGER::\n       **Ignore this function's return value** -- unless this\
    \ command's standard output contains _only_ pathnames, in\n       which case this\
    \ function returns the correct filesystem-encoded string expected by PyInstaller.\
    \ In all other\n       cases, this function's return value is _not_ safely usable.\n\
    \n       For backward compatibility, this function's return value non-portably\
    \ depends on the current Python version and\n       passed keyword arguments:\n\
    \n       * Under Python 3.x, this value is a **decoded `str` string**. However,\
    \ even this value is _not_ necessarily\n         safely usable:\n         * If\
    \ the `encoding` parameter is passed, this value is guaranteed to be safely usable.\n\
    \         * Else, this value _cannot_ be safely used for any purpose (e.g., string\
    \ manipulation or parsing), except to be\n           passed directly to another\
    \ non-Python command. Why? Because this value has been decoded with the encoding\n\
    \           specified by `sys.getfilesystemencoding()`, the encoding used by `os.fsencode()`\
    \ and `os.fsdecode()` to\n           convert from platform-agnostic to platform-specific\
    \ pathnames. This is _not_ necessarily the encoding with\n           which this\
    \ command's standard output was encoded. Cue edge-case decoding exceptions.\n\n\
    \    Parameters\n    ----------\n    cmdargs :\n        Variadic list whose:\n\
    \        1. Mandatory first element is the absolute path, relative path, or basename\
    \ in the current `${PATH}` of the\n           command to run.\n        2. Optional\
    \ remaining elements are arguments to pass to this command.\n    encoding : str,\
    \ optional\n        Optional keyword argument specifying the encoding with which\
    \ to decode this command's standard output under\n        Python 3. As this function's\
    \ return value should be ignored, this argument should _never_ be passed.\n  \
    \  raise_enoent : boolean, optional\n        Optional keyword argument to simply\
    \ raise the exception if the executing the command fails since to the command\n\
    \        is not found. This is useful to checking id a command exists.\n\n   \
    \ All remaining keyword arguments are passed as is to the `subprocess.Popen()`\
    \ constructor.\n\n    Returns\n    ----------\n    str\n        Ignore this value.\
    \ See discussion above.\n    \"\"\"\n\n    proc = subprocess.Popen(cmdargs, stdout=subprocess.PIPE,\
    \ **kwargs)\n    try:\n        out = proc.communicate(timeout=60)[0]\n    except\
    \ OSError as e:\n        if raise_enoent and e.errno == errno.ENOENT:\n      \
    \      raise\n        print('--' * 20, file=sys.stderr)\n        print(\"Error\
    \ running '%s':\" % \" \".join(cmdargs), file=sys.stderr)\n        print(e, file=sys.stderr)\n\
    \        print('--' * 20, file=sys.stderr)\n        raise ExecCommandFailed(\"\
    Error: Executing command failed!\") from e\n    except subprocess.TimeoutExpired:\n\
    \        proc.kill()\n        raise\n\n    # stdout/stderr are returned as a byte\
    \ array NOT as string, so we need to convert that to proper encoding.\n    try:\n\
    \        if encoding:\n            out = out.decode(encoding)\n        else:\n\
    \            # If no encoding is given, assume we are reading filenames from stdout\
    \ only because it is the common case.\n            out = os.fsdecode(out)\n  \
    \  except UnicodeDecodeError as e:\n        # The sub-process used a different\
    \ encoding; provide more information to ease debugging.\n        print('--' *\
    \ 20, file=sys.stderr)\n        print(str(e), file=sys.stderr)\n        print('These\
    \ are the bytes around the offending byte:', file=sys.stderr)\n        print('--'\
    \ * 20, file=sys.stderr)\n        raise\n    return out\n\n\ndef exec_command_rc(*cmdargs:\
    \ str, **kwargs: float | bool | list | None):\n    \"\"\"\n    Return the exit\
    \ code of the command specified by the passed positional arguments, optionally\
    \ configured by the\n    passed keyword arguments.\n\n    Parameters\n    ----------\n\
    \    cmdargs : list\n        Variadic list whose:\n        1. Mandatory first\
    \ element is the absolute path, relative path, or basename in the current `${PATH}`\
    \ of the\n           command to run.\n        2. Optional remaining elements are\
    \ arguments to pass to this command.\n\n    All keyword arguments are passed as\
    \ is to the `subprocess.call()` function.\n\n    Returns\n    ----------\n   \
    \ int\n        This command's exit code as an unsigned byte in the range `[0,\
    \ 255]`, where 0 signifies success and all other\n        values signal a failure.\n\
    \    \"\"\"\n\n    # 'encoding' keyword is not supported for 'subprocess.call';\
    \ remove it from kwargs.\n    if 'encoding' in kwargs:\n        kwargs.pop('encoding')\n\
    \    return subprocess.call(cmdargs, **kwargs)\n\n\ndef exec_command_all(*cmdargs:\
    \ str, encoding: str | None = None, **kwargs: int | bool | list | None):\n   \
    \ \"\"\"\n    Run the command specified by the passed positional arguments, optionally\
    \ configured by the passed keyword arguments.\n\n    .. DANGER::\n       **Ignore\
    \ this function's return value.** If this command's standard output consists solely\
    \ of pathnames, consider\n       calling `exec_command()`\n\n    Parameters\n\
    \    ----------\n    cmdargs : str\n        Variadic list whose:\n        1. Mandatory\
    \ first element is the absolute path, relative path, or basename in the current\
    \ `${PATH}` of the\n           command to run.\n        2. Optional remaining\
    \ elements are arguments to pass to this command.\n    encoding : str, optional\n\
    \        Optional keyword argument specifying the encoding with which to decode\
    \ this command's standard output. As this\n        function's return value should\
    \ be ignored, this argument should _never_ be passed.\n\n    All remaining keyword\
    \ arguments are passed as is to the `subprocess.Popen()` constructor.\n\n    Returns\n\
    \    ----------\n    (int, str, str)\n        Ignore this 3-element tuple `(exit_code,\
    \ stdout, stderr)`. See the `exec_command()` function for discussion.\n    \"\"\
    \"\n    proc = subprocess.Popen(\n        cmdargs,\n        bufsize=-1,  # Default\
    \ OS buffer size.\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n\
    \        **kwargs\n    )\n    # Waits for subprocess to complete.\n    try:\n\
    \        out, err = proc.communicate(timeout=60)\n    except subprocess.TimeoutExpired:\n\
    \        proc.kill()\n        raise\n    # stdout/stderr are returned as a byte\
    \ array NOT as string. Thus we need to convert that to proper encoding.\n    try:\n\
    \        if encoding:\n            out = out.decode(encoding)\n            err\
    \ = err.decode(encoding)\n        else:\n            # If no encoding is given,\
    \ assume we're reading filenames from stdout only because it's the common case.\n\
    \            out = os.fsdecode(out)\n            err = os.fsdecode(err)\n    except\
    \ UnicodeDecodeError as e:\n        # The sub-process used a different encoding,\
    \ provide more information to ease debugging.\n        print('--' * 20, file=sys.stderr)\n\
    \        print(str(e), file=sys.stderr)\n        print('These are the bytes around\
    \ the offending byte:', file=sys.stderr)\n        print('--' * 20, file=sys.stderr)\n\
    \        raise\n\n    return proc.returncode, out, err\n\n\ndef __wrap_python(args,\
    \ kwargs):\n    cmdargs = [sys.executable]\n\n    # macOS supports universal binaries\
    \ (binary for multiple architectures. We need to ensure that subprocess\n    #\
    \ binaries are running for the same architecture as python executable. It is necessary\
    \ to run binaries with 'arch'\n    # command.\n    if is_darwin:\n        if architecture\
    \ == '64bit':\n            if platform.machine() == 'arm64':\n               \
    \ py_prefix = ['arch', '-arm64']  # Apple M1\n            else:\n            \
    \    py_prefix = ['arch', '-x86_64']  # Intel\n        elif architecture == '32bit':\n\
    \            py_prefix = ['arch', '-i386']\n        else:\n            py_prefix\
    \ = []\n        # Since macOS 10.11, the environment variable DYLD_LIBRARY_PATH\
    \ is no more inherited by child processes, so we\n        # proactively propagate\
    \ the current value using the `-e` option of the `arch` command.\n        if 'DYLD_LIBRARY_PATH'\
    \ in os.environ:\n            path = os.environ['DYLD_LIBRARY_PATH']\n       \
    \     py_prefix += ['-e', 'DYLD_LIBRARY_PATH=%s' % path]\n        cmdargs = py_prefix\
    \ + cmdargs\n\n    if not __debug__:\n        cmdargs.append('-O')\n\n    cmdargs.extend(args)\n\
    \n    env = kwargs.get('env')\n    if env is None:\n        env = dict(**os.environ)\n\
    \n    # Ensure python 3 subprocess writes 'str' as utf-8\n    env['PYTHONIOENCODING']\
    \ = 'UTF-8'\n    # ... and ensure we read output as utf-8\n    kwargs['encoding']\
    \ = 'UTF-8'\n\n    return cmdargs, kwargs\n\n\ndef exec_python(*args: str, **kwargs:\
    \ str | None):\n    \"\"\"\n    Wrap running python script in a subprocess.\n\n\
    \    Return stdout of the invoked command.\n    \"\"\"\n    cmdargs, kwargs =\
    \ __wrap_python(args, kwargs)\n    return exec_command(*cmdargs, **kwargs)\n\n\
    \ndef exec_python_rc(*args: str, **kwargs: str | None):\n    \"\"\"\n    Wrap\
    \ running python script in a subprocess.\n\n    Return exit code of the invoked\
    \ command.\n    \"\"\"\n    cmdargs, kwargs = __wrap_python(args, kwargs)\n  \
    \  return exec_command_rc(*cmdargs, **kwargs)\n\n\n# Path handling.\n\n\n# Site-packages\
    \ functions - use native function if available.\ndef getsitepackages(prefixes:\
    \ list | None = None):\n    \"\"\"\n    Returns a list containing all global site-packages\
    \ directories.\n\n    For each directory present in ``prefixes`` (or the global\
    \ ``PREFIXES``), this function finds its `site-packages`\n    subdirectory depending\
    \ on the system environment, and returns a list of full paths.\n    \"\"\"\n \
    \   # This implementation was copied from the ``site`` module, python 3.7.3.\n\
    \    sitepackages = []\n    seen = set()\n\n    if prefixes is None:\n       \
    \ prefixes = [sys.prefix, sys.exec_prefix]\n\n    for prefix in prefixes:\n  \
    \      if not prefix or prefix in seen:\n            continue\n        seen.add(prefix)\n\
    \n        if os.sep == '/':\n            sitepackages.append(os.path.join(prefix,\
    \ \"lib\", \"python%d.%d\" % sys.version_info[:2], \"site-packages\"))\n     \
    \   else:\n            sitepackages.append(prefix)\n            sitepackages.append(os.path.join(prefix,\
    \ \"lib\", \"site-packages\"))\n    return sitepackages\n\n\n# Backported for\
    \ virtualenv. Module 'site' in virtualenv might not have this attribute.\ngetsitepackages\
    \ = getattr(site, 'getsitepackages', getsitepackages)\n\n\n# Wrapper to load a\
    \ module from a Python source file. This function loads import hooks when processing\
    \ them.\ndef importlib_load_source(name: str, pathname: str):\n    # Import module\
    \ from a file.\n    mod_loader = importlib.machinery.SourceFileLoader(name, pathname)\n\
    \    mod = types.ModuleType(mod_loader.name)\n    mod.__file__ = mod_loader.get_filename()\
    \  # Some hooks require __file__ attribute in their namespace\n    mod_loader.exec_module(mod)\n\
    \    return mod\n\n\n# Patterns of module names that should be bundled into the\
    \ base_library.zip to be available during bootstrap.\n# These modules include\
    \ direct or indirect dependencies of encodings.* modules. The encodings modules\
    \ must be\n# recursively included to set the I/O encoding during python startup.\
    \ Similarly, this list should include\n# modules used by PyInstaller's bootstrap\
    \ scripts and modules (loader/pyi*.py)\n\nPY3_BASE_MODULES = {\n    '_collections_abc',\n\
    \    '_weakrefset',\n    'abc',\n    'codecs',\n    'collections',\n    'copyreg',\n\
    \    'encodings',\n    'enum',\n    'functools',\n    'genericpath',  # dependency\
    \ of os.path\n    'io',\n    'heapq',\n    'keyword',\n    'linecache',\n    'locale',\n\
    \    'ntpath',  # dependency of os.path\n    'operator',\n    'os',\n    'posixpath',\
    \  # dependency of os.path\n    're',\n    'reprlib',\n    'sre_compile',\n  \
    \  'sre_constants',\n    'sre_parse',\n    'stat',  # dependency of os.path\n\
    \    'traceback',  # for startup errors\n    'types',\n    'weakref',\n    'warnings',\n\
    }\n\nif not is_py310:\n    PY3_BASE_MODULES.add('_bootlocale')\n\n# Object types\
    \ of Pure Python modules in modulegraph dependency graph.\n# Pure Python modules\
    \ have code object (attribute co_code).\nPURE_PYTHON_MODULE_TYPES = {\n    'SourceModule',\n\
    \    'CompiledModule',\n    'Package',\n    'NamespacePackage',\n    # Deprecated.\n\
    \    # TODO Could these module types be removed?\n    'FlatPackage',\n    'ArchiveModule',\n\
    }\n# Object types of special Python modules (built-in, run-time, namespace package)\
    \ in modulegraph dependency graph that do\n# not have code object.\nSPECIAL_MODULE_TYPES\
    \ = {\n    # Omit AliasNode from here (and consequently from VALID_MODULE_TYPES),\
    \ in order to prevent PyiModuleGraph from\n    # running standard hooks for aliased\
    \ modules.\n    #'AliasNode',\n    'BuiltinModule',\n    'RuntimeModule',\n  \
    \  'RuntimePackage',\n\n    # PyInstaller handles scripts differently and not\
    \ as standard Python modules.\n    'Script',\n}\n# Object types of Binary Python\
    \ modules (extensions, etc) in modulegraph dependency graph.\nBINARY_MODULE_TYPES\
    \ = {\n    'Extension',\n    'ExtensionPackage',\n}\n# Object types of valid Python\
    \ modules in modulegraph dependency graph.\nVALID_MODULE_TYPES = PURE_PYTHON_MODULE_TYPES\
    \ | SPECIAL_MODULE_TYPES | BINARY_MODULE_TYPES\n# Object types of bad/missing/invalid\
    \ Python modules in modulegraph dependency graph.\n# TODO: should be 'Invalid'\
    \ module types also in the 'MISSING' set?\nBAD_MODULE_TYPES = {\n    'BadModule',\n\
    \    'ExcludedModule',\n    'InvalidSourceModule',\n    'InvalidCompiledModule',\n\
    \    'MissingModule',\n\n    # Runtime modules and packages are technically valid\
    \ rather than bad, but exist only in-memory rather than on-disk\n    # (typically\
    \ due to pre_safe_import_module() hooks), and hence cannot be physically frozen.\
    \ For simplicity, these\n    # nodes are categorized as bad rather than valid.\n\
    \    'RuntimeModule',\n    'RuntimePackage',\n}\nALL_MODULE_TYPES = VALID_MODULE_TYPES\
    \ | BAD_MODULE_TYPES\n# TODO: review this mapping to TOC, remove useless entries.\n\
    # Dictionary to map ModuleGraph node types to TOC typecodes.\nMODULE_TYPES_TO_TOC_DICT\
    \ = {\n    # Pure modules.\n    'AliasNode': 'PYMODULE',\n    'Script': 'PYSOURCE',\n\
    \    'SourceModule': 'PYMODULE',\n    'CompiledModule': 'PYMODULE',\n    'Package':\
    \ 'PYMODULE',\n    'FlatPackage': 'PYMODULE',\n    'ArchiveModule': 'PYMODULE',\n\
    \    # Binary modules.\n    'Extension': 'EXTENSION',\n    'ExtensionPackage':\
    \ 'EXTENSION',\n    # Special valid modules.\n    'BuiltinModule': 'BUILTIN',\n\
    \    'NamespacePackage': 'PYMODULE',\n    # Bad modules.\n    'BadModule': 'bad',\n\
    \    'ExcludedModule': 'excluded',\n    'InvalidSourceModule': 'invalid',\n  \
    \  'InvalidCompiledModule': 'invalid',\n    'MissingModule': 'missing',\n    'RuntimeModule':\
    \ 'runtime',\n    'RuntimePackage': 'runtime',\n    # Other.\n    'does not occur':\
    \ 'BINARY',\n}\n\n\ndef check_requirements():\n    \"\"\"\n    Verify that all\
    \ requirements to run PyInstaller are met.\n\n    Fail hard if any requirement\
    \ is not met.\n    \"\"\"\n    # Fail hard if Python does not have minimum required\
    \ version\n    if sys.version_info < (3, 8):\n        raise EnvironmentError('PyInstaller\
    \ requires Python 3.8 or newer.')\n\n    # There are some old packages which used\
    \ to be backports of libraries which are now part of the standard library.\n \
    \   # These backports are now unmaintained and contain only an older subset of\
    \ features leading to obscure errors like\n    # \"enum has not attribute IntFlag\"\
    \ if installed.\n    from importlib.metadata import distribution, PackageNotFoundError\n\
    \n    for name in [\"enum34\", \"typing\", \"pathlib\"]:\n        try:\n     \
    \       dist = distribution(name)\n        except PackageNotFoundError:\n    \
    \        continue\n        remove = \"conda remove\" if is_conda else f'\"{sys.executable}\"\
    \ -m pip uninstall {name}'\n        raise SystemExit(\n            f\"The '{name}'\
    \ package is an obsolete backport of a standard library package and is incompatible\
    \ with \"\n            f\"PyInstaller. Please remove this package (located in\
    \ {dist.locate_file('')}) using\\n    {remove}\\n\"\n            \"then try again.\"\
    \n        )\n\n    # Bail out if binutils is not installed.\n    if is_linux and\
    \ shutil.which(\"objdump\") is None:\n        raise SystemExit(\n            \"\
    On Linux, objdump is required. It is typically provided by the 'binutils' package\
    \ \"\n            \"installable via your Linux distribution's package manager.\"\
    \n        )\n\n\n### Dependency File: log.py\n#-----------------------------------------------------------------------------\n\
    # Copyright (c) 2013-2023, PyInstaller Development Team.\n#\n# Distributed under\
    \ the terms of the GNU General Public License (version 2\n# or later) with exception\
    \ for distributing the bootloader.\n#\n# The full license is in the file COPYING.txt,\
    \ distributed with this software.\n#\n# SPDX-License-Identifier: (GPL-2.0-or-later\
    \ WITH Bootloader-exception)\n#-----------------------------------------------------------------------------\n\
    \"\"\"\nLogging module for PyInstaller.\n\"\"\"\n\n__all__ = ['getLogger', 'INFO',\
    \ 'WARN', 'DEBUG', 'TRACE', 'ERROR', 'FATAL', 'DEPRECATION']\n\nimport os\nimport\
    \ logging\nfrom logging import DEBUG, ERROR, FATAL, INFO, WARN, getLogger\n\n\
    TRACE = DEBUG - 5\nlogging.addLevelName(TRACE, 'TRACE')\nDEPRECATION = WARN +\
    \ 5\nlogging.addLevelName(DEPRECATION, 'DEPRECATION')\nLEVELS = {\n    'TRACE':\
    \ TRACE,\n    'DEBUG': DEBUG,\n    'INFO': INFO,\n    'WARN': WARN,\n    'DEPRECATION':\
    \ DEPRECATION,\n    'ERROR': ERROR,\n    'FATAL': FATAL,\n}\n\nFORMAT = '%(relativeCreated)d\
    \ %(levelname)s: %(message)s'\n_env_level = os.environ.get(\"PYI_LOG_LEVEL\",\
    \ \"INFO\")\ntry:\n    level = LEVELS[_env_level.upper()]\nexcept KeyError:\n\
    \    raise SystemExit(f\"Invalid PYI_LOG_LEVEL value '{_env_level}'. Should be\
    \ one of {list(LEVELS)}.\")\nlogging.basicConfig(format=FORMAT, level=level)\n\
    logger = getLogger('PyInstaller')\n\n\ndef __add_options(parser):\n    parser.add_argument(\n\
    \        '--log-level',\n        choices=LEVELS,\n        metavar=\"LEVEL\",\n\
    \        dest='loglevel',\n        help='Amount of detail in build-time console\
    \ messages. LEVEL may be one of %s (default: INFO). '\n        'Also settable\
    \ via and overrides the PYI_LOG_LEVEL environment variable.' % ', '.join(LEVELS),\n\
    \    )\n\n\ndef __process_options(parser, opts):\n    if opts.loglevel:\n    \
    \    try:\n            level = opts.loglevel.upper()\n            _level = LEVELS[level]\n\
    \        except KeyError:\n            parser.error('Unknown log level `%s`' %\
    \ opts.loglevel)\n        logger.setLevel(_level)\n        os.environ[\"PYI_LOG_LEVEL\"\
    ] = level\n\nOutput the complete test file, code only, no explanations.\n### Time\n\
    Current time: 2025-03-17 01:53:04\n"
  role: user
