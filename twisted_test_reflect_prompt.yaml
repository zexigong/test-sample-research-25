messages:
- content: You are an AI agent expert in writing unit tests. Your task is to write
    unit tests for the given code files of the repository. Make sure the tests can
    be executed without lint or compile errors.
  role: system
- content: "### Task Information\nBased on the source code, write/rewrite tests to\
    \ cover the source code.\nRepository: twisted\nTest File Path: twisted\\test_reflect\\\
    test_reflect.py\nProject Programming Language: Python\nTesting Framework: pytest\n\
    ### Source File Content\n### Source File Content:\n# -*- test-case-name: twisted.test.test_reflect\
    \ -*-\n# Copyright (c) Twisted Matrix Laboratories.\n# See LICENSE for details.\n\
    \n\"\"\"\nStandardized versions of various cool and/or strange things that you\
    \ can do\nwith Python's reflection capabilities.\n\"\"\"\n\n\nimport os\nimport\
    \ pickle\nimport re\nimport sys\nimport traceback\nimport types\nimport weakref\n\
    from collections import deque\nfrom io import IOBase, StringIO\nfrom typing import\
    \ Type, Union\n\nfrom twisted.python.compat import nativeString\nfrom twisted.python.deprecate\
    \ import _fullyQualifiedName as fullyQualifiedName\n\nRegexType = type(re.compile(\"\
    \"))\n\n\ndef prefixedMethodNames(classObj, prefix):\n    \"\"\"\n    Given a\
    \ class object C{classObj}, returns a list of method names that match\n    the\
    \ string C{prefix}.\n\n    @param classObj: A class object from which to collect\
    \ method names.\n\n    @param prefix: A native string giving a prefix.  Each method\
    \ with a name\n        which begins with this prefix will be returned.\n    @type\
    \ prefix: L{str}\n\n    @return: A list of the names of matching methods of C{classObj}\
    \ (and base\n        classes of C{classObj}).\n    @rtype: L{list} of L{str}\n\
    \    \"\"\"\n    dct = {}\n    addMethodNamesToDict(classObj, dct, prefix)\n \
    \   return list(dct.keys())\n\n\ndef addMethodNamesToDict(classObj, dict, prefix,\
    \ baseClass=None):\n    \"\"\"\n    This goes through C{classObj} (and its bases)\
    \ and puts method names\n    starting with 'prefix' in 'dict' with a value of\
    \ 1. if baseClass isn't\n    None, methods will only be added if classObj is-a\
    \ baseClass\n\n    If the class in question has the methods 'prefix_methodname'\
    \ and\n    'prefix_methodname2', the resulting dict should look something like:\n\
    \    {\"methodname\": 1, \"methodname2\": 1}.\n\n    @param classObj: A class\
    \ object from which to collect method names.\n\n    @param dict: A L{dict} which\
    \ will be updated with the results of the\n        accumulation.  Items are added\
    \ to this dictionary, with method names as\n        keys and C{1} as values.\n\
    \    @type dict: L{dict}\n\n    @param prefix: A native string giving a prefix.\
    \  Each method of C{classObj}\n        (and base classes of C{classObj}) with\
    \ a name which begins with this\n        prefix will be returned.\n    @type prefix:\
    \ L{str}\n\n    @param baseClass: A class object at which to stop searching upwards\
    \ for new\n        methods.  To collect all method names, do not pass a value\
    \ for this\n        parameter.\n\n    @return: L{None}\n    \"\"\"\n    for base\
    \ in classObj.__bases__:\n        addMethodNamesToDict(base, dict, prefix, baseClass)\n\
    \n    if baseClass is None or baseClass in classObj.__bases__:\n        for name,\
    \ method in classObj.__dict__.items():\n            optName = name[len(prefix)\
    \ :]\n            if (\n                (type(method) is types.FunctionType)\n\
    \                and (name[: len(prefix)] == prefix)\n                and (len(optName))\n\
    \            ):\n                dict[optName] = 1\n\n\ndef prefixedMethods(obj,\
    \ prefix=\"\"):\n    \"\"\"\n    Given an object C{obj}, returns a list of method\
    \ objects that match the\n    string C{prefix}.\n\n    @param obj: An arbitrary\
    \ object from which to collect methods.\n\n    @param prefix: A native string\
    \ giving a prefix.  Each method of C{obj} with\n        a name which begins with\
    \ this prefix will be returned.\n    @type prefix: L{str}\n\n    @return: A list\
    \ of the matching method objects.\n    @rtype: L{list}\n    \"\"\"\n    dct =\
    \ {}\n    accumulateMethods(obj, dct, prefix)\n    return list(dct.values())\n\
    \n\ndef accumulateMethods(obj, dict, prefix=\"\", curClass=None):\n    \"\"\"\n\
    \    Given an object C{obj}, add all methods that begin with C{prefix}.\n\n  \
    \  @param obj: An arbitrary object to collect methods from.\n\n    @param dict:\
    \ A L{dict} which will be updated with the results of the\n        accumulation.\
    \  Items are added to this dictionary, with method names as\n        keys and\
    \ corresponding instance method objects as values.\n    @type dict: L{dict}\n\n\
    \    @param prefix: A native string giving a prefix.  Each method of C{obj} with\n\
    \        a name which begins with this prefix will be returned.\n    @type prefix:\
    \ L{str}\n\n    @param curClass: The class in the inheritance hierarchy at which\
    \ to start\n        collecting methods.  Collection proceeds up.  To collect all\
    \ methods\n        from C{obj}, do not pass a value for this parameter.\n\n  \
    \  @return: L{None}\n    \"\"\"\n    if not curClass:\n        curClass = obj.__class__\n\
    \    for base in curClass.__bases__:\n        # The implementation of the object\
    \ class is different on PyPy vs.\n        # CPython.  This has the side effect\
    \ of making accumulateMethods()\n        # pick up object methods from all new-style\
    \ classes -\n        # such as __getattribute__, etc.\n        # If we ignore\
    \ 'object' when accumulating methods, we can get\n        # consistent behavior\
    \ on Pypy and CPython.\n        if base is not object:\n            accumulateMethods(obj,\
    \ dict, prefix, base)\n\n    for name, method in curClass.__dict__.items():\n\
    \        optName = name[len(prefix) :]\n        if (\n            (type(method)\
    \ is types.FunctionType)\n            and (name[: len(prefix)] == prefix)\n  \
    \          and (len(optName))\n        ):\n            dict[optName] = getattr(obj,\
    \ name)\n\n\ndef namedModule(name):\n    \"\"\"\n    Return a module given its\
    \ name.\n    \"\"\"\n    topLevel = __import__(name)\n    packages = name.split(\"\
    .\")[1:]\n    m = topLevel\n    for p in packages:\n        m = getattr(m, p)\n\
    \    return m\n\n\ndef namedObject(name):\n    \"\"\"\n    Get a fully named module-global\
    \ object.\n    \"\"\"\n    classSplit = name.split(\".\")\n    module = namedModule(\"\
    .\".join(classSplit[:-1]))\n    return getattr(module, classSplit[-1])\n\n\nnamedClass\
    \ = namedObject  # backwards compat\n\n\ndef requireModule(name, default=None):\n\
    \    \"\"\"\n    Try to import a module given its name, returning C{default} value\
    \ if\n    C{ImportError} is raised during import.\n\n    @param name: Module name\
    \ as it would have been passed to C{import}.\n    @type name: C{str}.\n\n    @param\
    \ default: Value returned in case C{ImportError} is raised while\n        importing\
    \ the module.\n\n    @return: Module or default value.\n    \"\"\"\n    try:\n\
    \        return namedModule(name)\n    except ImportError:\n        return default\n\
    \n\nclass _NoModuleFound(Exception):\n    \"\"\"\n    No module was found because\
    \ none exists.\n    \"\"\"\n\n\nclass InvalidName(ValueError):\n    \"\"\"\n \
    \   The given name is not a dot-separated list of Python objects.\n    \"\"\"\n\
    \n\nclass ModuleNotFound(InvalidName):\n    \"\"\"\n    The module associated\
    \ with the given name doesn't exist and it can't be\n    imported.\n    \"\"\"\
    \n\n\nclass ObjectNotFound(InvalidName):\n    \"\"\"\n    The object associated\
    \ with the given name doesn't exist and it can't be\n    imported.\n    \"\"\"\
    \n\n\ndef _importAndCheckStack(importName):\n    \"\"\"\n    Import the given\
    \ name as a module, then walk the stack to determine whether\n    the failure\
    \ was the module not existing, or some code in the module (for\n    example a\
    \ dependent import) failing.  This can be helpful to determine\n    whether any\
    \ actual application code was run.  For example, to distiguish\n    administrative\
    \ error (entering the wrong module name), from programmer\n    error (writing\
    \ buggy code in a module that fails to import).\n\n    @param importName: The\
    \ name of the module to import.\n    @type importName: C{str}\n    @raise Exception:\
    \ if something bad happens.  This can be any type of\n        exception, since\
    \ nobody knows what loading some arbitrary code might\n        do.\n    @raise\
    \ _NoModuleFound: if no module was found.\n    \"\"\"\n    try:\n        return\
    \ __import__(importName)\n    except ImportError:\n        excType, excValue,\
    \ excTraceback = sys.exc_info()\n        while excTraceback:\n            execName\
    \ = excTraceback.tb_frame.f_globals[\"__name__\"]\n            if execName ==\
    \ importName:\n                raise excValue.with_traceback(excTraceback)\n \
    \           excTraceback = excTraceback.tb_next\n        raise _NoModuleFound()\n\
    \n\ndef namedAny(name):\n    \"\"\"\n    Retrieve a Python object by its fully\
    \ qualified name from the global Python\n    module namespace.  The first part\
    \ of the name, that describes a module,\n    will be discovered and imported.\
    \  Each subsequent part of the name is\n    treated as the name of an attribute\
    \ of the object specified by all of the\n    name which came before it.  For example,\
    \ the fully-qualified name of this\n    object is 'twisted.python.reflect.namedAny'.\n\
    \n    @type name: L{str}\n    @param name: The name of the object to return.\n\
    \n    @raise InvalidName: If the name is an empty string, starts or ends with\n\
    \        a '.', or is otherwise syntactically incorrect.\n\n    @raise ModuleNotFound:\
    \ If the name is syntactically correct but the\n        module it specifies cannot\
    \ be imported because it does not appear to\n        exist.\n\n    @raise ObjectNotFound:\
    \ If the name is syntactically correct, includes at\n        least one '.', but\
    \ the module it specifies cannot be imported because\n        it does not appear\
    \ to exist.\n\n    @raise AttributeError: If an attribute of an object along the\
    \ way cannot be\n        accessed, or a module along the way is not found.\n\n\
    \    @return: the Python object identified by 'name'.\n    \"\"\"\n    if not\
    \ name:\n        raise InvalidName(\"Empty module name\")\n\n    names = name.split(\"\
    .\")\n\n    # if the name starts or ends with a '.' or contains '..', the __import__\n\
    \    # will raise an 'Empty module name' error. This will provide a better error\n\
    \    # message.\n    if \"\" in names:\n        raise InvalidName(\n         \
    \   \"name must be a string giving a '.'-separated list of Python \"\n       \
    \     \"identifiers, not %r\" % (name,)\n        )\n\n    topLevelPackage = None\n\
    \    moduleNames = names[:]\n    while not topLevelPackage:\n        if moduleNames:\n\
    \            trialname = \".\".join(moduleNames)\n            try:\n         \
    \       topLevelPackage = _importAndCheckStack(trialname)\n            except\
    \ _NoModuleFound:\n                moduleNames.pop()\n        else:\n        \
    \    if len(names) == 1:\n                raise ModuleNotFound(f\"No module named\
    \ {name!r}\")\n            else:\n                raise ObjectNotFound(f\"{name!r}\
    \ does not name an object\")\n\n    obj = topLevelPackage\n    for n in names[1:]:\n\
    \        obj = getattr(obj, n)\n\n    return obj\n\n\ndef filenameToModuleName(fn):\n\
    \    \"\"\"\n    Convert a name in the filesystem to the name of the Python module\
    \ it is.\n\n    This is aggressive about getting a module name back from a file;\
    \ it will\n    always return a string.  Aggressive means 'sometimes wrong'; it\
    \ won't look\n    at the Python path or try to do any error checking: don't use\
    \ this method\n    unless you already know that the filename you're talking about\
    \ is a Python\n    module.\n\n    @param fn: A filesystem path to a module or\
    \ package; C{bytes} on Python 2,\n        C{bytes} or C{unicode} on Python 3.\n\
    \n    @return: A hopefully importable module name.\n    @rtype: C{str}\n    \"\
    \"\"\n    if isinstance(fn, bytes):\n        initPy = b\"__init__.py\"\n    else:\n\
    \        initPy = \"__init__.py\"\n    fullName = os.path.abspath(fn)\n    base\
    \ = os.path.basename(fn)\n    if not base:\n        # this happens when fn ends\
    \ with a path separator, just skit it\n        base = os.path.basename(fn[:-1])\n\
    \    modName = nativeString(os.path.splitext(base)[0])\n    while 1:\n       \
    \ fullName = os.path.dirname(fullName)\n        if os.path.exists(os.path.join(fullName,\
    \ initPy)):\n            modName = \"{}.{}\".format(\n                nativeString(os.path.basename(fullName)),\n\
    \                nativeString(modName),\n            )\n        else:\n      \
    \      break\n    return modName\n\n\ndef qual(clazz: Type[object]) -> str:\n\
    \    \"\"\"\n    Return full import path of a class.\n    \"\"\"\n    return clazz.__module__\
    \ + \".\" + clazz.__name__\n\n\ndef _determineClass(x):\n    try:\n        return\
    \ x.__class__\n    except BaseException:\n        return type(x)\n\n\ndef _determineClassName(x):\n\
    \    c = _determineClass(x)\n    try:\n        return c.__name__\n    except BaseException:\n\
    \        try:\n            return str(c)\n        except BaseException:\n    \
    \        return \"<BROKEN CLASS AT 0x%x>\" % id(c)\n\n\ndef _safeFormat(formatter:\
    \ Union[types.FunctionType, Type[str]], o: object) -> str:\n    \"\"\"\n    Helper\
    \ function for L{safe_repr} and L{safe_str}.\n\n    Called when C{repr} or C{str}\
    \ fail. Returns a string containing info about\n    C{o} and the latest exception.\n\
    \n    @param formatter: C{str} or C{repr}.\n    @type formatter: C{type}\n   \
    \ @param o: Any object.\n\n    @rtype: C{str}\n    @return: A string containing\
    \ information about C{o} and the raised\n        exception.\n    \"\"\"\n    io\
    \ = StringIO()\n    traceback.print_exc(file=io)\n    className = _determineClassName(o)\n\
    \    tbValue = io.getvalue()\n    return \"<{} instance at 0x{:x} with {} error:\\\
    n {}>\".format(\n        className,\n        id(o),\n        formatter.__name__,\n\
    \        tbValue,\n    )\n\n\ndef safe_repr(o):\n    \"\"\"\n    Returns a string\
    \ representation of an object, or a string containing a\n    traceback, if that\
    \ object's __repr__ raised an exception.\n\n    @param o: Any object.\n\n    @rtype:\
    \ C{str}\n    \"\"\"\n    try:\n        return repr(o)\n    except BaseException:\n\
    \        return _safeFormat(repr, o)\n\n\ndef safe_str(o: object) -> str:\n  \
    \  \"\"\"\n    Returns a string representation of an object, or a string containing\
    \ a\n    traceback, if that object's __str__ raised an exception.\n\n    @param\
    \ o: Any object.\n    \"\"\"\n    if isinstance(o, bytes):\n        # If o is\
    \ bytes and seems to holds a utf-8 encoded string,\n        # convert it to str.\n\
    \        try:\n            return o.decode(\"utf-8\")\n        except BaseException:\n\
    \            pass\n    try:\n        return str(o)\n    except BaseException:\n\
    \        return _safeFormat(str, o)\n\n\nclass QueueMethod:\n    \"\"\"\n    I\
    \ represent a method that doesn't exist yet.\n    \"\"\"\n\n    def __init__(self,\
    \ name, calls):\n        self.name = name\n        self.calls = calls\n\n    def\
    \ __call__(self, *args):\n        self.calls.append((self.name, args))\n\n\ndef\
    \ fullFuncName(func):\n    qualName = str(pickle.whichmodule(func, func.__name__))\
    \ + \".\" + func.__name__\n    if namedObject(qualName) is not func:\n       \
    \ raise Exception(f\"Couldn't find {func} as {qualName}.\")\n    return qualName\n\
    \n\ndef getClass(obj):\n    \"\"\"\n    Return the class or type of object 'obj'.\n\
    \    \"\"\"\n    return type(obj)\n\n\ndef accumulateClassDict(classObj, attr,\
    \ adict, baseClass=None):\n    \"\"\"\n    Accumulate all attributes of a given\
    \ name in a class hierarchy into a single dictionary.\n\n    Assuming all class\
    \ attributes of this name are dictionaries.\n    If any of the dictionaries being\
    \ accumulated have the same key, the\n    one highest in the class hierarchy wins.\n\
    \    (XXX: If \\\"highest\\\" means \\\"closest to the starting class\\\".)\n\n\
    \    Ex::\n\n      class Soy:\n        properties = {\\\"taste\\\": \\\"bland\\\
    \"}\n\n      class Plant:\n        properties = {\\\"colour\\\": \\\"green\\\"\
    }\n\n      class Seaweed(Plant):\n        pass\n\n      class Lunch(Soy, Seaweed):\n\
    \        properties = {\\\"vegan\\\": 1 }\n\n      dct = {}\n\n      accumulateClassDict(Lunch,\
    \ \\\"properties\\\", dct)\n\n      print(dct)\n\n    {\\\"taste\\\": \\\"bland\\\
    \", \\\"colour\\\": \\\"green\\\", \\\"vegan\\\": 1}\n    \"\"\"\n    for base\
    \ in classObj.__bases__:\n        accumulateClassDict(base, attr, adict)\n   \
    \ if baseClass is None or baseClass in classObj.__bases__:\n        adict.update(classObj.__dict__.get(attr,\
    \ {}))\n\n\ndef accumulateClassList(classObj, attr, listObj, baseClass=None):\n\
    \    \"\"\"\n    Accumulate all attributes of a given name in a class hierarchy\
    \ into a single list.\n\n    Assuming all class attributes of this name are lists.\n\
    \    \"\"\"\n    for base in classObj.__bases__:\n        accumulateClassList(base,\
    \ attr, listObj)\n    if baseClass is None or baseClass in classObj.__bases__:\n\
    \        listObj.extend(classObj.__dict__.get(attr, []))\n\n\ndef isSame(a, b):\n\
    \    return a is b\n\n\ndef isLike(a, b):\n    return a == b\n\n\ndef modgrep(goal):\n\
    \    return objgrep(sys.modules, goal, isLike, \"sys.modules\")\n\n\ndef isOfType(start,\
    \ goal):\n    return type(start) is goal\n\n\ndef findInstances(start, t):\n \
    \   return objgrep(start, t, isOfType)\n\n\ndef objgrep(\n    start,\n    goal,\n\
    \    eq=isLike,\n    path=\"\",\n    paths=None,\n    seen=None,\n    showUnknowns=0,\n\
    \    maxDepth=None,\n):\n    \"\"\"\n    L{objgrep} finds paths between C{start}\
    \ and C{goal}.\n\n    Starting at the python object C{start}, we will loop over\
    \ every reachable\n    reference, tring to find the python object C{goal} (i.e.\
    \ every object\n    C{candidate} for whom C{eq(candidate, goal)} is truthy), and\
    \ return a\n    L{list} of L{str}, where each L{str} is Python syntax for a path\
    \ between\n    C{start} and C{goal}.\n\n    Since this can be slightly difficult\
    \ to visualize, here's an example::\n\n        >>> class Holder:\n        ...\
    \     def __init__(self, x):\n        ...         self.x = x\n        ...\n  \
    \      >>> start = Holder({\"irrelevant\": \"ignore\",\n        ...          \
    \       \"relevant\": [7, 1, 3, 5, 7]})\n        >>> for path in objgrep(start,\
    \ 7):\n        ...     print(\"start\" + path)\n        start.x['relevant'][0]\n\
    \        start.x['relevant'][4]\n\n    This can be useful, for example, when debugging\
    \ stateful graphs of objects\n    attached to a socket, trying to figure out where\
    \ a particular connection is\n    attached.\n\n    @param start: The object to\
    \ start looking at.\n\n    @param goal: The object to search for.\n\n    @param\
    \ eq: A 2-argument predicate which takes an object found by traversing\n     \
    \   references starting at C{start}, as well as C{goal}, and returns a\n     \
    \   boolean.\n\n    @param path: The prefix of the path to include in every return\
    \ value; empty\n        by default.\n\n    @param paths: The result object to\
    \ append values to; a list of strings.\n\n    @param seen: A dictionary mapping\
    \ ints (object IDs) to objects already\n        seen.\n\n    @param showUnknowns:\
    \ if true, print a message to C{stdout} when\n        encountering objects that\
    \ C{objgrep} does not know how to traverse.\n\n    @param maxDepth: The maximum\
    \ number of object references to attempt\n        traversing before giving up.\
    \  If an integer, limit to that many links,\n        if C{None}, unlimited.\n\n\
    \    @return: A list of strings representing python object paths starting at\n\
    \        C{start} and terminating at C{goal}.\n    \"\"\"\n    if paths is None:\n\
    \        paths = []\n    if seen is None:\n        seen = {}\n    if eq(start,\
    \ goal):\n        paths.append(path)\n    if id(start) in seen:\n        if seen[id(start)]\
    \ is start:\n            return\n    if maxDepth is not None:\n        if maxDepth\
    \ == 0:\n            return\n        maxDepth -= 1\n    seen[id(start)] = start\n\
    \    # Make an alias for those arguments which are passed recursively to\n   \
    \ # objgrep for container objects.\n    args = (paths, seen, showUnknowns, maxDepth)\n\
    \    if isinstance(start, dict):\n        for k, v in start.items():\n       \
    \     objgrep(k, goal, eq, path + \"{\" + repr(v) + \"}\", *args)\n          \
    \  objgrep(v, goal, eq, path + \"[\" + repr(k) + \"]\", *args)\n    elif isinstance(start,\
    \ (list, tuple, deque)):\n        for idx, _elem in enumerate(start):\n      \
    \      objgrep(start[idx], goal, eq, path + \"[\" + str(idx) + \"]\", *args)\n\
    \    elif isinstance(start, types.MethodType):\n        objgrep(start.__self__,\
    \ goal, eq, path + \".__self__\", *args)\n        objgrep(start.__func__, goal,\
    \ eq, path + \".__func__\", *args)\n        objgrep(start.__self__.__class__,\
    \ goal, eq, path + \".__self__.__class__\", *args)\n    elif hasattr(start, \"\
    __dict__\"):\n        for k, v in start.__dict__.items():\n            objgrep(v,\
    \ goal, eq, path + \".\" + k, *args)\n    elif isinstance(start, weakref.ReferenceType):\n\
    \        objgrep(start(), goal, eq, path + \"()\", *args)\n    elif isinstance(\n\
    \        start,\n        (\n            str,\n            int,\n            types.FunctionType,\n\
    \            types.BuiltinMethodType,\n            RegexType,\n            float,\n\
    \            type(None),\n            IOBase,\n        ),\n    ) or type(start).__name__\
    \ in (\n        \"wrapper_descriptor\",\n        \"method_descriptor\",\n    \
    \    \"member_descriptor\",\n        \"getset_descriptor\",\n    ):\n        pass\n\
    \    elif showUnknowns:\n        print(\"unknown type\", type(start), start)\n\
    \    return paths\n\n\n__all__ = [\n    \"InvalidName\",\n    \"ModuleNotFound\"\
    ,\n    \"ObjectNotFound\",\n    \"QueueMethod\",\n    \"namedModule\",\n    \"\
    namedObject\",\n    \"namedClass\",\n    \"namedAny\",\n    \"requireModule\"\
    ,\n    \"safe_repr\",\n    \"safe_str\",\n    \"prefixedMethodNames\",\n    \"\
    addMethodNamesToDict\",\n    \"prefixedMethods\",\n    \"accumulateMethods\",\n\
    \    \"fullFuncName\",\n    \"qual\",\n    \"getClass\",\n    \"accumulateClassDict\"\
    ,\n    \"accumulateClassList\",\n    \"isSame\",\n    \"isLike\",\n    \"modgrep\"\
    ,\n    \"isOfType\",\n    \"findInstances\",\n    \"objgrep\",\n    \"filenameToModuleName\"\
    ,\n    \"fullyQualifiedName\",\n]\n\n\n# This is to be removed when fixing #6986\n\
    __all__.remove(\"objgrep\")\n\n### Source File Dependency Files Content\n### Dependency\
    \ File: compat.py\n# -*- test-case-name: twisted.test.test_compat -*-\n#\n# Copyright\
    \ (c) Twisted Matrix Laboratories.\n# See LICENSE for details.\n\n\n\"\"\"\nCompatibility\
    \ module to provide backwards compatibility for useful Python\nfeatures.\n\nThis\
    \ is mainly for use of internal Twisted code. We encourage you to use\nthe latest\
    \ version of Python directly from your code, if possible.\n\n@var unicode: The\
    \ type of Unicode strings, C{unicode} on Python 2 and C{str}\n    on Python 3.\n\
    \n@var NativeStringIO: An in-memory file-like object that operates on the native\n\
    \    string type (bytes in Python 2, unicode in Python 3).\n\n@var urllib_parse:\
    \ a URL-parsing module (urlparse on Python 2, urllib.parse on\n    Python 3)\n\
    \"\"\"\n\n\nimport inspect\nimport os\nimport platform\nimport socket\nimport\
    \ urllib.parse as urllib_parse\nfrom collections.abc import Sequence\nfrom functools\
    \ import reduce\nfrom html import escape\nfrom http import cookiejar as cookielib\n\
    from io import IOBase, StringIO as NativeStringIO, TextIOBase\nfrom sys import\
    \ intern\nfrom types import FrameType, MethodType as _MethodType\nfrom typing\
    \ import Any, AnyStr, cast\nfrom urllib.parse import quote as urlquote, unquote\
    \ as urlunquote\n\nfrom incremental import Version\n\nfrom twisted.python.deprecate\
    \ import deprecated, deprecatedModuleAttribute\n\nif platform.python_implementation()\
    \ == \"PyPy\":\n    _PYPY = True\nelse:\n    _PYPY = False\n\nFileType = IOBase\n\
    deprecatedModuleAttribute(\n    Version(\"Twisted\", 21, 2, 0),\n    \"Obsolete\
    \ alias for io.IOBase\",\n    __name__,\n    \"FileType\",\n)\n\nfrozenset = frozenset\n\
    deprecatedModuleAttribute(\n    Version(\"Twisted\", 21, 2, 0),\n    \"Obsolete\
    \ alias for frozenset builtin type\",\n    __name__,\n    \"frozenset\",\n)\n\n\
    InstanceType = object\ndeprecatedModuleAttribute(\n    Version(\"Twisted\", 21,\
    \ 2, 0),\n    \"Old-style classes don't exist in Python 3\",\n    __name__,\n\
    \    \"InstanceType\",\n)\n\nizip = zip\ndeprecatedModuleAttribute(\n    Version(\"\
    Twisted\", 21, 2, 0),\n    \"Obsolete alias for zip() builtin\",\n    __name__,\n\
    \    \"izip\",\n)\n\nlong = int\ndeprecatedModuleAttribute(\n    Version(\"Twisted\"\
    , 21, 2, 0),\n    \"Obsolete alias for int builtin type\",\n    __name__,\n  \
    \  \"long\",\n)\n\nrange = range\ndeprecatedModuleAttribute(\n    Version(\"Twisted\"\
    , 21, 2, 0),\n    \"Obsolete alias for range() builtin\",\n    __name__,\n   \
    \ \"range\",\n)\n\nraw_input = input\ndeprecatedModuleAttribute(\n    Version(\"\
    Twisted\", 21, 2, 0),\n    \"Obsolete alias for input() builtin\",\n    __name__,\n\
    \    \"raw_input\",\n)\n\nset = set\ndeprecatedModuleAttribute(\n    Version(\"\
    Twisted\", 21, 2, 0),\n    \"Obsolete alias for set builtin type\",\n    __name__,\n\
    \    \"set\",\n)\n\nStringType = str\ndeprecatedModuleAttribute(\n    Version(\"\
    Twisted\", 21, 2, 0),\n    \"Obsolete alias for str builtin type\",\n    __name__,\n\
    \    \"StringType\",\n)\n\nunichr = chr\ndeprecatedModuleAttribute(\n    Version(\"\
    Twisted\", 21, 2, 0),\n    \"Obsolete alias for chr() builtin\",\n    __name__,\n\
    \    \"unichr\",\n)\n\nunicode = str\ndeprecatedModuleAttribute(\n    Version(\"\
    Twisted\", 21, 2, 0),\n    \"Obsolete alias for str builtin type\",\n    __name__,\n\
    \    \"unicode\",\n)\n\nxrange = range\ndeprecatedModuleAttribute(\n    Version(\"\
    Twisted\", 21, 2, 0),\n    \"Obsolete alias for range() builtin\",\n    __name__,\n\
    \    \"xrange\",\n)\n\n\n@deprecated(Version(\"Twisted\", 21, 2, 0), replacement=\"\
    d.items()\")\ndef iteritems(d):\n    \"\"\"\n    Return an iterable of the items\
    \ of C{d}.\n\n    @type d: L{dict}\n    @rtype: iterable\n    \"\"\"\n    return\
    \ d.items()\n\n\n@deprecated(Version(\"Twisted\", 21, 2, 0), replacement=\"d.values()\"\
    )\ndef itervalues(d):\n    \"\"\"\n    Return an iterable of the values of C{d}.\n\
    \n    @type d: L{dict}\n    @rtype: iterable\n    \"\"\"\n    return d.values()\n\
    \n\n@deprecated(Version(\"Twisted\", 21, 2, 0), replacement=\"list(d.items())\"\
    )\ndef items(d):\n    \"\"\"\n    Return a list of the items of C{d}.\n\n    @type\
    \ d: L{dict}\n    @rtype: L{list}\n    \"\"\"\n    return list(d.items())\n\n\n\
    def currentframe(n: int = 0) -> FrameType:\n    \"\"\"\n    In Python 3, L{inspect.currentframe}\
    \ does not take a stack-level argument.\n    Restore that functionality from Python\
    \ 2 so we don't have to re-implement\n    the C{f_back}-walking loop in places\
    \ where it's called.\n\n    @param n: The number of stack levels above the caller\
    \ to walk.\n\n    @return: a frame, n levels up the stack from the caller.\n \
    \   \"\"\"\n    f = inspect.currentframe()\n    for x in range(n + 1):\n     \
    \   assert f is not None\n        f = f.f_back\n    assert f is not None\n   \
    \ return f\n\n\ndef execfile(filename, globals, locals=None):\n    \"\"\"\n  \
    \  Execute a Python script in the given namespaces.\n\n    Similar to the execfile\
    \ builtin, but a namespace is mandatory, partly\n    because that's a sensible\
    \ thing to require, and because otherwise we'd\n    have to do some frame hacking.\n\
    \n    This is a compatibility implementation for Python 3 porting, to avoid the\n\
    \    use of the deprecated builtin C{execfile} function.\n    \"\"\"\n    if locals\
    \ is None:\n        locals = globals\n    with open(filename, \"rb\") as fin:\n\
    \        source = fin.read()\n    code = compile(source, filename, \"exec\")\n\
    \    exec(code, globals, locals)\n\n\n# type note: Can't find a Comparable type,\
    \ despite\n# https://github.com/python/typing/issues/59\ndef cmp(a: object, b:\
    \ object) -> int:\n    \"\"\"\n    Compare two objects.\n\n    Returns a negative\
    \ number if C{a < b}, zero if they are equal, and a\n    positive number if C{a\
    \ > b}.\n    \"\"\"\n    if a < b:  # type: ignore[operator]\n        return -1\n\
    \    elif a == b:\n        return 0\n    else:\n        return 1\n\n\ndef comparable(klass):\n\
    \    \"\"\"\n    Class decorator that ensures support for the special C{__cmp__}\
    \ method.\n\n    C{__eq__}, C{__lt__}, etc. methods are added to the class, relying\
    \ on\n    C{__cmp__} to implement their comparisons.\n    \"\"\"\n\n    def __eq__(self:\
    \ Any, other: object) -> bool:\n        c = cast(bool, self.__cmp__(other))\n\
    \        if c is NotImplemented:\n            return c\n        return c == 0\n\
    \n    def __ne__(self: Any, other: object) -> bool:\n        c = cast(bool, self.__cmp__(other))\n\
    \        if c is NotImplemented:\n            return c\n        return c != 0\n\
    \n    def __lt__(self: Any, other: object) -> bool:\n        c = cast(bool, self.__cmp__(other))\n\
    \        if c is NotImplemented:\n            return c\n        return c < 0\n\
    \n    def __le__(self: Any, other: object) -> bool:\n        c = cast(bool, self.__cmp__(other))\n\
    \        if c is NotImplemented:\n            return c\n        return c <= 0\n\
    \n    def __gt__(self: Any, other: object) -> bool:\n        c = cast(bool, self.__cmp__(other))\n\
    \        if c is NotImplemented:\n            return c\n        return c > 0\n\
    \n    def __ge__(self: Any, other: object) -> bool:\n        c = cast(bool, self.__cmp__(other))\n\
    \        if c is NotImplemented:\n            return c\n        return c >= 0\n\
    \n    klass.__lt__ = __lt__\n    klass.__gt__ = __gt__\n    klass.__le__ = __le__\n\
    \    klass.__ge__ = __ge__\n    klass.__eq__ = __eq__\n    klass.__ne__ = __ne__\n\
    \    return klass\n\n\ndef ioType(fileIshObject, default=str):\n    \"\"\"\n \
    \   Determine the type which will be returned from the given file object's\n \
    \   read() and accepted by its write() method as an argument.\n\n    In other\
    \ words, determine whether the given file is 'opened in text mode'.\n\n    @param\
    \ fileIshObject: Any object, but ideally one which resembles a file.\n    @type\
    \ fileIshObject: L{object}\n\n    @param default: A default value to return when\
    \ the type of C{fileIshObject}\n        cannot be determined.\n    @type default:\
    \ L{type}\n\n    @return: There are 3 possible return values:\n\n            1.\
    \ L{str}, if the file is unambiguously opened in text mode.\n\n            2.\
    \ L{bytes}, if the file is unambiguously opened in binary mode.\n\n          \
    \  3. The C{default} parameter, if the given type is not understood.\n\n    @rtype:\
    \ L{type}\n    \"\"\"\n    if isinstance(fileIshObject, TextIOBase):\n       \
    \ # If it's for text I/O, then it's for text I/O.\n        return str\n    if\
    \ isinstance(fileIshObject, IOBase):\n        # If it's for I/O but it's _not_\
    \ for text I/O, it's for bytes I/O.\n        return bytes\n    encoding = getattr(fileIshObject,\
    \ \"encoding\", None)\n    import codecs\n\n    if isinstance(fileIshObject, (codecs.StreamReader,\
    \ codecs.StreamWriter)):\n        # On StreamReaderWriter, the 'encoding' attribute\
    \ has special meaning;\n        # it is unambiguously text.\n        if encoding:\n\
    \            return str\n        else:\n            return bytes\n    return default\n\
    \n\ndef nativeString(s: AnyStr) -> str:\n    \"\"\"\n    Convert C{bytes} or C{str}\
    \ to C{str} type, using ASCII encoding if\n    conversion is necessary.\n\n  \
    \  @raise UnicodeError: The input string is not ASCII encodable/decodable.\n \
    \   @raise TypeError: The input is neither C{bytes} nor C{str}.\n    \"\"\"\n\
    \    if not isinstance(s, (bytes, str)):\n        raise TypeError(\"%r is neither\
    \ bytes nor str\" % s)\n    if isinstance(s, bytes):\n        return s.decode(\"\
    ascii\")\n    else:\n        # Ensure we're limited to ASCII subset:\n       \
    \ s.encode(\"ascii\")\n    return s\n\n\ndef _matchingString(constantString, inputString):\n\
    \    \"\"\"\n    Some functions, such as C{os.path.join}, operate on string arguments\
    \ which\n    may be bytes or text, and wish to return a value of the same type.\
    \  In\n    those cases you may wish to have a string constant (in the case of\n\
    \    C{os.path.join}, that constant would be C{os.path.sep}) involved in the\n\
    \    parsing or processing, that must be of a matching type in order to use\n\
    \    string operations on it.  L{_matchingString} will take a constant string\n\
    \    (either L{bytes} or L{str}) and convert it to the same type as the\n    input\
    \ string.  C{constantString} should contain only characters from ASCII;\n    to\
    \ ensure this, it will be encoded or decoded regardless.\n\n    @param constantString:\
    \ A string literal used in processing.\n    @type constantString: L{str} or L{bytes}\n\
    \n    @param inputString: A byte string or text string provided by the user.\n\
    \    @type inputString: L{str} or L{bytes}\n\n    @return: C{constantString} converted\
    \ into the same type as C{inputString}\n    @rtype: the type of C{inputString}\n\
    \    \"\"\"\n    if isinstance(constantString, bytes):\n        otherType = constantString.decode(\"\
    ascii\")\n    else:\n        otherType = constantString.encode(\"ascii\")\n  \
    \  if type(constantString) == type(inputString):\n        return constantString\n\
    \    else:\n        return otherType\n\n\n@deprecated(\n    Version(\"Twisted\"\
    , 21, 2, 0),\n    replacement=\"raise exception.with_traceback(traceback)\",\n\
    )\ndef reraise(exception, traceback):\n    \"\"\"\n    Re-raise an exception,\
    \ with an optional traceback.\n\n    Re-raised exceptions will be mutated, with\
    \ their C{__traceback__} attribute\n    being set.\n\n    @param exception: The\
    \ exception instance.\n    @param traceback: The traceback to use, or L{None}\
    \ indicating a new\n    traceback.\n    \"\"\"\n    raise exception.with_traceback(traceback)\n\
    \n\ndef iterbytes(originalBytes):\n    \"\"\"\n    Return an iterable wrapper\
    \ for a C{bytes} object that provides the behavior\n    of iterating over C{bytes}\
    \ on Python 2.\n\n    In particular, the results of iteration are the individual\
    \ bytes (rather\n    than integers as on Python 3).\n\n    @param originalBytes:\
    \ A C{bytes} object that will be wrapped.\n    \"\"\"\n    for i in range(len(originalBytes)):\n\
    \        yield originalBytes[i : i + 1]\n\n\n@deprecated(Version(\"Twisted\",\
    \ 21, 2, 0), replacement=\"b'%d'\")\ndef intToBytes(i: int) -> bytes:\n    \"\"\
    \"\n    Convert the given integer into C{bytes}, as ASCII-encoded Arab numeral.\n\
    \n    @param i: The C{int} to convert to C{bytes}.\n    @rtype: C{bytes}\n   \
    \ \"\"\"\n    return b\"%d\" % (i,)\n\n\ndef lazyByteSlice(object, offset=0, size=None):\n\
    \    \"\"\"\n    Return a memory view of the given bytes-like object.\n\n    If\
    \ an offset is given, the view starts at that offset. If a size is\n    given,\
    \ the view will only be of that length.\n\n    @param object: C{bytes} to be sliced.\n\
    \n    @param offset: C{int}, starting index of view.\n\n    @param size: Optional,\
    \ if an C{int} is given limit the length of the view\n        to this size.\n\
    \    \"\"\"\n    view = memoryview(object)\n    if size is None:\n        return\
    \ view[offset:]\n    else:\n        return view[offset : (offset + size)]\n\n\n\
    def networkString(s: str) -> bytes:\n    \"\"\"\n    Convert a string to L{bytes}\
    \ using ASCII encoding.\n\n    This is useful for sending text-like bytes that\
    \ are constructed using\n    string interpolation.  For example::\n\n        networkString(\"\
    Hello %d\" % (n,))\n\n    @param s: A string to convert to bytes.\n    @type s:\
    \ L{str}\n\n    @raise UnicodeError: The input string is not ASCII encodable.\n\
    \    @raise TypeError: The input is not L{str}.\n\n    @rtype: L{bytes}\n    \"\
    \"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Can only convert\
    \ strings to bytes\")\n    return s.encode(\"ascii\")\n\n\n@deprecated(Version(\"\
    Twisted\", 21, 2, 0), replacement=\"os.environb\")\ndef bytesEnviron():\n    \"\
    \"\"\n    Return a L{dict} of L{os.environ} where all text-strings are encoded\
    \ into\n    L{bytes}.\n\n    This function is POSIX only; environment variables\
    \ are always text strings\n    on Windows.\n    \"\"\"\n    encodekey = os.environ.encodekey\n\
    \    encodevalue = os.environ.encodevalue\n\n    return {encodekey(x): encodevalue(y)\
    \ for x, y in os.environ.items()}\n\n\ndef _constructMethod(cls, name, self):\n\
    \    \"\"\"\n    Construct a bound method.\n\n    @param cls: The class that the\
    \ method should be bound to.\n    @type cls: L{type}\n\n    @param name: The name\
    \ of the method.\n    @type name: native L{str}\n\n    @param self: The object\
    \ that the method is bound to.\n    @type self: any object\n\n    @return: a bound\
    \ method\n    @rtype: L{_MethodType}\n    \"\"\"\n    func = cls.__dict__[name]\n\
    \    return _MethodType(func, self)\n\n\ndef _pypy3BlockingHack():\n    \"\"\"\
    \n    Work around U{https://foss.heptapod.net/pypy/pypy/-/issues/3051}\n    by\
    \ replacing C{socket.fromfd} with a more conservative version.\n    \"\"\"\n \
    \   try:\n        from fcntl import F_GETFL, F_SETFL, fcntl\n    except ImportError:\n\
    \        return\n    if not _PYPY:\n        return\n\n    def fromFDWithoutModifyingFlags(fd,\
    \ family, type, proto=None):\n        passproto = [proto] * (proto is not None)\n\
    \        flags = fcntl(fd, F_GETFL)\n        try:\n            return realFromFD(fd,\
    \ family, type, *passproto)\n        finally:\n            fcntl(fd, F_SETFL,\
    \ flags)\n\n    realFromFD = socket.fromfd\n    if realFromFD.__name__ == fromFDWithoutModifyingFlags.__name__:\n\
    \        return\n    socket.fromfd = fromFDWithoutModifyingFlags\n\n\n_pypy3BlockingHack()\n\
    \n\ndeprecatedModuleAttribute(\n    Version(\"Twisted\", 21, 2, 0),\n    \"Use\
    \ functools.reduce() directly\",\n    __name__,\n    \"reduce\",\n)\n\ndeprecatedModuleAttribute(\n\
    \    Version(\"Twisted\", 21, 2, 0),\n    \"Use io.StringIO directly\",\n    __name__,\n\
    \    \"NativeStringIO\",\n)\n\ndeprecatedModuleAttribute(\n    Version(\"Twisted\"\
    , 21, 2, 0),\n    \"Import urllib.parse directly\",\n    __name__,\n    \"urllib_parse\"\
    ,\n)\n\ndeprecatedModuleAttribute(\n    Version(\"Twisted\", 21, 2, 0), \"Use\
    \ html.escape directly\", __name__, \"escape\"\n)\n\ndeprecatedModuleAttribute(\n\
    \    Version(\"Twisted\", 21, 2, 0),\n    \"Use urllib.parse.quote() directly\"\
    ,\n    __name__,\n    \"urlquote\",\n)\n\ndeprecatedModuleAttribute(\n    Version(\"\
    Twisted\", 21, 2, 0),\n    \"Use urllib.parse.unquote() directly\",\n    __name__,\n\
    \    \"urlunquote\",\n)\n\ndeprecatedModuleAttribute(\n    Version(\"Twisted\"\
    , 21, 2, 0),\n    \"Use http.cookiejar directly\",\n    __name__,\n    \"cookielib\"\
    ,\n)\n\ndeprecatedModuleAttribute(\n    Version(\"Twisted\", 21, 2, 0), \"Use\
    \ sys.intern() directly\", __name__, \"intern\"\n)\n\ndeprecatedModuleAttribute(\n\
    \    Version(\"Twisted\", 21, 2, 0),\n    \"Use collections.abc.Sequence directly\"\
    ,\n    __name__,\n    \"Sequence\",\n)\n\n\n__all__ = [\n    \"reraise\",\n  \
    \  \"execfile\",\n    \"frozenset\",\n    \"reduce\",\n    \"set\",\n    \"cmp\"\
    ,\n    \"comparable\",\n    \"nativeString\",\n    \"NativeStringIO\",\n    \"\
    networkString\",\n    \"unicode\",\n    \"iterbytes\",\n    \"intToBytes\",\n\
    \    \"lazyByteSlice\",\n    \"StringType\",\n    \"InstanceType\",\n    \"FileType\"\
    ,\n    \"items\",\n    \"iteritems\",\n    \"itervalues\",\n    \"range\",\n \
    \   \"xrange\",\n    \"urllib_parse\",\n    \"bytesEnviron\",\n    \"escape\"\
    ,\n    \"urlquote\",\n    \"urlunquote\",\n    \"cookielib\",\n    \"intern\"\
    ,\n    \"unichr\",\n    \"raw_input\",\n    \"Sequence\",\n]\n\n\n### Dependency\
    \ File: deprecate.py\n# -*- test-case-name: twisted.python.test.test_deprecate\
    \ -*-\n# Copyright (c) Twisted Matrix Laboratories.\n# See LICENSE for details.\n\
    \n\"\"\"\nDeprecation framework for Twisted.\n\nTo mark a method, function, or\
    \ class as being deprecated do this::\n\n    from incremental import Version\n\
    \    from twisted.python.deprecate import deprecated\n\n    @deprecated(Version(\"\
    Twisted\", 22, 10, 0))\n    def badAPI(self, first, second):\n        '''\n  \
    \      Docstring for badAPI.\n        '''\n        ...\n\n    @deprecated(Version(\"\
    Twisted\", 22, 10, 0))\n    class BadClass:\n        '''\n        Docstring for\
    \ BadClass.\n        '''\n\nThe newly-decorated badAPI will issue a warning when\
    \ called, and BadClass will\nissue a warning when instantiated. Both will also\
    \ have  a deprecation notice\nappended to their docstring.\n\nTo deprecate properties\
    \ you can use::\n\n    from incremental import Version\n    from twisted.python.deprecate\
    \ import deprecatedProperty\n\n    class OtherwiseUndeprecatedClass:\n\n     \
    \   @deprecatedProperty(Version(\"Twisted\", 22, 10, 0))\n        def badProperty(self):\n\
    \            '''\n            Docstring for badProperty.\n            '''\n\n\
    \        @badProperty.setter\n        def badProperty(self, value):\n        \
    \    '''\n            Setter sill also raise the deprecation warning.\n      \
    \      '''\n\n\nWhile it's best to avoid this as it adds performance overhead\
    \ to *any* usage of\nthe module, to mark module-level attributes as being deprecated\
    \ you can use::\n\n    badAttribute = \"someValue\"\n\n    ...\n\n    deprecatedModuleAttribute(\n\
    \        Version(\"Twisted\", 22, 10, 0),\n        \"Use goodAttribute instead.\"\
    ,\n        \"your.full.module.name\",\n        \"badAttribute\")\n\nThe deprecated\
    \ attributes will issue a warning whenever they are accessed. If\nthe attributes\
    \ being deprecated are in the same module as the\nL{deprecatedModuleAttribute}\
    \ call is being made from, the C{__name__} global\ncan be used as the C{moduleName}\
    \ parameter.\n\n\nTo mark an optional, keyword parameter of a function or method\
    \ as deprecated\nwithout deprecating the function itself, you can use::\n\n  \
    \  @deprecatedKeywordParameter(Version(\"Twisted\", 22, 10, 0), \"baz\")\n   \
    \ def someFunction(foo, bar=0, baz=None):\n        ...\n\nSee also L{incremental.Version}.\n\
    \n@type DEPRECATION_WARNING_FORMAT: C{str}\n@var DEPRECATION_WARNING_FORMAT: The\
    \ default deprecation warning string format\n    to use when one is not provided\
    \ by the user.\n\"\"\"\nfrom __future__ import annotations\n\n__all__ = [\n  \
    \  \"deprecated\",\n    \"deprecatedProperty\",\n    \"getDeprecationWarningString\"\
    ,\n    \"getWarningMethod\",\n    \"setWarningMethod\",\n    \"deprecatedModuleAttribute\"\
    ,\n    \"deprecatedKeywordParameter\",\n]\n\n\nimport inspect\nimport sys\nfrom\
    \ dis import findlinestarts\nfrom functools import wraps\nfrom types import ModuleType\n\
    from typing import Any, Callable, Dict, Optional, TypeVar, cast\nfrom warnings\
    \ import warn, warn_explicit\n\nfrom incremental import Version, getVersionString\n\
    from typing_extensions import ParamSpec\n\n_P = ParamSpec(\"_P\")\n_R = TypeVar(\"\
    _R\")\n\nDEPRECATION_WARNING_FORMAT = \"%(fqpn)s was deprecated in %(version)s\"\
    \n\n# Notionally, part of twisted.python.reflect, but defining it there causes\
    \ a\n# cyclic dependency between this module and that module.  Define it here,\n\
    # instead, and let reflect import it to re-expose to the public.\n\n\ndef _fullyQualifiedName(obj):\n\
    \    \"\"\"\n    Return the fully qualified name of a module, class, method or\
    \ function.\n    Classes and functions need to be module level ones to be correctly\n\
    \    qualified.\n\n    @rtype: C{str}.\n    \"\"\"\n    try:\n        name = obj.__qualname__\n\
    \    except AttributeError:\n        name = obj.__name__\n\n    if inspect.isclass(obj)\
    \ or inspect.isfunction(obj):\n        moduleName = obj.__module__\n        return\
    \ f\"{moduleName}.{name}\"\n    elif inspect.ismethod(obj):\n        return f\"\
    {obj.__module__}.{obj.__qualname__}\"\n    return name\n\n\n# Try to keep it looking\
    \ like something in twisted.python.reflect.\n_fullyQualifiedName.__module__ =\
    \ \"twisted.python.reflect\"\n_fullyQualifiedName.__name__ = \"fullyQualifiedName\"\
    \n_fullyQualifiedName.__qualname__ = \"fullyQualifiedName\"\n\n\ndef _getReplacementString(replacement):\n\
    \    \"\"\"\n    Surround a replacement for a deprecated API with some polite\
    \ text exhorting\n    the user to consider it as an alternative.\n\n    @type\
    \ replacement: C{str} or callable\n\n    @return: a string like \"please use twisted.python.modules.getModule\n\
    \        instead\".\n    \"\"\"\n    if callable(replacement):\n        replacement\
    \ = _fullyQualifiedName(replacement)\n    return f\"please use {replacement} instead\"\
    \n\n\ndef _getDeprecationDocstring(version, replacement=None):\n    \"\"\"\n \
    \   Generate an addition to a deprecated object's docstring that explains its\n\
    \    deprecation.\n\n    @param version: the version it was deprecated.\n    @type\
    \ version: L{incremental.Version}\n\n    @param replacement: The replacement,\
    \ if specified.\n    @type replacement: C{str} or callable\n\n    @return: a string\
    \ like \"Deprecated in Twisted 27.2.0; please use\n        twisted.timestream.tachyon.flux\
    \ instead.\"\n    \"\"\"\n    doc = f\"Deprecated in {getVersionString(version)}\"\
    \n    if replacement:\n        doc = f\"{doc}; {_getReplacementString(replacement)}\"\
    \n    return doc + \".\"\n\n\ndef _getDeprecationWarningString(fqpn, version,\
    \ format=None, replacement=None):\n    \"\"\"\n    Return a string indicating\
    \ that the Python name was deprecated in the given\n    version.\n\n    @param\
    \ fqpn: Fully qualified Python name of the thing being deprecated\n    @type fqpn:\
    \ C{str}\n\n    @param version: Version that C{fqpn} was deprecated in.\n    @type\
    \ version: L{incremental.Version}\n\n    @param format: A user-provided format\
    \ to interpolate warning values into, or\n        L{DEPRECATION_WARNING_FORMAT\n\
    \        <twisted.python.deprecate.DEPRECATION_WARNING_FORMAT>} if L{None} is\n\
    \        given.\n    @type format: C{str}\n\n    @param replacement: what should\
    \ be used in place of C{fqpn}. Either pass in\n        a string, which will be\
    \ inserted into the warning message, or a\n        callable, which will be expanded\
    \ to its full import path.\n    @type replacement: C{str} or callable\n\n    @return:\
    \ A textual description of the deprecation\n    @rtype: C{str}\n    \"\"\"\n \
    \   if format is None:\n        format = DEPRECATION_WARNING_FORMAT\n    warningString\
    \ = format % {\"fqpn\": fqpn, \"version\": getVersionString(version)}\n    if\
    \ replacement:\n        warningString = \"{}; {}\".format(\n            warningString,\
    \ _getReplacementString(replacement)\n        )\n    return warningString\n\n\n\
    def getDeprecationWarningString(callableThing, version, format=None, replacement=None):\n\
    \    \"\"\"\n    Return a string indicating that the callable was deprecated in\
    \ the given\n    version.\n\n    @type callableThing: C{callable}\n    @param\
    \ callableThing: Callable object to be deprecated\n\n    @type version: L{incremental.Version}\n\
    \    @param version: Version that C{callableThing} was deprecated in.\n\n    @type\
    \ format: C{str}\n    @param format: A user-provided format to interpolate warning\
    \ values into,\n        or L{DEPRECATION_WARNING_FORMAT\n        <twisted.python.deprecate.DEPRECATION_WARNING_FORMAT>}\
    \ if L{None} is\n        given\n\n    @param replacement: what should be used\
    \ in place of the callable. Either\n        pass in a string, which will be inserted\
    \ into the warning message,\n        or a callable, which will be expanded to\
    \ its full import path.\n    @type replacement: C{str} or callable\n\n    @return:\
    \ A string describing the deprecation.\n    @rtype: C{str}\n    \"\"\"\n    return\
    \ _getDeprecationWarningString(\n        _fullyQualifiedName(callableThing), version,\
    \ format, replacement\n    )\n\n\ndef _appendToDocstring(thingWithDoc, textToAppend):\n\
    \    \"\"\"\n    Append the given text to the docstring of C{thingWithDoc}.\n\n\
    \    If C{thingWithDoc} has no docstring, then the text just replaces the\n  \
    \  docstring. If it has a single-line docstring then it appends a blank line\n\
    \    and the message text. If it has a multi-line docstring, then in appends a\n\
    \    blank line a the message text, and also does the indentation correctly.\n\
    \    \"\"\"\n    if thingWithDoc.__doc__:\n        docstringLines = thingWithDoc.__doc__.splitlines()\n\
    \    else:\n        docstringLines = []\n\n    if len(docstringLines) == 0:\n\
    \        docstringLines.append(textToAppend)\n    elif len(docstringLines) ==\
    \ 1:\n        docstringLines.extend([\"\", textToAppend, \"\"])\n    else:\n \
    \       trailer = docstringLines[-1]\n        spaces = \"\"\n        if not trailer.strip():\n\
    \            # Deal with differences between Python 3.13 and older versions.\n\
    \            spaces = docstringLines.pop()\n        docstringLines.extend([\"\"\
    , spaces + textToAppend, spaces])\n        docstringLines = [l.lstrip(\" \") for\
    \ l in docstringLines]\n    thingWithDoc.__doc__ = \"\\n\".join(docstringLines)\n\
    \n\ndef deprecated(\n    version: Version, replacement: str | Callable[..., object]\
    \ | None = None\n) -> Callable[[Callable[_P, _R]], Callable[_P, _R]]:\n    \"\"\
    \"\n    Return a decorator that marks callables as deprecated. To deprecate a\n\
    \    property, see L{deprecatedProperty}.\n\n    @type version: L{incremental.Version}\n\
    \    @param version: The version in which the callable will be marked as\n   \
    \     having been deprecated.  The decorated function will be annotated\n    \
    \    with this version, having it set as its C{deprecatedVersion}\n        attribute.\n\
    \n    @param replacement: what should be used in place of the callable. Either\n\
    \        pass in a string, which will be inserted into the warning message,\n\
    \        or a callable, which will be expanded to its full import path.\n    @type\
    \ replacement: C{str} or callable\n    \"\"\"\n\n    def deprecationDecorator(function:\
    \ Callable[_P, _R]) -> Callable[_P, _R]:\n        \"\"\"\n        Decorator that\
    \ marks C{function} as deprecated.\n        \"\"\"\n        warningString = getDeprecationWarningString(\n\
    \            function, version, None, replacement\n        )\n\n        @wraps(function)\n\
    \        def deprecatedFunction(*args: _P.args, **kwargs: _P.kwargs) -> _R:\n\
    \            warn(warningString, DeprecationWarning, stacklevel=2)\n         \
    \   return function(*args, **kwargs)\n\n        _appendToDocstring(\n        \
    \    deprecatedFunction, _getDeprecationDocstring(version, replacement)\n    \
    \    )\n        deprecatedFunction.deprecatedVersion = version  # type: ignore[attr-defined]\n\
    \        return deprecatedFunction\n\n    return deprecationDecorator\n\n\ndef\
    \ deprecatedProperty(\n    version: Version, replacement: str | Callable[...,\
    \ object] | None = None\n) -> Callable[[Callable[_P, _R]], Callable[_P, _R]]:\n\
    \    \"\"\"\n    Return a decorator that marks a property as deprecated. To deprecate\
    \ a\n    regular callable or class, see L{deprecated}.\n\n    @type version: L{incremental.Version}\n\
    \    @param version: The version in which the callable will be marked as\n   \
    \     having been deprecated.  The decorated function will be annotated\n    \
    \    with this version, having it set as its C{deprecatedVersion}\n        attribute.\n\
    \n    @param replacement: what should be used in place of the callable.\n    \
    \    Either pass in a string, which will be inserted into the warning\n      \
    \  message, or a callable, which will be expanded to its full import\n       \
    \ path.\n    @type replacement: C{str} or callable\n\n    @return: A new property\
    \ with deprecated setter and getter.\n    @rtype: C{property}\n\n    @since: 16.1.0\n\
    \    \"\"\"\n\n    class _DeprecatedProperty(property):\n        \"\"\"\n    \
    \    Extension of the build-in property to allow deprecated setters.\n       \
    \ \"\"\"\n\n        def _deprecatedWrapper(self, function):\n            @wraps(function)\n\
    \            def deprecatedFunction(*args, **kwargs):\n                warn(\n\
    \                    self.warningString,  # type: ignore[attr-defined]\n     \
    \               DeprecationWarning,\n                    stacklevel=2,\n     \
    \           )\n                return function(*args, **kwargs)\n\n          \
    \  return deprecatedFunction\n\n        def setter(self, function):\n        \
    \    return property.setter(self, self._deprecatedWrapper(function))\n\n    def\
    \ deprecationDecorator(function):\n        warningString = getDeprecationWarningString(\n\
    \            function, version, None, replacement\n        )\n\n        @wraps(function)\n\
    \        def deprecatedFunction(*args, **kwargs):\n            warn(warningString,\
    \ DeprecationWarning, stacklevel=2)\n            return function(*args, **kwargs)\n\
    \n        _appendToDocstring(\n            deprecatedFunction, _getDeprecationDocstring(version,\
    \ replacement)\n        )\n        deprecatedFunction.deprecatedVersion = version\
    \  # type: ignore[attr-defined]\n\n        result = _DeprecatedProperty(deprecatedFunction)\n\
    \        result.warningString = warningString  # type: ignore[attr-defined]\n\
    \        return result\n\n    return deprecationDecorator\n\n\ndef getWarningMethod():\n\
    \    \"\"\"\n    Return the warning method currently used to record deprecation\
    \ warnings.\n    \"\"\"\n    return warn\n\n\ndef setWarningMethod(newMethod):\n\
    \    \"\"\"\n    Set the warning method to use to record deprecation warnings.\n\
    \n    The callable should take message, category and stacklevel. The return\n\
    \    value is ignored.\n    \"\"\"\n    global warn\n    warn = newMethod\n\n\n\
    class _InternalState:\n    \"\"\"\n    An L{_InternalState} is a helper object\
    \ for a L{_ModuleProxy}, so that it\n    can easily access its own attributes,\
    \ bypassing its logic for delegating to\n    another object that it's proxying\
    \ for.\n\n    @ivar proxy: a L{_ModuleProxy}\n    \"\"\"\n\n    def __init__(self,\
    \ proxy):\n        object.__setattr__(self, \"proxy\", proxy)\n\n    def __getattribute__(self,\
    \ name):\n        return object.__getattribute__(object.__getattribute__(self,\
    \ \"proxy\"), name)\n\n    def __setattr__(self, name, value):\n        return\
    \ object.__setattr__(object.__getattribute__(self, \"proxy\"), name, value)\n\n\
    \nclass _ModuleProxy:\n    \"\"\"\n    Python module wrapper to hook module-level\
    \ attribute access.\n\n    Access to deprecated attributes first checks\n    L{_ModuleProxy._deprecatedAttributes},\
    \ if the attribute does not appear\n    there then access falls through to L{_ModuleProxy._module},\
    \ the wrapped\n    module object.\n\n    @ivar _module: Module on which to hook\
    \ attribute access.\n    @type _module: C{module}\n\n    @ivar _deprecatedAttributes:\
    \ Mapping of attribute names to objects that\n        retrieve the module attribute's\
    \ original value.\n    @type _deprecatedAttributes: C{dict} mapping C{str} to\n\
    \        L{_DeprecatedAttribute}\n\n    @ivar _lastWasPath: Heuristic guess as\
    \ to whether warnings about this\n        package should be ignored for the next\
    \ call.  If the last attribute\n        access of this module was a C{getattr}\
    \ of C{__path__}, we will assume\n        that it was the import system doing\
    \ it and we won't emit a warning for\n        the next access, even if it is to\
    \ a deprecated attribute.  The CPython\n        import system always tries to\
    \ access C{__path__}, then the attribute\n        itself, then the attribute itself\
    \ again, in both successful and failed\n        cases.\n    @type _lastWasPath:\
    \ C{bool}\n    \"\"\"\n\n    def __init__(self, module):\n        state = _InternalState(self)\n\
    \        state._module = module\n        state._deprecatedAttributes = {}\n  \
    \      state._lastWasPath = False\n\n    def __repr__(self) -> str:\n        \"\
    \"\"\n        Get a string containing the type of the module proxy and a\n   \
    \     representation of the wrapped module object.\n        \"\"\"\n        state\
    \ = _InternalState(self)\n        return f\"<{type(self).__name__} module={state._module!r}>\"\
    \n\n    def __setattr__(self, name, value):\n        \"\"\"\n        Set an attribute\
    \ on the wrapped module object.\n        \"\"\"\n        state = _InternalState(self)\n\
    \        state._lastWasPath = False\n        setattr(state._module, name, value)\n\
    \n    def __getattribute__(self, name):\n        \"\"\"\n        Get an attribute\
    \ from the module object, possibly emitting a warning.\n\n        If the specified\
    \ name has been deprecated, then a warning is issued.\n        (Unless certain\
    \ obscure conditions are met; see\n        L{_ModuleProxy._lastWasPath} for more\
    \ information about what might quash\n        such a warning.)\n        \"\"\"\
    \n        state = _InternalState(self)\n        if state._lastWasPath:\n     \
    \       deprecatedAttribute = None\n        else:\n            deprecatedAttribute\
    \ = state._deprecatedAttributes.get(name)\n\n        if deprecatedAttribute is\
    \ not None:\n            # If we have a _DeprecatedAttribute object from the earlier\
    \ lookup,\n            # allow it to issue the warning.\n            value = deprecatedAttribute.get()\n\
    \        else:\n            # Otherwise, just retrieve the underlying value directly;\
    \ it's not\n            # deprecated, there's no warning to issue.\n         \
    \   value = getattr(state._module, name)\n        if name == \"__path__\":\n \
    \           state._lastWasPath = True\n        else:\n            state._lastWasPath\
    \ = False\n        return value\n\n\nclass _DeprecatedAttribute:\n    \"\"\"\n\
    \    Wrapper for deprecated attributes.\n\n    This is intended to be used by\
    \ L{_ModuleProxy}. Calling\n    L{_DeprecatedAttribute.get} will issue a warning\
    \ and retrieve the\n    underlying attribute's value.\n\n    @type module: C{module}\n\
    \    @ivar module: The original module instance containing this attribute\n\n\
    \    @type fqpn: C{str}\n    @ivar fqpn: Fully qualified Python name for the deprecated\
    \ attribute\n\n    @type version: L{incremental.Version}\n    @ivar version: Version\
    \ that the attribute was deprecated in\n\n    @type message: C{str}\n    @ivar\
    \ message: Deprecation message\n    \"\"\"\n\n    def __init__(self, module, name,\
    \ version, message):\n        \"\"\"\n        Initialise a deprecated name wrapper.\n\
    \        \"\"\"\n        self.module = module\n        self.__name__ = name\n\
    \        self.fqpn = module.__name__ + \".\" + name\n        self.version = version\n\
    \        self.message = message\n\n    def get(self):\n        \"\"\"\n      \
    \  Get the underlying attribute value and issue a deprecation warning.\n     \
    \   \"\"\"\n        # This might fail if the deprecated thing is a module inside\
    \ a package.\n        # In that case, don't emit the warning this time.  The import\
    \ system\n        # will come back again when it's not an AttributeError and we\
    \ can emit\n        # the warning then.\n        result = getattr(self.module,\
    \ self.__name__)\n        message = _getDeprecationWarningString(\n          \
    \  self.fqpn, self.version, DEPRECATION_WARNING_FORMAT + \": \" + self.message\n\
    \        )\n        warn(message, DeprecationWarning, stacklevel=3)\n        return\
    \ result\n\n\ndef _deprecateAttribute(proxy, name, version, message):\n    \"\"\
    \"\n    Mark a module-level attribute as being deprecated.\n\n    @type proxy:\
    \ L{_ModuleProxy}\n    @param proxy: The module proxy instance proxying the deprecated\
    \ attributes\n\n    @type name: C{str}\n    @param name: Attribute name\n\n  \
    \  @type version: L{incremental.Version}\n    @param version: Version that the\
    \ attribute was deprecated in\n\n    @type message: C{str}\n    @param message:\
    \ Deprecation message\n    \"\"\"\n    _module = object.__getattribute__(proxy,\
    \ \"_module\")\n    attr = _DeprecatedAttribute(_module, name, version, message)\n\
    \    # Add a deprecated attribute marker for this module's attribute. When this\n\
    \    # attribute is accessed via _ModuleProxy a warning is emitted.\n    _deprecatedAttributes\
    \ = object.__getattribute__(proxy, \"_deprecatedAttributes\")\n    _deprecatedAttributes[name]\
    \ = attr\n\n\ndef deprecatedModuleAttribute(version, message, moduleName, name):\n\
    \    \"\"\"\n    Declare a module-level attribute as being deprecated.\n\n   \
    \ @type version: L{incremental.Version}\n    @param version: Version that the\
    \ attribute was deprecated in\n\n    @type message: C{str}\n    @param message:\
    \ Deprecation message\n\n    @type moduleName: C{str}\n    @param moduleName:\
    \ Fully-qualified Python name of the module containing\n        the deprecated\
    \ attribute; if called from the same module as the\n        attributes are being\
    \ deprecated in, using the C{__name__} global can\n        be helpful\n\n    @type\
    \ name: C{str}\n    @param name: Attribute name to deprecate\n    \"\"\"\n   \
    \ module = sys.modules[moduleName]\n    if not isinstance(module, _ModuleProxy):\n\
    \        module = cast(ModuleType, _ModuleProxy(module))\n        sys.modules[moduleName]\
    \ = module\n\n    _deprecateAttribute(module, name, version, message)\n\n\ndef\
    \ warnAboutFunction(offender, warningString):\n    \"\"\"\n    Issue a warning\
    \ string, identifying C{offender} as the responsible code.\n\n    This function\
    \ is used to deprecate some behavior of a function.  It differs\n    from L{warnings.warn}\
    \ in that it is not limited to deprecating the behavior\n    of a function currently\
    \ on the call stack.\n\n    @param offender: The function that is being deprecated.\n\
    \n    @param warningString: The string that should be emitted by this warning.\n\
    \    @type warningString: C{str}\n\n    @since: 11.0\n    \"\"\"\n    # inspect.getmodule()\
    \ is attractive, but somewhat\n    # broken in Python < 2.6.  See Python bug 4845.\n\
    \    # In Python 3.13 line numbers returned by findlinestarts\n    # can be None\
    \ for bytecode that does not map to source\n    # lines.\n    offenderModule =\
    \ sys.modules[offender.__module__]\n    warn_explicit(\n        warningString,\n\
    \        category=DeprecationWarning,\n        filename=inspect.getabsfile(offenderModule),\n\
    \        lineno=max(\n            lineNumber\n            for _, lineNumber in\
    \ findlinestarts(offender.__code__)\n            if lineNumber is not None\n \
    \       ),\n        module=offenderModule.__name__,\n        registry=offender.__globals__.setdefault(\"\
    __warningregistry__\", {}),\n        module_globals=None,\n    )\n\n\ndef _passedArgSpec(argspec,\
    \ positional, keyword):\n    \"\"\"\n    Take an I{inspect.ArgSpec}, a tuple of\
    \ positional arguments, and a dict of\n    keyword arguments, and return a mapping\
    \ of arguments that were actually\n    passed to their passed values.\n\n    @param\
    \ argspec: The argument specification for the function to inspect.\n    @type\
    \ argspec: I{inspect.ArgSpec}\n\n    @param positional: The positional arguments\
    \ that were passed.\n    @type positional: L{tuple}\n\n    @param keyword: The\
    \ keyword arguments that were passed.\n    @type keyword: L{dict}\n\n    @return:\
    \ A dictionary mapping argument names (those declared in C{argspec})\n       \
    \ to values that were passed explicitly by the user.\n    @rtype: L{dict} mapping\
    \ L{str} to L{object}\n    \"\"\"\n    result: Dict[str, object] = {}\n    unpassed\
    \ = len(argspec.args) - len(positional)\n    if argspec.keywords is not None:\n\
    \        kwargs = result[argspec.keywords] = {}\n    if unpassed < 0:\n      \
    \  if argspec.varargs is None:\n            raise TypeError(\"Too many arguments.\"\
    )\n        else:\n            result[argspec.varargs] = positional[len(argspec.args)\
    \ :]\n    for name, value in zip(argspec.args, positional):\n        result[name]\
    \ = value\n    for name, value in keyword.items():\n        if name in argspec.args:\n\
    \            if name in result:\n                raise TypeError(\"Already passed.\"\
    )\n            result[name] = value\n        elif argspec.keywords is not None:\n\
    \            kwargs[name] = value\n        else:\n            raise TypeError(\"\
    no such param\")\n    return result\n\n\ndef _passedSignature(signature, positional,\
    \ keyword):\n    \"\"\"\n    Take an L{inspect.Signature}, a tuple of positional\
    \ arguments, and a dict of\n    keyword arguments, and return a mapping of arguments\
    \ that were actually\n    passed to their passed values.\n\n    @param signature:\
    \ The signature of the function to inspect.\n    @type signature: L{inspect.Signature}\n\
    \n    @param positional: The positional arguments that were passed.\n    @type\
    \ positional: L{tuple}\n\n    @param keyword: The keyword arguments that were\
    \ passed.\n    @type keyword: L{dict}\n\n    @return: A dictionary mapping argument\
    \ names (those declared in\n        C{signature}) to values that were passed explicitly\
    \ by the user.\n    @rtype: L{dict} mapping L{str} to L{object}\n    \"\"\"\n\
    \    result = {}\n    kwargs = None\n    numPositional = 0\n    for n, (name,\
    \ param) in enumerate(signature.parameters.items()):\n        if param.kind ==\
    \ inspect.Parameter.VAR_POSITIONAL:\n            # Varargs, for example: *args\n\
    \            result[name] = positional[n:]\n            numPositional = len(result[name])\
    \ + 1\n        elif param.kind == inspect.Parameter.VAR_KEYWORD:\n           \
    \ # Variable keyword args, for example: **my_kwargs\n            kwargs = result[name]\
    \ = {}\n        elif param.kind in (\n            inspect.Parameter.POSITIONAL_OR_KEYWORD,\n\
    \            inspect.Parameter.POSITIONAL_ONLY,\n        ):\n            if n\
    \ < len(positional):\n                result[name] = positional[n]\n         \
    \       numPositional += 1\n        elif param.kind == inspect.Parameter.KEYWORD_ONLY:\n\
    \            if name not in keyword:\n                if param.default == inspect.Parameter.empty:\n\
    \                    raise TypeError(f\"missing keyword arg {name}\")\n      \
    \          else:\n                    result[name] = param.default\n        else:\n\
    \            raise TypeError(f\"'{name}' parameter is invalid kind: {param.kind}\"\
    )\n\n    if len(positional) > numPositional:\n        raise TypeError(\"Too many\
    \ arguments.\")\n    for name, value in keyword.items():\n        if name in signature.parameters.keys():\n\
    \            if name in result:\n                raise TypeError(\"Already passed.\"\
    )\n            result[name] = value\n        elif kwargs is not None:\n      \
    \      kwargs[name] = value\n        else:\n            raise TypeError(\"no such\
    \ param\")\n    return result\n\n\ndef _mutuallyExclusiveArguments(argumentPairs):\n\
    \    \"\"\"\n    Decorator which causes its decoratee to raise a L{TypeError}\
    \ if two of the\n    given arguments are passed at the same time.\n\n    @param\
    \ argumentPairs: pairs of argument identifiers, each pair indicating\n       \
    \ an argument that may not be passed in conjunction with another.\n    @type argumentPairs:\
    \ sequence of 2-sequences of L{str}\n\n    @return: A decorator, used like so::\n\
    \n            @_mutuallyExclusiveArguments([[\"tweedledum\", \"tweedledee\"]])\n\
    \            def function(tweedledum=1, tweedledee=2):\n                \"Don't\
    \ pass tweedledum and tweedledee at the same time.\"\n\n    @rtype: 1-argument\
    \ callable taking a callable and returning a callable.\n    \"\"\"\n\n    def\
    \ wrapper(wrappee):\n        spec = inspect.signature(wrappee)\n        _passed\
    \ = _passedSignature\n\n        @wraps(wrappee)\n        def wrapped(*args, **kwargs):\n\
    \            arguments = _passed(spec, args, kwargs)\n            for this, that\
    \ in argumentPairs:\n                if this in arguments and that in arguments:\n\
    \                    raise TypeError(\n                        (\"The %r and %r\
    \ arguments to %s \" \"are mutually exclusive.\")\n                        % (this,\
    \ that, _fullyQualifiedName(wrappee))\n                    )\n            return\
    \ wrappee(*args, **kwargs)\n\n        return wrapped\n\n    return wrapper\n\n\
    \n_Tc = TypeVar(\"_Tc\", bound=Callable[..., Any])\n\n\ndef deprecatedKeywordParameter(\n\
    \    version: Version, name: str, replacement: Optional[str] = None\n) -> Callable[[_Tc],\
    \ _Tc]:\n    \"\"\"\n    Return a decorator that marks a keyword parameter of\
    \ a callable\n    as deprecated. A warning will be emitted if a caller supplies\n\
    \    a value for the parameter, whether the caller uses a keyword or\n    positional\
    \ syntax.\n\n    @type version: L{incremental.Version}\n    @param version: The\
    \ version in which the parameter will be marked as\n        having been deprecated.\n\
    \n    @type name: L{str}\n    @param name: The name of the deprecated parameter.\n\
    \n    @type replacement: L{str}\n    @param replacement: Optional text indicating\
    \ what should be used in\n        place of the deprecated parameter.\n\n    @since:\
    \ Twisted 21.2.0\n    \"\"\"\n\n    def wrapper(wrappee: _Tc) -> _Tc:\n      \
    \  warningString = _getDeprecationWarningString(\n            f\"The {name!r}\
    \ parameter to {_fullyQualifiedName(wrappee)}\",\n            version,\n     \
    \       replacement=replacement,\n        )\n\n        doc = \"The {!r} parameter\
    \ was deprecated in {}\".format(\n            name,\n            getVersionString(version),\n\
    \        )\n        if replacement:\n            doc = doc + \"; \" + _getReplacementString(replacement)\n\
    \        doc += \".\"\n\n        params = inspect.signature(wrappee).parameters\n\
    \        if (\n            name in params\n            and params[name].kind ==\
    \ inspect.Parameter.POSITIONAL_OR_KEYWORD\n        ):\n            parameterIndex\
    \ = list(params).index(name)\n\n            def checkDeprecatedParameter(*args,\
    \ **kwargs):\n                if len(args) > parameterIndex or name in kwargs:\n\
    \                    warn(warningString, DeprecationWarning, stacklevel=2)\n \
    \               return wrappee(*args, **kwargs)\n\n        else:\n\n         \
    \   def checkDeprecatedParameter(*args, **kwargs):\n                if name in\
    \ kwargs:\n                    warn(warningString, DeprecationWarning, stacklevel=2)\n\
    \                return wrappee(*args, **kwargs)\n\n        decorated = cast(_Tc,\
    \ wraps(wrappee)(checkDeprecatedParameter))\n        _appendToDocstring(decorated,\
    \ doc)\n        return decorated\n\n    return wrapper\n\nOutput the complete\
    \ test file, code only, no explanations.\n### Time\nCurrent time: 2025-03-17 01:43:46\n"
  role: user
