messages:
- content: You are an AI agent expert in writing unit tests. Your task is to write
    unit tests for the given code files of the repository. Make sure the tests can
    be executed without lint or compile errors.
  role: system
- content: "### Task Information\nBased on the source code, write/rewrite tests to\
    \ cover the source code.\nRepository: pyinstaller\nTest File Path: pyinstaller\\\
    test_bytecode\\test_bytecode.py\nProject Programming Language: Python\nTesting\
    \ Framework: pytest\n### Source File Content\n### Source File Content:\n#-----------------------------------------------------------------------------\n\
    # Copyright (c) 2021-2023, PyInstaller Development Team.\n#\n# Distributed under\
    \ the terms of the GNU General Public License (version 2\n# or later) with exception\
    \ for distributing the bootloader.\n#\n# The full license is in the file COPYING.txt,\
    \ distributed with this software.\n#\n# SPDX-License-Identifier: (GPL-2.0-or-later\
    \ WITH Bootloader-exception)\n#-----------------------------------------------------------------------------\n\
    \"\"\"\nTools for searching bytecode for key statements that indicate the need\
    \ for additional resources, such as data files\nand package metadata.\n\nBy *bytecode*\
    \ I mean the ``code`` object given by ``compile()``, accessible from the ``__code__``\
    \ attribute of any\nnon-builtin function or, in PyInstallerLand, the ``PyiModuleGraph.node(\"\
    some.module\").code`` attribute. The best\nguide for bytecode format I have found\
    \ is the disassembler reference: https://docs.python.org/3/library/dis.html\n\n\
    This parser implementation aims to combine the flexibility and speed of regex\
    \ with the clarity of the output of\n``dis.dis(code)``. It has not achieved the\
    \ 2nd, but C'est la vie...\n\nThe biggest clarity killer here is the ``EXTENDED_ARG``\
    \ opcode which can appear almost anywhere and therefore needs\nto be tiptoed around\
    \ at every step. If this code needs to expand significantly, I would recommend\
    \ an upgrade to a\nregex-based grammar parsing library such as Reparse. This way,\
    \ little steps like unpacking ``EXTENDED_ARGS`` can be\ndefined once then simply\
    \ referenced forming a nice hierarchy rather than copied everywhere its needed.\n\
    \"\"\"\n\nimport dis\nimport re\nfrom types import CodeType\nfrom typing import\
    \ Pattern\n\nfrom PyInstaller import compat\n\n# opcode name -> opcode map\n#\
    \ Python 3.11 introduced specialized opcodes that are not covered by opcode.opmap\
    \ (and equivalent dis.opmap), but dis\n# has a private map of all opcodes called\
    \ _all_opmap. So use the latter, if available.\nopmap = getattr(dis, '_all_opmap',\
    \ dis.opmap)\n\n\ndef _instruction_to_regex(x: str):\n    \"\"\"\n    Get a regex-escaped\
    \ opcode byte from its human readable name.\n    \"\"\"\n    return re.escape(bytes([opmap[x]]))\n\
    \n\ndef bytecode_regex(pattern: bytes, flags=re.VERBOSE | re.DOTALL):\n    \"\"\
    \"\n    A regex-powered Python bytecode matcher.\n\n    ``bytecode_regex`` provides\
    \ a very thin wrapper around :func:`re.compile`.\n\n      * Any opcode names wrapped\
    \ in backticks are substituted for their corresponding opcode bytes.\n      *\
    \ Patterns are compiled in VERBOSE mode by default so that whitespace and comments\
    \ may be used.\n\n    This aims to mirror the output of :func:`dis.dis`, which\
    \ is far more readable than looking at raw byte strings.\n    \"\"\"\n    assert\
    \ isinstance(pattern, bytes)\n\n    # Replace anything wrapped in backticks with\
    \ regex-escaped opcodes.\n    pattern = re.sub(\n        rb\"`(\\w+)`\",\n   \
    \     lambda m: _instruction_to_regex(m[1].decode()),\n        pattern,\n    )\n\
    \    return re.compile(pattern, flags=flags)\n\n\ndef finditer(pattern: Pattern,\
    \ string: bytes):\n    \"\"\"\n    Call ``pattern.finditer(string)``, but remove\
    \ any matches beginning on an odd byte (i.e., matches where\n    match.start()\
    \ is not a multiple of 2).\n\n    This should be used to avoid false positive\
    \ matches where a bytecode pair's argument is mistaken for an opcode.\n    \"\"\
    \"\n    assert isinstance(string, bytes)\n    string = _cleanup_bytecode_string(string)\n\
    \    matches = pattern.finditer(string)\n    while True:\n        for match in\
    \ matches:\n            if match.start() % 2 == 0:\n                # All is good.\
    \ This match starts on an OPCODE.\n                yield match\n            else:\n\
    \                # This match has started on an odd byte, meaning that it is a\
    \ false positive and should be skipped.\n                # There is a very slim\
    \ chance that a genuine match overlaps this one and, because re.finditer() does\
    \ not\n                # allow overlapping matches, it would be lost. To avoid\
    \ that, restart the regex scan, starting at the\n                # next even byte.\n\
    \                matches = pattern.finditer(string, match.start() + 1)\n     \
    \           break\n        else:\n            break\n\n\n# Opcodes involved in\
    \ function calls with constant arguments. The differences between python versions\
    \ are handled by\n# variables below, which are then used to construct the _call_function_bytecode\
    \ regex.\n# NOTE1: the _OPCODES_* entries are typically used in (non-capturing)\
    \ groups that match the opcode plus an arbitrary\n# argument. But because the\
    \ entries themselves may contain more than on opcode (with OR operator between\
    \ them), they\n# themselves need to be enclosed in another (non-capturing) group.\
    \ E.g., \"(?:(?:_OPCODES_FUNCTION_GLOBAL).)\".\n# NOTE2: _OPCODES_EXTENDED_ARG2\
    \ is an exception, as it is used as a list of opcodes to exclude, i.e.,\n# \"\
    [^_OPCODES_EXTENDED_ARG2]\". Therefore, multiple opcodes are not separated by\
    \ the OR operator.\nif not compat.is_py311:\n    # Python 3.7 introduced two new\
    \ function-related opcodes, LOAD_METHOD and CALL_METHOD\n    _OPCODES_EXTENDED_ARG\
    \ = rb\"`EXTENDED_ARG`\"\n    _OPCODES_EXTENDED_ARG2 = _OPCODES_EXTENDED_ARG\n\
    \    _OPCODES_FUNCTION_GLOBAL = rb\"`LOAD_NAME`|`LOAD_GLOBAL`|`LOAD_FAST`\"\n\
    \    _OPCODES_FUNCTION_LOAD = rb\"`LOAD_ATTR`|`LOAD_METHOD`\"\n    _OPCODES_FUNCTION_ARGS\
    \ = rb\"`LOAD_CONST`\"\n    _OPCODES_FUNCTION_CALL = rb\"`CALL_FUNCTION`|`CALL_METHOD`|`CALL_FUNCTION_EX`\"\
    \n\n    def _cleanup_bytecode_string(bytecode):\n        return bytecode  # Nothing\
    \ to do here\nelif not compat.is_py312:\n    # Python 3.11 removed CALL_FUNCTION\
    \ and CALL_METHOD, and replaced them with PRECALL + CALL instruction sequence.\n\
    \    # As both PRECALL and CALL have the same parameter (the argument count),\
    \ we need to match only up to the PRECALL.\n    # The CALL_FUNCTION_EX is still\
    \ present.\n    # From Python 3.11b1 on, there is an EXTENDED_ARG_QUICK specialization\
    \ opcode present.\n    _OPCODES_EXTENDED_ARG = rb\"`EXTENDED_ARG`|`EXTENDED_ARG_QUICK`\"\
    \n    _OPCODES_EXTENDED_ARG2 = rb\"`EXTENDED_ARG``EXTENDED_ARG_QUICK`\"  # Special\
    \ case; see note above the if/else block!\n    _OPCODES_FUNCTION_GLOBAL = rb\"\
    `LOAD_NAME`|`LOAD_GLOBAL`|`LOAD_FAST`\"\n    _OPCODES_FUNCTION_LOAD = rb\"`LOAD_ATTR`|`LOAD_METHOD`\"\
    \n    _OPCODES_FUNCTION_ARGS = rb\"`LOAD_CONST`\"\n    _OPCODES_FUNCTION_CALL\
    \ = rb\"`PRECALL`|`CALL_FUNCTION_EX`\"\n\n    # Starting with python 3.11, the\
    \ bytecode is peppered with CACHE instructions (which dis module conveniently\
    \ hides\n    # unless show_caches=True is used). Dealing with these CACHE instructions\
    \ in regex rules is going to render them\n    # unreadable, so instead we pre-process\
    \ the bytecode and filter the offending opcodes out.\n    _cache_instruction_filter\
    \ = bytecode_regex(rb\"(`CACHE`.)|(..)\")\n\n    def _cleanup_bytecode_string(bytecode):\n\
    \        return _cache_instruction_filter.sub(rb\"\\2\", bytecode)\nelse:\n  \
    \  # Python 3.12 merged EXTENDED_ARG_QUICK back in to EXTENDED_ARG, and LOAD_METHOD\
    \ in to LOAD_ATTR\n    # PRECALL is no longer a valid key\n    _OPCODES_EXTENDED_ARG\
    \ = rb\"`EXTENDED_ARG`\"\n    _OPCODES_EXTENDED_ARG2 = _OPCODES_EXTENDED_ARG\n\
    \    _OPCODES_FUNCTION_GLOBAL = rb\"`LOAD_NAME`|`LOAD_GLOBAL`|`LOAD_FAST`\"\n\
    \    _OPCODES_FUNCTION_LOAD = rb\"`LOAD_ATTR`\"\n    _OPCODES_FUNCTION_ARGS =\
    \ rb\"`LOAD_CONST`\"\n    _OPCODES_FUNCTION_CALL = rb\"`CALL`|`CALL_FUNCTION_EX`\"\
    \n\n    # In Python 3.13, PUSH_NULL opcode is emitted after the LOAD_NAME (and\
    \ after LOAD_ATTR opcode(s), if applicable).\n    # In python 3.11 and 3.12, it\
    \ was emitted before the LOAD_NAME, and thus fell outside of our regex matching;\
    \ now,\n    # we have to deal with it. But, instead of trying to add it to matching\
    \ rules and adjusting the post-processing\n    # to deal with it, we opt to filter\
    \ them out (at the same time as we filter out CACHE opcodes), and leave the rest\n\
    \    # of processing untouched.\n    if compat.is_py313:\n        _cache_instruction_filter\
    \ = bytecode_regex(rb\"(`CACHE`.)|(`PUSH_NULL`.)|(..)\")\n\n        def _cleanup_bytecode_string(bytecode):\n\
    \            return _cache_instruction_filter.sub(rb\"\\3\", bytecode)\n    else:\n\
    \        _cache_instruction_filter = bytecode_regex(rb\"(`CACHE`.)|(..)\")\n\n\
    \        def _cleanup_bytecode_string(bytecode):\n            return _cache_instruction_filter.sub(rb\"\
    \\2\", bytecode)\n\n\n# language=PythonVerboseRegExp\n_call_function_bytecode\
    \ = bytecode_regex(\n    rb\"\"\"\n    # Matches `global_function('some', 'constant',\
    \ 'arguments')`.\n\n    # Load the global function. In code with >256 of names,\
    \ this may require extended name references.\n    (\n     (?:(?:\"\"\" + _OPCODES_EXTENDED_ARG\
    \ + rb\"\"\").)*\n     (?:(?:\"\"\" + _OPCODES_FUNCTION_GLOBAL + rb\"\"\").)\n\
    \    )\n\n    # For foo.bar.whizz(), the above is the 'foo', below is the 'bar.whizz'\
    \ (one opcode per name component, each\n    # possibly preceded by name reference\
    \ extension).\n    (\n     (?:\n       (?:(?:\"\"\" + _OPCODES_EXTENDED_ARG +\
    \ rb\"\"\").)*\n       (?:\"\"\" + _OPCODES_FUNCTION_LOAD + rb\"\"\").\n     )*\n\
    \    )\n\n    # Load however many arguments it takes. These (for now) must all\
    \ be constants.\n    # Again, code with >256 constants may need extended enumeration.\n\
    \    (\n      (?:\n        (?:(?:\"\"\" + _OPCODES_EXTENDED_ARG + rb\"\"\").)*\n\
    \        (?:\"\"\" + _OPCODES_FUNCTION_ARGS + rb\"\"\").\n      )*\n    )\n\n\
    \    # Call the function. If opcode is CALL_FUNCTION_EX, the parameter are flags.\
    \ For other opcodes, the parameter\n    # is the argument count (which may be\
    \ > 256).\n    (\n      (?:(?:\"\"\" + _OPCODES_EXTENDED_ARG + rb\"\"\").)*\n\
    \      (?:\"\"\" + _OPCODES_FUNCTION_CALL + rb\"\"\").\n    )\n\"\"\"\n)\n\n#\
    \ language=PythonVerboseRegExp\n_extended_arg_bytecode = bytecode_regex(\n   \
    \ rb\"\"\"(\n    # Arbitrary number of EXTENDED_ARG pairs.\n    (?:(?:\"\"\" +\
    \ _OPCODES_EXTENDED_ARG + rb\"\"\").)*\n\n    # Followed by some other instruction\
    \ (usually a LOAD).\n    [^\"\"\" + _OPCODES_EXTENDED_ARG2 + rb\"\"\"].\n)\"\"\
    \"\n)\n\n\ndef extended_arguments(extended_args: bytes):\n    \"\"\"\n    Unpack\
    \ the (extended) integer used to reference names or constants.\n\n    The input\
    \ should be a bytecode snippet of the following form::\n\n        EXTENDED_ARG\
    \    ?      # Repeated 0-4 times.\n        LOAD_xxx        ?      # Any of LOAD_NAME/LOAD_CONST/LOAD_METHOD/...\n\
    \n    Each ? byte combined together gives the number we want.\n    \"\"\"\n  \
    \  return int.from_bytes(extended_args[1::2], \"big\")\n\n\ndef load(raw: bytes,\
    \ code: CodeType) -> str:\n    \"\"\"\n    Parse an (extended) LOAD_xxx instruction.\n\
    \    \"\"\"\n    # Get the enumeration.\n    index = extended_arguments(raw)\n\
    \n    # Work out what that enumeration was for (constant/local var/global var).\n\
    \n    # If the last instruction byte is a LOAD_FAST:\n    if raw[-2] == opmap[\"\
    LOAD_FAST\"]:\n        # Then this is a local variable.\n        return code.co_varnames[index]\n\
    \    # Or if it is a LOAD_CONST:\n    if raw[-2] == opmap[\"LOAD_CONST\"]:\n \
    \       # Then this is a literal.\n        return code.co_consts[index]\n    #\
    \ Otherwise, it is a global name.\n    if compat.is_py311 and raw[-2] == opmap[\"\
    LOAD_GLOBAL\"]:\n        # In python 3.11, namei>>1 is pushed on stack...\n  \
    \      return code.co_names[index >> 1]\n    if compat.is_py312 and raw[-2] ==\
    \ opmap[\"LOAD_ATTR\"]:\n        # In python 3.12, namei>>1 is pushed on stack...\n\
    \        return code.co_names[index >> 1]\n\n    return code.co_names[index]\n\
    \n\ndef loads(raw: bytes, code: CodeType) -> list:\n    \"\"\"\n    Parse multiple\
    \ consecutive LOAD_xxx instructions. Or load() in a for loop.\n\n    May be used\
    \ to unpack a function's parameters or nested attributes ``(foo.bar.pop.whack)``.\n\
    \    \"\"\"\n    return [load(i, code) for i in _extended_arg_bytecode.findall(raw)]\n\
    \n\ndef function_calls(code: CodeType) -> list:\n    \"\"\"\n    Scan a code object\
    \ for all function calls on constant arguments.\n    \"\"\"\n    match: re.Match\n\
    \    out = []\n\n    for match in finditer(_call_function_bytecode, code.co_code):\n\
    \        function_root, methods, args, function_call = match.groups()\n\n    \
    \    # For foo():\n        #   `function_root` contains 'foo' and `methods` is\
    \ empty.\n        # For foo.bar.whizz():\n        #   `function_root` contains\
    \ 'foo' and `methods` contains the rest.\n        function_root = load(function_root,\
    \ code)\n        methods = loads(methods, code)\n        function = \".\".join([function_root]\
    \ + methods)\n\n        args = loads(args, code)\n        if function_call[0]\
    \ == opmap['CALL_FUNCTION_EX']:\n            flags = extended_arguments(function_call)\n\
    \            if flags != 0:\n                # Keyword arguments present. Unhandled\
    \ at the moment.\n                continue\n            # In calls with const\
    \ arguments, args contains a single\n            # tuple with all values.\n  \
    \          if len(args) != 1 or not isinstance(args[0], tuple):\n            \
    \    continue\n            args = list(args[0])\n        else:\n            arg_count\
    \ = extended_arguments(function_call)\n\n            if arg_count != len(args):\n\
    \                # This happens if there are variable or keyword arguments. Bail\
    \ out in either case.\n                continue\n\n        out.append((function,\
    \ args))\n\n    return out\n\n\ndef search_recursively(search: callable, code:\
    \ CodeType, _memo=None) -> dict:\n    \"\"\"\n    Apply a search function to a\
    \ code object, recursing into child code objects (function definitions).\n   \
    \ \"\"\"\n    if _memo is None:\n        _memo = {}\n    if code not in _memo:\n\
    \        _memo[code] = search(code)\n        for const in code.co_consts:\n  \
    \          if isinstance(const, CodeType):\n                search_recursively(search,\
    \ const, _memo)\n    return _memo\n\n\ndef recursive_function_calls(code: CodeType)\
    \ -> dict:\n    \"\"\"\n    Scan a code object for function calls on constant\
    \ arguments, recursing into function definitions and bodies of\n    comprehension\
    \ loops.\n    \"\"\"\n    return search_recursively(function_calls, code)\n\n\n\
    def any_alias(full_name: str):\n    \"\"\"List possible aliases of a fully qualified\
    \ Python name.\n\n        >>> list(any_alias(\"foo.bar.wizz\"))\n        ['foo.bar.wizz',\
    \ 'bar.wizz', 'wizz']\n\n    This crudely allows us to capture uses of wizz()\
    \ under any of\n    ::\n        import foo\n        foo.bar.wizz()\n    ::\n \
    \       from foo import bar\n        bar.wizz()\n    ::\n        from foo.bar\
    \ import wizz\n        wizz()\n\n    However, it will fail for any form of aliases\
    \ and quite likely find false matches.\n    \"\"\"\n    parts = full_name.split('.')\n\
    \    while parts:\n        yield \".\".join(parts)\n        parts = parts[1:]\n\
    \n### Source File Dependency Files Content\n### Dependency File: compat.py\n#\
    \ ----------------------------------------------------------------------------\n\
    # Copyright (c) 2005-2023, PyInstaller Development Team.\n#\n# Distributed under\
    \ the terms of the GNU General Public License (version 2\n# or later) with exception\
    \ for distributing the bootloader.\n#\n# The full license is in the file COPYING.txt,\
    \ distributed with this software.\n#\n# SPDX-License-Identifier: (GPL-2.0-or-later\
    \ WITH Bootloader-exception)\n# ----------------------------------------------------------------------------\n\
    \"\"\"\nVarious classes and functions to provide some backwards-compatibility\
    \ with previous versions of Python onward.\n\"\"\"\nfrom __future__ import annotations\n\
    \nimport errno\n\nimport importlib.machinery\nimport importlib.util\nimport os\n\
    import platform\nimport site\nimport subprocess\nimport sys\nimport sysconfig\n\
    import shutil\nimport types\n\nfrom PyInstaller._shared_with_waf import _pyi_machine\n\
    from PyInstaller.exceptions import ExecCommandFailed\n\n# setup.py sets this environment\
    \ variable to avoid errors due to unmet run-time dependencies. The PyInstaller.compat\n\
    # module is imported by setup.py to build wheels, and some dependencies that are\
    \ otherwise required at run-time\n# (importlib-metadata on python < 3.10, pywin32-ctypes\
    \ on Windows) might not be present while building wheels,\n# nor are they required\
    \ during that phase.\n_setup_py_mode = os.environ.get('_PYINSTALLER_SETUP_PY',\
    \ '0') != '0'\n\n# PyInstaller requires importlib.metadata from python >= 3.10\
    \ stdlib, or equivalent importlib-metadata >= 4.6.\nif _setup_py_mode:\n    importlib_metadata\
    \ = None\nelse:\n    if sys.version_info >= (3, 10):\n        import importlib.metadata\
    \ as importlib_metadata\n    else:\n        try:\n            import importlib_metadata\n\
    \        except ImportError as e:\n            from PyInstaller.exceptions import\
    \ ImportlibMetadataError\n            raise ImportlibMetadataError() from e\n\n\
    \        import packaging.version  # For importlib_metadata version check\n\n\
    \        # Validate the version\n        if packaging.version.parse(importlib_metadata.version(\"\
    importlib-metadata\")) < packaging.version.parse(\"4.6\"):\n            from PyInstaller.exceptions\
    \ import ImportlibMetadataError\n            raise ImportlibMetadataError()\n\n\
    # Strict collect mode, which raises error when trying to collect duplicate files\
    \ into PKG/CArchive or COLLECT.\nstrict_collect_mode = os.environ.get(\"PYINSTALLER_STRICT_COLLECT_MODE\"\
    , \"0\") != \"0\"\n\n# Copied from https://docs.python.org/3/library/platform.html#cross-platform.\n\
    is_64bits: bool = sys.maxsize > 2**32\n\n# Distinguish specific code for various\
    \ Python versions. Variables 'is_pyXY' mean that Python X.Y and up is supported.\n\
    # Keep even unsupported versions here to keep 3rd-party hooks working.\nis_py35\
    \ = sys.version_info >= (3, 5)\nis_py36 = sys.version_info >= (3, 6)\nis_py37\
    \ = sys.version_info >= (3, 7)\nis_py38 = sys.version_info >= (3, 8)\nis_py39\
    \ = sys.version_info >= (3, 9)\nis_py310 = sys.version_info >= (3, 10)\nis_py311\
    \ = sys.version_info >= (3, 11)\nis_py312 = sys.version_info >= (3, 12)\nis_py313\
    \ = sys.version_info >= (3, 13)\n\nis_win = sys.platform.startswith('win')\nis_win_10\
    \ = is_win and (platform.win32_ver()[0] == '10')\nis_win_11 = is_win and (platform.win32_ver()[0]\
    \ == '11')\nis_win_wine = False  # Running under Wine; determined later on.\n\
    is_cygwin = sys.platform == 'cygwin'\nis_darwin = sys.platform == 'darwin'  #\
    \ macOS\n\n# Unix platforms\nis_linux = sys.platform.startswith('linux')\nis_solar\
    \ = sys.platform.startswith('sun')  # Solaris\nis_aix = sys.platform.startswith('aix')\n\
    is_freebsd = sys.platform.startswith('freebsd')\nis_openbsd = sys.platform.startswith('openbsd')\n\
    is_hpux = sys.platform.startswith('hp-ux')\n\n# Some code parts are similar to\
    \ several unix platforms (e.g. Linux, Solaris, AIX).\n# macOS is not considered\
    \ as unix since there are many platform-specific details for Mac in PyInstaller.\n\
    is_unix = is_linux or is_solar or is_aix or is_freebsd or is_hpux or is_openbsd\n\
    \n# Linux distributions such as Alpine or OpenWRT use musl as their libc implementation\
    \ and resultantly need specially\n# compiled bootloaders. On musl systems, ldd\
    \ with no arguments prints 'musl' and its version.\nis_musl = is_linux and \"\
    musl\" in subprocess.run([\"ldd\"], capture_output=True, encoding=\"utf-8\").stderr\n\
    \n# macOS version\n_macos_ver = tuple(int(x) for x in platform.mac_ver()[0].split('.'))\
    \ if is_darwin else None\n\n# macOS 11 (Big Sur): if python is not compiled with\
    \ Big Sur support, it ends up in compatibility mode by default, which\n# is indicated\
    \ by platform.mac_ver() returning '10.16'. The lack of proper Big Sur support\
    \ breaks find_library()\n# function from ctypes.util module, as starting with\
    \ Big Sur, shared libraries are not visible on disk anymore. Support\n# for the\
    \ new library search mechanism was added in python 3.9 when compiled with Big\
    \ Sur support. In such cases,\n# platform.mac_ver() reports version as '11.x'.\
    \ The behavior can be further modified via SYSTEM_VERSION_COMPAT\n# environment\
    \ variable; which allows explicitly enabling or disabling the compatibility mode.\
    \ However, note that\n# disabling the compatibility mode and using python that\
    \ does not properly support Big Sur still leaves find_library()\n# broken (which\
    \ is a scenario that we ignore at the moment).\n# The same logic applies to macOS\
    \ 12 (Monterey).\nis_macos_11_compat = bool(_macos_ver) and _macos_ver[0:2] ==\
    \ (10, 16)  # Big Sur or newer in compat mode\nis_macos_11_native = bool(_macos_ver)\
    \ and _macos_ver[0:2] >= (11, 0)  # Big Sur or newer in native mode\nis_macos_11\
    \ = is_macos_11_compat or is_macos_11_native  # Big Sur or newer\n\n# Check if\
    \ python >= 3.13 was built with Py_GIL_DISABLED / free-threading (PEP703).\n#\n\
    # This affects the shared library name, which has the \"t\" ABI suffix, as per:\n\
    # https://github.com/python/steering-council/issues/221#issuecomment-1841593283\n\
    #\n# It also affects the layout of PyConfig structure used by bootloader; consequently\n\
    #  a) we need to inform bootloader what kind of build it is dealing with\n#  b)\
    \ we must not mix up shared libraries, in case multiple builds are present on\
    \ the system. Thus, strictly enforce the\n#     \"t\" ABI suffix in the PYDYLIB_NAMES,\
    \ if applicable.\nis_nogil = bool(sysconfig.get_config_var('Py_GIL_DISABLED'))\n\
    \n_py_suffix = \"t\" if is_nogil else \"\"\n\n# On different platforms is different\
    \ file for dynamic python library.\n_py_major, _py_minor = sys.version_info[:2]\n\
    if is_win or is_cygwin:\n    PYDYLIB_NAMES = {\n        f'python{_py_major}{_py_minor}{_py_suffix}.dll',\n\
    \        f'libpython{_py_major}{_py_minor}{_py_suffix}.dll',\n        f'libpython{_py_major}.{_py_minor}{_py_suffix}.dll',\n\
    \    }  # For MSYS2 environment\nelif is_darwin:\n    # The suffix in .framework\
    \ library name is capitalized, e.g., PythonT for freethreading-enabled build.\n\
    \    # The `libpython%d.%d%s.dylib` is there primarily for Anaconda installations,\
    \ but it also serves as a fallback in\n    # .framework builds, where `/Library/Frameworks/Python.framework/Versions/3.X/lib/libpython3.13.dylib`\
    \ is a symbolic\n    # link that points to `../Python`.\n    PYDYLIB_NAMES = {\n\
    \        f'Python{_py_suffix.upper()}',\n        f'.Python{_py_suffix.upper()}',\n\
    \        f'Python{_py_major}{_py_suffix.upper()}',\n        f'libpython{_py_major}.{_py_minor}{_py_suffix}.dylib',\n\
    \    }\nelif is_aix:\n    # Shared libs on AIX may be archives with shared object\
    \ members, hence the \".a\" suffix. However, starting with\n    # python 2.7.11\
    \ libpython?.?.so and Python3 libpython?.?m.so files are produced.\n    PYDYLIB_NAMES\
    \ = {\n        f'libpython{_py_major}.{_py_minor}{_py_suffix}.a',\n        f'libpython{_py_major}.{_py_minor}{_py_suffix}.so',\n\
    \    }\nelif is_freebsd:\n    PYDYLIB_NAMES = {\n        f'libpython{_py_major}.{_py_minor}{_py_suffix}.so.1',\n\
    \        f'libpython{_py_major}.{_py_minor}{_py_suffix}.so.1.0',\n    }\nelif\
    \ is_openbsd:\n    PYDYLIB_NAMES = {\n        f'libpython{_py_major}.{_py_minor}{_py_suffix}.so.0.0',\n\
    \    }\nelif is_hpux:\n    PYDYLIB_NAMES = {\n        f'libpython{_py_major}.{_py_minor}{_py_suffix}.so',\n\
    \    }\nelif is_unix:\n    # Other *nix platforms.\n    # Python 2 .so library\
    \ on Linux is: libpython2.7.so.1.0\n    # Python 3 .so library on Linux is: libpython3.3.so.1.0\n\
    \    PYDYLIB_NAMES = {\n        f'libpython{_py_major}.{_py_minor}{_py_suffix}.so.1.0',\n\
    \        f'libpython{_py_major}.{_py_minor}{_py_suffix}.so',\n    }\nelse:\n \
    \   raise SystemExit('Your platform is not yet supported. Please define constant\
    \ PYDYLIB_NAMES for your platform.')\n\ndel _py_major, _py_minor, _py_suffix\n\
    \n# In a virtual environment created by virtualenv (github.com/pypa/virtualenv)\
    \ there exists sys.real_prefix with the path\n# to the base Python installation\
    \ from which the virtual environment was created. This is true regardless of the\
    \ version\n# of Python used to execute the virtualenv command.\n#\n# In a virtual\
    \ environment created by the venv module available in the Python standard lib,\
    \ there exists sys.base_prefix\n# with the path to the base implementation. This\
    \ does not exist in a virtual environment created by virtualenv.\n#\n# The following\
    \ code creates compat.is_venv and is.virtualenv that are True when running a virtual\
    \ environment, and also\n# compat.base_prefix with the path to the base Python\
    \ installation.\n\nbase_prefix: str = os.path.abspath(getattr(sys, 'real_prefix',\
    \ getattr(sys, 'base_prefix', sys.prefix)))\n# Ensure `base_prefix` is not containing\
    \ any relative parts.\nis_venv = is_virtualenv = base_prefix != os.path.abspath(sys.prefix)\n\
    \n# Conda environments sometimes have different paths or apply patches to packages\
    \ that can affect how a hook or package\n# should access resources. Method for\
    \ determining conda taken from https://stackoverflow.com/questions/47610844#47610844\n\
    is_conda = os.path.isdir(os.path.join(base_prefix, 'conda-meta'))\n\n# Similar\
    \ to ``is_conda`` but is ``False`` using another ``venv``-like manager on top.\
    \ In this case, no packages\n# encountered will be conda packages meaning that\
    \ the default non-conda behaviour is generally desired from PyInstaller.\nis_pure_conda\
    \ = os.path.isdir(os.path.join(sys.prefix, 'conda-meta'))\n\n# Full path to python\
    \ interpreter.\npython_executable = getattr(sys, '_base_executable', sys.executable)\n\
    \n# Is this Python from Microsoft App Store (Windows only)? Python from Microsoft\
    \ App Store has executable pointing at\n# empty shims.\nis_ms_app_store = is_win\
    \ and os.path.getsize(python_executable) == 0\n\nif is_ms_app_store:\n    # Locate\
    \ the actual executable inside base_prefix.\n    python_executable = os.path.join(base_prefix,\
    \ os.path.basename(python_executable))\n    if not os.path.exists(python_executable):\n\
    \        raise SystemExit(\n            'PyInstaller cannot locate real python\
    \ executable belonging to Python from Microsoft App Store!'\n        )\n\n# Bytecode\
    \ magic value\nBYTECODE_MAGIC = importlib.util.MAGIC_NUMBER\n\n# List of suffixes\
    \ for Python C extension modules.\nEXTENSION_SUFFIXES = importlib.machinery.EXTENSION_SUFFIXES\n\
    ALL_SUFFIXES = importlib.machinery.all_suffixes()\n\n# On Windows we require pywin32-ctypes.\n\
    # -> all pyinstaller modules should use win32api from PyInstaller.compat to\n\
    #    ensure that it can work on MSYS2 (which requires pywin32-ctypes)\nif is_win:\n\
    \    if _setup_py_mode:\n        pywintypes = None\n        win32api = None\n\
    \    else:\n        try:\n            # Hide the `cffi` package from win32-ctypes\
    \ by temporarily blocking its import. This ensures that `ctypes`\n           \
    \ # backend is always used, even if `cffi` is available. The `cffi` backend uses\
    \ `pycparser`, which is\n            # incompatible with -OO mode (2nd optimization\
    \ level) due to its removal of docstrings.\n            # See https://github.com/pyinstaller/pyinstaller/issues/6345\n\
    \            # On the off chance that `cffi` has already been imported, store\
    \ the `sys.modules` entry so we can restore\n            # it after importing\
    \ `pywin32-ctypes` modules.\n            orig_cffi = sys.modules.get('cffi')\n\
    \            sys.modules['cffi'] = None\n\n            from win32ctypes.pywin32\
    \ import pywintypes  # noqa: F401, E402\n            from win32ctypes.pywin32\
    \ import win32api  # noqa: F401, E402\n        except ImportError as e:\n    \
    \        raise SystemExit(\n                'Could not import `pywintypes` or\
    \ `win32api` from `win32ctypes.pywin32`.\\n'\n                'Please make sure\
    \ that `pywin32-ctypes` is installed and importable, for example:\\n\\n'\n   \
    \             'pip install pywin32-ctypes\\n'\n            ) from e\n        finally:\n\
    \            # Unblock `cffi`.\n            if orig_cffi is not None:\n      \
    \          sys.modules['cffi'] = orig_cffi\n            else:\n              \
    \  del sys.modules['cffi']\n            del orig_cffi\n\n# macOS's platform.architecture()\
    \ can be buggy, so we do this manually here. Based off the python documentation:\n\
    # https://docs.python.org/3/library/platform.html#platform.architecture\nif is_darwin:\n\
    \    architecture = '64bit' if sys.maxsize > 2**32 else '32bit'\nelse:\n    architecture\
    \ = platform.architecture()[0]\n\n# Cygwin needs special handling, because platform.system()\
    \ contains identifiers such as MSYS_NT-10.0-19042 and\n# CYGWIN_NT-10.0-19042\
    \ that do not fit PyInstaller's OS naming scheme. Explicitly set `system` to 'Cygwin'.\n\
    system = 'Cygwin' if is_cygwin else platform.system()\n\n# Machine suffix for\
    \ bootloader.\nif is_win:\n    # On Windows ARM64 using an x64 Python environment,\
    \ platform.machine() returns ARM64 but\n    # we really want the bootloader that\
    \ matches the Python environment instead of the OS.\n    machine = _pyi_machine(os.environ.get(\"\
    PROCESSOR_ARCHITECTURE\", platform.machine()), platform.system())\nelse:\n   \
    \ machine = _pyi_machine(platform.machine(), platform.system())\n\n\n# Wine detection\
    \ and support\ndef is_wine_dll(filename: str | os.PathLike):\n    \"\"\"\n   \
    \ Check if the given PE file is a Wine DLL (PE-converted built-in, or fake/placeholder\
    \ one).\n\n    Returns True if the given file is a Wine DLL, False if not (or\
    \ if file cannot be analyzed or does not exist).\n    \"\"\"\n    _WINE_SIGNATURES\
    \ = (\n        b'Wine builtin DLL',  # PE-converted Wine DLL\n        b'Wine placeholder\
    \ DLL',  # Fake/placeholder Wine DLL\n    )\n    _MAX_LEN = max([len(sig) for\
    \ sig in _WINE_SIGNATURES])\n\n    # Wine places their DLL signature in the padding\
    \ area between the IMAGE_DOS_HEADER and IMAGE_NT_HEADERS. So we need\n    # to\
    \ compare the bytes that come right after IMAGE_DOS_HEADER, i.e., after initial\
    \ 64 bytes. We can read the file\n    # directly and avoid using the pefile library\
    \ to avoid performance penalty associated with full header parsing.\n    try:\n\
    \        with open(filename, 'rb') as fp:\n            fp.seek(64)\n         \
    \   signature = fp.read(_MAX_LEN)\n        return signature.startswith(_WINE_SIGNATURES)\n\
    \    except Exception:\n        pass\n    return False\n\n\nif is_win:\n    try:\n\
    \        import ctypes.util  # noqa: E402\n        is_win_wine = is_wine_dll(ctypes.util.find_library('kernel32'))\n\
    \    except Exception:\n        pass\n\n# Set and get environment variables does\
    \ not handle unicode strings correctly on Windows.\n\n# Acting on os.environ instead\
    \ of using getenv()/setenv()/unsetenv(), as suggested in\n# <http://docs.python.org/library/os.html#os.environ>:\
    \ \"Calling putenv() directly does not change os.environ, so it is\n# better to\
    \ modify os.environ.\" (Same for unsetenv.)\n\n\ndef getenv(name: str, default:\
    \ str | None = None):\n    \"\"\"\n    Returns unicode string containing value\
    \ of environment variable 'name'.\n    \"\"\"\n    return os.environ.get(name,\
    \ default)\n\n\ndef setenv(name: str, value: str):\n    \"\"\"\n    Accepts unicode\
    \ string and set it as environment variable 'name' containing value 'value'.\n\
    \    \"\"\"\n    os.environ[name] = value\n\n\ndef unsetenv(name: str):\n    \"\
    \"\"\n    Delete the environment variable 'name'.\n    \"\"\"\n    # Some platforms\
    \ (e.g., AIX) do not support `os.unsetenv()` and thus `del os.environ[name]` has\
    \ no effect on the\n    # real environment. For this case, we set the value to\
    \ the empty string.\n    os.environ[name] = \"\"\n    del os.environ[name]\n\n\
    \n# Exec commands in subprocesses.\n\n\ndef exec_command(\n    *cmdargs: str,\
    \ encoding: str | None = None, raise_enoent: bool | None = None, **kwargs: int\
    \ | bool | list | None\n):\n    \"\"\"\n    Run the command specified by the passed\
    \ positional arguments, optionally configured by the passed keyword arguments.\n\
    \n    .. DANGER::\n       **Ignore this function's return value** -- unless this\
    \ command's standard output contains _only_ pathnames, in\n       which case this\
    \ function returns the correct filesystem-encoded string expected by PyInstaller.\
    \ In all other\n       cases, this function's return value is _not_ safely usable.\n\
    \n       For backward compatibility, this function's return value non-portably\
    \ depends on the current Python version and\n       passed keyword arguments:\n\
    \n       * Under Python 3.x, this value is a **decoded `str` string**. However,\
    \ even this value is _not_ necessarily\n         safely usable:\n         * If\
    \ the `encoding` parameter is passed, this value is guaranteed to be safely usable.\n\
    \         * Else, this value _cannot_ be safely used for any purpose (e.g., string\
    \ manipulation or parsing), except to be\n           passed directly to another\
    \ non-Python command. Why? Because this value has been decoded with the encoding\n\
    \           specified by `sys.getfilesystemencoding()`, the encoding used by `os.fsencode()`\
    \ and `os.fsdecode()` to\n           convert from platform-agnostic to platform-specific\
    \ pathnames. This is _not_ necessarily the encoding with\n           which this\
    \ command's standard output was encoded. Cue edge-case decoding exceptions.\n\n\
    \    Parameters\n    ----------\n    cmdargs :\n        Variadic list whose:\n\
    \        1. Mandatory first element is the absolute path, relative path, or basename\
    \ in the current `${PATH}` of the\n           command to run.\n        2. Optional\
    \ remaining elements are arguments to pass to this command.\n    encoding : str,\
    \ optional\n        Optional keyword argument specifying the encoding with which\
    \ to decode this command's standard output under\n        Python 3. As this function's\
    \ return value should be ignored, this argument should _never_ be passed.\n  \
    \  raise_enoent : boolean, optional\n        Optional keyword argument to simply\
    \ raise the exception if the executing the command fails since to the command\n\
    \        is not found. This is useful to checking id a command exists.\n\n   \
    \ All remaining keyword arguments are passed as is to the `subprocess.Popen()`\
    \ constructor.\n\n    Returns\n    ----------\n    str\n        Ignore this value.\
    \ See discussion above.\n    \"\"\"\n\n    proc = subprocess.Popen(cmdargs, stdout=subprocess.PIPE,\
    \ **kwargs)\n    try:\n        out = proc.communicate(timeout=60)[0]\n    except\
    \ OSError as e:\n        if raise_enoent and e.errno == errno.ENOENT:\n      \
    \      raise\n        print('--' * 20, file=sys.stderr)\n        print(\"Error\
    \ running '%s':\" % \" \".join(cmdargs), file=sys.stderr)\n        print(e, file=sys.stderr)\n\
    \        print('--' * 20, file=sys.stderr)\n        raise ExecCommandFailed(\"\
    Error: Executing command failed!\") from e\n    except subprocess.TimeoutExpired:\n\
    \        proc.kill()\n        raise\n\n    # stdout/stderr are returned as a byte\
    \ array NOT as string, so we need to convert that to proper encoding.\n    try:\n\
    \        if encoding:\n            out = out.decode(encoding)\n        else:\n\
    \            # If no encoding is given, assume we are reading filenames from stdout\
    \ only because it is the common case.\n            out = os.fsdecode(out)\n  \
    \  except UnicodeDecodeError as e:\n        # The sub-process used a different\
    \ encoding; provide more information to ease debugging.\n        print('--' *\
    \ 20, file=sys.stderr)\n        print(str(e), file=sys.stderr)\n        print('These\
    \ are the bytes around the offending byte:', file=sys.stderr)\n        print('--'\
    \ * 20, file=sys.stderr)\n        raise\n    return out\n\n\ndef exec_command_rc(*cmdargs:\
    \ str, **kwargs: float | bool | list | None):\n    \"\"\"\n    Return the exit\
    \ code of the command specified by the passed positional arguments, optionally\
    \ configured by the\n    passed keyword arguments.\n\n    Parameters\n    ----------\n\
    \    cmdargs : list\n        Variadic list whose:\n        1. Mandatory first\
    \ element is the absolute path, relative path, or basename in the current `${PATH}`\
    \ of the\n           command to run.\n        2. Optional remaining elements are\
    \ arguments to pass to this command.\n\n    All keyword arguments are passed as\
    \ is to the `subprocess.call()` function.\n\n    Returns\n    ----------\n   \
    \ int\n        This command's exit code as an unsigned byte in the range `[0,\
    \ 255]`, where 0 signifies success and all other\n        values signal a failure.\n\
    \    \"\"\"\n\n    # 'encoding' keyword is not supported for 'subprocess.call';\
    \ remove it from kwargs.\n    if 'encoding' in kwargs:\n        kwargs.pop('encoding')\n\
    \    return subprocess.call(cmdargs, **kwargs)\n\n\ndef exec_command_all(*cmdargs:\
    \ str, encoding: str | None = None, **kwargs: int | bool | list | None):\n   \
    \ \"\"\"\n    Run the command specified by the passed positional arguments, optionally\
    \ configured by the passed keyword arguments.\n\n    .. DANGER::\n       **Ignore\
    \ this function's return value.** If this command's standard output consists solely\
    \ of pathnames, consider\n       calling `exec_command()`\n\n    Parameters\n\
    \    ----------\n    cmdargs : str\n        Variadic list whose:\n        1. Mandatory\
    \ first element is the absolute path, relative path, or basename in the current\
    \ `${PATH}` of the\n           command to run.\n        2. Optional remaining\
    \ elements are arguments to pass to this command.\n    encoding : str, optional\n\
    \        Optional keyword argument specifying the encoding with which to decode\
    \ this command's standard output. As this\n        function's return value should\
    \ be ignored, this argument should _never_ be passed.\n\n    All remaining keyword\
    \ arguments are passed as is to the `subprocess.Popen()` constructor.\n\n    Returns\n\
    \    ----------\n    (int, str, str)\n        Ignore this 3-element tuple `(exit_code,\
    \ stdout, stderr)`. See the `exec_command()` function for discussion.\n    \"\"\
    \"\n    proc = subprocess.Popen(\n        cmdargs,\n        bufsize=-1,  # Default\
    \ OS buffer size.\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n\
    \        **kwargs\n    )\n    # Waits for subprocess to complete.\n    try:\n\
    \        out, err = proc.communicate(timeout=60)\n    except subprocess.TimeoutExpired:\n\
    \        proc.kill()\n        raise\n    # stdout/stderr are returned as a byte\
    \ array NOT as string. Thus we need to convert that to proper encoding.\n    try:\n\
    \        if encoding:\n            out = out.decode(encoding)\n            err\
    \ = err.decode(encoding)\n        else:\n            # If no encoding is given,\
    \ assume we're reading filenames from stdout only because it's the common case.\n\
    \            out = os.fsdecode(out)\n            err = os.fsdecode(err)\n    except\
    \ UnicodeDecodeError as e:\n        # The sub-process used a different encoding,\
    \ provide more information to ease debugging.\n        print('--' * 20, file=sys.stderr)\n\
    \        print(str(e), file=sys.stderr)\n        print('These are the bytes around\
    \ the offending byte:', file=sys.stderr)\n        print('--' * 20, file=sys.stderr)\n\
    \        raise\n\n    return proc.returncode, out, err\n\n\ndef __wrap_python(args,\
    \ kwargs):\n    cmdargs = [sys.executable]\n\n    # macOS supports universal binaries\
    \ (binary for multiple architectures. We need to ensure that subprocess\n    #\
    \ binaries are running for the same architecture as python executable. It is necessary\
    \ to run binaries with 'arch'\n    # command.\n    if is_darwin:\n        if architecture\
    \ == '64bit':\n            if platform.machine() == 'arm64':\n               \
    \ py_prefix = ['arch', '-arm64']  # Apple M1\n            else:\n            \
    \    py_prefix = ['arch', '-x86_64']  # Intel\n        elif architecture == '32bit':\n\
    \            py_prefix = ['arch', '-i386']\n        else:\n            py_prefix\
    \ = []\n        # Since macOS 10.11, the environment variable DYLD_LIBRARY_PATH\
    \ is no more inherited by child processes, so we\n        # proactively propagate\
    \ the current value using the `-e` option of the `arch` command.\n        if 'DYLD_LIBRARY_PATH'\
    \ in os.environ:\n            path = os.environ['DYLD_LIBRARY_PATH']\n       \
    \     py_prefix += ['-e', 'DYLD_LIBRARY_PATH=%s' % path]\n        cmdargs = py_prefix\
    \ + cmdargs\n\n    if not __debug__:\n        cmdargs.append('-O')\n\n    cmdargs.extend(args)\n\
    \n    env = kwargs.get('env')\n    if env is None:\n        env = dict(**os.environ)\n\
    \n    # Ensure python 3 subprocess writes 'str' as utf-8\n    env['PYTHONIOENCODING']\
    \ = 'UTF-8'\n    # ... and ensure we read output as utf-8\n    kwargs['encoding']\
    \ = 'UTF-8'\n\n    return cmdargs, kwargs\n\n\ndef exec_python(*args: str, **kwargs:\
    \ str | None):\n    \"\"\"\n    Wrap running python script in a subprocess.\n\n\
    \    Return stdout of the invoked command.\n    \"\"\"\n    cmdargs, kwargs =\
    \ __wrap_python(args, kwargs)\n    return exec_command(*cmdargs, **kwargs)\n\n\
    \ndef exec_python_rc(*args: str, **kwargs: str | None):\n    \"\"\"\n    Wrap\
    \ running python script in a subprocess.\n\n    Return exit code of the invoked\
    \ command.\n    \"\"\"\n    cmdargs, kwargs = __wrap_python(args, kwargs)\n  \
    \  return exec_command_rc(*cmdargs, **kwargs)\n\n\n# Path handling.\n\n\n# Site-packages\
    \ functions - use native function if available.\ndef getsitepackages(prefixes:\
    \ list | None = None):\n    \"\"\"\n    Returns a list containing all global site-packages\
    \ directories.\n\n    For each directory present in ``prefixes`` (or the global\
    \ ``PREFIXES``), this function finds its `site-packages`\n    subdirectory depending\
    \ on the system environment, and returns a list of full paths.\n    \"\"\"\n \
    \   # This implementation was copied from the ``site`` module, python 3.7.3.\n\
    \    sitepackages = []\n    seen = set()\n\n    if prefixes is None:\n       \
    \ prefixes = [sys.prefix, sys.exec_prefix]\n\n    for prefix in prefixes:\n  \
    \      if not prefix or prefix in seen:\n            continue\n        seen.add(prefix)\n\
    \n        if os.sep == '/':\n            sitepackages.append(os.path.join(prefix,\
    \ \"lib\", \"python%d.%d\" % sys.version_info[:2], \"site-packages\"))\n     \
    \   else:\n            sitepackages.append(prefix)\n            sitepackages.append(os.path.join(prefix,\
    \ \"lib\", \"site-packages\"))\n    return sitepackages\n\n\n# Backported for\
    \ virtualenv. Module 'site' in virtualenv might not have this attribute.\ngetsitepackages\
    \ = getattr(site, 'getsitepackages', getsitepackages)\n\n\n# Wrapper to load a\
    \ module from a Python source file. This function loads import hooks when processing\
    \ them.\ndef importlib_load_source(name: str, pathname: str):\n    # Import module\
    \ from a file.\n    mod_loader = importlib.machinery.SourceFileLoader(name, pathname)\n\
    \    mod = types.ModuleType(mod_loader.name)\n    mod.__file__ = mod_loader.get_filename()\
    \  # Some hooks require __file__ attribute in their namespace\n    mod_loader.exec_module(mod)\n\
    \    return mod\n\n\n# Patterns of module names that should be bundled into the\
    \ base_library.zip to be available during bootstrap.\n# These modules include\
    \ direct or indirect dependencies of encodings.* modules. The encodings modules\
    \ must be\n# recursively included to set the I/O encoding during python startup.\
    \ Similarly, this list should include\n# modules used by PyInstaller's bootstrap\
    \ scripts and modules (loader/pyi*.py)\n\nPY3_BASE_MODULES = {\n    '_collections_abc',\n\
    \    '_weakrefset',\n    'abc',\n    'codecs',\n    'collections',\n    'copyreg',\n\
    \    'encodings',\n    'enum',\n    'functools',\n    'genericpath',  # dependency\
    \ of os.path\n    'io',\n    'heapq',\n    'keyword',\n    'linecache',\n    'locale',\n\
    \    'ntpath',  # dependency of os.path\n    'operator',\n    'os',\n    'posixpath',\
    \  # dependency of os.path\n    're',\n    'reprlib',\n    'sre_compile',\n  \
    \  'sre_constants',\n    'sre_parse',\n    'stat',  # dependency of os.path\n\
    \    'traceback',  # for startup errors\n    'types',\n    'weakref',\n    'warnings',\n\
    }\n\nif not is_py310:\n    PY3_BASE_MODULES.add('_bootlocale')\n\n# Object types\
    \ of Pure Python modules in modulegraph dependency graph.\n# Pure Python modules\
    \ have code object (attribute co_code).\nPURE_PYTHON_MODULE_TYPES = {\n    'SourceModule',\n\
    \    'CompiledModule',\n    'Package',\n    'NamespacePackage',\n    # Deprecated.\n\
    \    # TODO Could these module types be removed?\n    'FlatPackage',\n    'ArchiveModule',\n\
    }\n# Object types of special Python modules (built-in, run-time, namespace package)\
    \ in modulegraph dependency graph that do\n# not have code object.\nSPECIAL_MODULE_TYPES\
    \ = {\n    # Omit AliasNode from here (and consequently from VALID_MODULE_TYPES),\
    \ in order to prevent PyiModuleGraph from\n    # running standard hooks for aliased\
    \ modules.\n    #'AliasNode',\n    'BuiltinModule',\n    'RuntimeModule',\n  \
    \  'RuntimePackage',\n\n    # PyInstaller handles scripts differently and not\
    \ as standard Python modules.\n    'Script',\n}\n# Object types of Binary Python\
    \ modules (extensions, etc) in modulegraph dependency graph.\nBINARY_MODULE_TYPES\
    \ = {\n    'Extension',\n    'ExtensionPackage',\n}\n# Object types of valid Python\
    \ modules in modulegraph dependency graph.\nVALID_MODULE_TYPES = PURE_PYTHON_MODULE_TYPES\
    \ | SPECIAL_MODULE_TYPES | BINARY_MODULE_TYPES\n# Object types of bad/missing/invalid\
    \ Python modules in modulegraph dependency graph.\n# TODO: should be 'Invalid'\
    \ module types also in the 'MISSING' set?\nBAD_MODULE_TYPES = {\n    'BadModule',\n\
    \    'ExcludedModule',\n    'InvalidSourceModule',\n    'InvalidCompiledModule',\n\
    \    'MissingModule',\n\n    # Runtime modules and packages are technically valid\
    \ rather than bad, but exist only in-memory rather than on-disk\n    # (typically\
    \ due to pre_safe_import_module() hooks), and hence cannot be physically frozen.\
    \ For simplicity, these\n    # nodes are categorized as bad rather than valid.\n\
    \    'RuntimeModule',\n    'RuntimePackage',\n}\nALL_MODULE_TYPES = VALID_MODULE_TYPES\
    \ | BAD_MODULE_TYPES\n# TODO: review this mapping to TOC, remove useless entries.\n\
    # Dictionary to map ModuleGraph node types to TOC typecodes.\nMODULE_TYPES_TO_TOC_DICT\
    \ = {\n    # Pure modules.\n    'AliasNode': 'PYMODULE',\n    'Script': 'PYSOURCE',\n\
    \    'SourceModule': 'PYMODULE',\n    'CompiledModule': 'PYMODULE',\n    'Package':\
    \ 'PYMODULE',\n    'FlatPackage': 'PYMODULE',\n    'ArchiveModule': 'PYMODULE',\n\
    \    # Binary modules.\n    'Extension': 'EXTENSION',\n    'ExtensionPackage':\
    \ 'EXTENSION',\n    # Special valid modules.\n    'BuiltinModule': 'BUILTIN',\n\
    \    'NamespacePackage': 'PYMODULE',\n    # Bad modules.\n    'BadModule': 'bad',\n\
    \    'ExcludedModule': 'excluded',\n    'InvalidSourceModule': 'invalid',\n  \
    \  'InvalidCompiledModule': 'invalid',\n    'MissingModule': 'missing',\n    'RuntimeModule':\
    \ 'runtime',\n    'RuntimePackage': 'runtime',\n    # Other.\n    'does not occur':\
    \ 'BINARY',\n}\n\n\ndef check_requirements():\n    \"\"\"\n    Verify that all\
    \ requirements to run PyInstaller are met.\n\n    Fail hard if any requirement\
    \ is not met.\n    \"\"\"\n    # Fail hard if Python does not have minimum required\
    \ version\n    if sys.version_info < (3, 8):\n        raise EnvironmentError('PyInstaller\
    \ requires Python 3.8 or newer.')\n\n    # There are some old packages which used\
    \ to be backports of libraries which are now part of the standard library.\n \
    \   # These backports are now unmaintained and contain only an older subset of\
    \ features leading to obscure errors like\n    # \"enum has not attribute IntFlag\"\
    \ if installed.\n    from importlib.metadata import distribution, PackageNotFoundError\n\
    \n    for name in [\"enum34\", \"typing\", \"pathlib\"]:\n        try:\n     \
    \       dist = distribution(name)\n        except PackageNotFoundError:\n    \
    \        continue\n        remove = \"conda remove\" if is_conda else f'\"{sys.executable}\"\
    \ -m pip uninstall {name}'\n        raise SystemExit(\n            f\"The '{name}'\
    \ package is an obsolete backport of a standard library package and is incompatible\
    \ with \"\n            f\"PyInstaller. Please remove this package (located in\
    \ {dist.locate_file('')}) using\\n    {remove}\\n\"\n            \"then try again.\"\
    \n        )\n\n    # Bail out if binutils is not installed.\n    if is_linux and\
    \ shutil.which(\"objdump\") is None:\n        raise SystemExit(\n            \"\
    On Linux, objdump is required. It is typically provided by the 'binutils' package\
    \ \"\n            \"installable via your Linux distribution's package manager.\"\
    \n        )\n\nOutput the complete test file, code only, no explanations.\n###\
    \ Time\nCurrent time: 2025-03-17 01:52:27\n"
  role: user
