messages:
- content: You are an AI agent expert in writing unit tests. Your task is to write
    unit tests for the given code files of the repository. Make sure the tests can
    be executed without lint or compile errors.
  role: system
- content: "### Task Information\nBased on the source code, write/rewrite tests to\
    \ cover the source code.\nRepository: twisted\nTest File Path: twisted\\test_memcache\\\
    test_memcache.py\nProject Programming Language: Python\nTesting Framework: pytest\n\
    ### Source File Content\n### Source File Content:\n# -*- test-case-name: twisted.test.test_memcache\
    \ -*-\n# Copyright (c) Twisted Matrix Laboratories.\n# See LICENSE for details.\n\
    \n\"\"\"\nMemcache client protocol. Memcached is a caching server, storing data\
    \ in the\nform of pairs key/value, and memcache is the protocol to talk with it.\n\
    \nTo connect to a server, create a factory for L{MemCacheProtocol}::\n\n    from\
    \ twisted.internet import reactor, protocol\n    from twisted.protocols.memcache\
    \ import MemCacheProtocol, DEFAULT_PORT\n    d = protocol.ClientCreator(reactor,\
    \ MemCacheProtocol\n        ).connectTCP(\"localhost\", DEFAULT_PORT)\n    def\
    \ doSomething(proto):\n        # Here you call the memcache operations\n     \
    \   return proto.set(\"mykey\", \"a lot of data\")\n    d.addCallback(doSomething)\n\
    \    reactor.run()\n\nAll the operations of the memcache protocol are present,\
    \ but\nL{MemCacheProtocol.set} and L{MemCacheProtocol.get} are the more important.\n\
    \nSee U{http://code.sixapart.com/svn/memcached/trunk/server/doc/protocol.txt}\
    \ for\nmore information about the protocol.\n\"\"\"\n\n\nfrom collections import\
    \ deque\n\nfrom twisted.internet.defer import Deferred, TimeoutError, fail\nfrom\
    \ twisted.protocols.basic import LineReceiver\nfrom twisted.protocols.policies\
    \ import TimeoutMixin\nfrom twisted.python import log\nfrom twisted.python.compat\
    \ import nativeString, networkString\n\nDEFAULT_PORT = 11211\n\n\nclass NoSuchCommand(Exception):\n\
    \    \"\"\"\n    Exception raised when a non existent command is called.\n   \
    \ \"\"\"\n\n\nclass ClientError(Exception):\n    \"\"\"\n    Error caused by an\
    \ invalid client call.\n    \"\"\"\n\n\nclass ServerError(Exception):\n    \"\"\
    \"\n    Problem happening on the server.\n    \"\"\"\n\n\nclass Command:\n   \
    \ \"\"\"\n    Wrap a client action into an object, that holds the values used\
    \ in the\n    protocol.\n\n    @ivar _deferred: the L{Deferred} object that will\
    \ be fired when the result\n        arrives.\n    @type _deferred: L{Deferred}\n\
    \n    @ivar command: name of the command sent to the server.\n    @type command:\
    \ L{bytes}\n    \"\"\"\n\n    def __init__(self, command, **kwargs):\n       \
    \ \"\"\"\n        Create a command.\n\n        @param command: the name of the\
    \ command.\n        @type command: L{bytes}\n\n        @param kwargs: this values\
    \ will be stored as attributes of the object\n            for future use\n   \
    \     \"\"\"\n        self.command = command\n        self._deferred = Deferred()\n\
    \        for k, v in kwargs.items():\n            setattr(self, k, v)\n\n    def\
    \ success(self, value):\n        \"\"\"\n        Shortcut method to fire the underlying\
    \ deferred.\n        \"\"\"\n        self._deferred.callback(value)\n\n    def\
    \ fail(self, error):\n        \"\"\"\n        Make the underlying deferred fails.\n\
    \        \"\"\"\n        self._deferred.errback(error)\n\n\nclass MemCacheProtocol(LineReceiver,\
    \ TimeoutMixin):\n    \"\"\"\n    MemCache protocol: connect to a memcached server\
    \ to store/retrieve values.\n\n    @ivar persistentTimeOut: the timeout period\
    \ used to wait for a response.\n    @type persistentTimeOut: L{int}\n\n    @ivar\
    \ _current: current list of requests waiting for an answer from the\n        server.\n\
    \    @type _current: L{deque} of L{Command}\n\n    @ivar _lenExpected: amount\
    \ of data expected in raw mode, when reading for\n        a value.\n    @type\
    \ _lenExpected: L{int}\n\n    @ivar _getBuffer: current buffer of data, used to\
    \ store temporary data\n        when reading in raw mode.\n    @type _getBuffer:\
    \ L{list}\n\n    @ivar _bufferLength: the total amount of bytes in C{_getBuffer}.\n\
    \    @type _bufferLength: L{int}\n\n    @ivar _disconnected: indicate if the connectionLost\
    \ has been called or not.\n    @type _disconnected: L{bool}\n    \"\"\"\n\n  \
    \  MAX_KEY_LENGTH = 250\n    _disconnected = False\n\n    def __init__(self, timeOut=60):\n\
    \        \"\"\"\n        Create the protocol.\n\n        @param timeOut: the timeout\
    \ to wait before detecting that the\n            connection is dead and close\
    \ it. It's expressed in seconds.\n        @type timeOut: L{int}\n        \"\"\"\
    \n        self._current = deque()\n        self._lenExpected = None\n        self._getBuffer\
    \ = None\n        self._bufferLength = None\n        self.persistentTimeOut =\
    \ self.timeOut = timeOut\n\n    def _cancelCommands(self, reason):\n        \"\
    \"\"\n        Cancel all the outstanding commands, making them fail with C{reason}.\n\
    \        \"\"\"\n        while self._current:\n            cmd = self._current.popleft()\n\
    \            cmd.fail(reason)\n\n    def timeoutConnection(self):\n        \"\"\
    \"\n        Close the connection in case of timeout.\n        \"\"\"\n       \
    \ self._cancelCommands(TimeoutError(\"Connection timeout\"))\n        self.transport.loseConnection()\n\
    \n    def connectionLost(self, reason):\n        \"\"\"\n        Cause any outstanding\
    \ commands to fail.\n        \"\"\"\n        self._disconnected = True\n     \
    \   self._cancelCommands(reason)\n        LineReceiver.connectionLost(self, reason)\n\
    \n    def sendLine(self, line):\n        \"\"\"\n        Override sendLine to\
    \ add a timeout to response.\n        \"\"\"\n        if not self._current:\n\
    \            self.setTimeout(self.persistentTimeOut)\n        LineReceiver.sendLine(self,\
    \ line)\n\n    def rawDataReceived(self, data):\n        \"\"\"\n        Collect\
    \ data for a get.\n        \"\"\"\n        self.resetTimeout()\n        self._getBuffer.append(data)\n\
    \        self._bufferLength += len(data)\n        if self._bufferLength >= self._lenExpected\
    \ + 2:\n            data = b\"\".join(self._getBuffer)\n            buf = data[:\
    \ self._lenExpected]\n            rem = data[self._lenExpected + 2 :]\n      \
    \      val = buf\n            self._lenExpected = None\n            self._getBuffer\
    \ = None\n            self._bufferLength = None\n            cmd = self._current[0]\n\
    \            if cmd.multiple:\n                flags, cas = cmd.values[cmd.currentKey]\n\
    \                cmd.values[cmd.currentKey] = (flags, cas, val)\n            else:\n\
    \                cmd.value = val\n            self.setLineMode(rem)\n\n    def\
    \ cmd_STORED(self):\n        \"\"\"\n        Manage a success response to a set\
    \ operation.\n        \"\"\"\n        self._current.popleft().success(True)\n\n\
    \    def cmd_NOT_STORED(self):\n        \"\"\"\n        Manage a specific 'not\
    \ stored' response to a set operation: this is not\n        an error, but some\
    \ condition wasn't met.\n        \"\"\"\n        self._current.popleft().success(False)\n\
    \n    def cmd_END(self):\n        \"\"\"\n        This the end token to a get\
    \ or a stat operation.\n        \"\"\"\n        cmd = self._current.popleft()\n\
    \        if cmd.command == b\"get\":\n            if cmd.multiple:\n         \
    \       values = {key: val[::2] for key, val in cmd.values.items()}\n        \
    \        cmd.success(values)\n            else:\n                cmd.success((cmd.flags,\
    \ cmd.value))\n        elif cmd.command == b\"gets\":\n            if cmd.multiple:\n\
    \                cmd.success(cmd.values)\n            else:\n                cmd.success((cmd.flags,\
    \ cmd.cas, cmd.value))\n        elif cmd.command == b\"stats\":\n            cmd.success(cmd.values)\n\
    \        else:\n            raise RuntimeError(\n                \"Unexpected\
    \ END response to {} command\".format(\n                    nativeString(cmd.command)\n\
    \                )\n            )\n\n    def cmd_NOT_FOUND(self):\n        \"\"\
    \"\n        Manage error response for incr/decr/delete.\n        \"\"\"\n    \
    \    self._current.popleft().success(False)\n\n    def cmd_VALUE(self, line):\n\
    \        \"\"\"\n        Prepare the reading a value after a get.\n        \"\"\
    \"\n        cmd = self._current[0]\n        if cmd.command == b\"get\":\n    \
    \        key, flags, length = line.split()\n            cas = b\"\"\n        else:\n\
    \            key, flags, length, cas = line.split()\n        self._lenExpected\
    \ = int(length)\n        self._getBuffer = []\n        self._bufferLength = 0\n\
    \        if cmd.multiple:\n            if key not in cmd.keys:\n             \
    \   raise RuntimeError(\"Unexpected commands answer.\")\n            cmd.currentKey\
    \ = key\n            cmd.values[key] = [int(flags), cas]\n        else:\n    \
    \        if cmd.key != key:\n                raise RuntimeError(\"Unexpected commands\
    \ answer.\")\n            cmd.flags = int(flags)\n            cmd.cas = cas\n\
    \        self.setRawMode()\n\n    def cmd_STAT(self, line):\n        \"\"\"\n\
    \        Reception of one stat line.\n        \"\"\"\n        cmd = self._current[0]\n\
    \        key, val = line.split(b\" \", 1)\n        cmd.values[key] = val\n\n \
    \   def cmd_VERSION(self, versionData):\n        \"\"\"\n        Read version\
    \ token.\n        \"\"\"\n        self._current.popleft().success(versionData)\n\
    \n    def cmd_ERROR(self):\n        \"\"\"\n        A non-existent command has\
    \ been sent.\n        \"\"\"\n        log.err(\"Non-existent command sent.\")\n\
    \        cmd = self._current.popleft()\n        cmd.fail(NoSuchCommand())\n\n\
    \    def cmd_CLIENT_ERROR(self, errText):\n        \"\"\"\n        An invalid\
    \ input as been sent.\n        \"\"\"\n        errText = repr(errText)\n     \
    \   log.err(\"Invalid input: \" + errText)\n        cmd = self._current.popleft()\n\
    \        cmd.fail(ClientError(errText))\n\n    def cmd_SERVER_ERROR(self, errText):\n\
    \        \"\"\"\n        An error has happened server-side.\n        \"\"\"\n\
    \        errText = repr(errText)\n        log.err(\"Server error: \" + errText)\n\
    \        cmd = self._current.popleft()\n        cmd.fail(ServerError(errText))\n\
    \n    def cmd_DELETED(self):\n        \"\"\"\n        A delete command has completed\
    \ successfully.\n        \"\"\"\n        self._current.popleft().success(True)\n\
    \n    def cmd_OK(self):\n        \"\"\"\n        The last command has been completed.\n\
    \        \"\"\"\n        self._current.popleft().success(True)\n\n    def cmd_EXISTS(self):\n\
    \        \"\"\"\n        A C{checkAndSet} update has failed.\n        \"\"\"\n\
    \        self._current.popleft().success(False)\n\n    def lineReceived(self,\
    \ line):\n        \"\"\"\n        Receive line commands from the server.\n   \
    \     \"\"\"\n        self.resetTimeout()\n        token = line.split(b\" \",\
    \ 1)[0]\n        # First manage standard commands without space\n        cmd =\
    \ getattr(self, \"cmd_\" + nativeString(token), None)\n        if cmd is not None:\n\
    \            args = line.split(b\" \", 1)[1:]\n            if args:\n        \
    \        cmd(args[0])\n            else:\n                cmd()\n        else:\n\
    \            # Then manage commands with space in it\n            line = line.replace(b\"\
    \ \", b\"_\")\n            cmd = getattr(self, \"cmd_\" + nativeString(line),\
    \ None)\n            if cmd is not None:\n                cmd()\n            else:\n\
    \                # Increment/Decrement response\n                cmd = self._current.popleft()\n\
    \                val = int(line)\n                cmd.success(val)\n        if\
    \ not self._current:\n            # No pending request, remove timeout\n     \
    \       self.setTimeout(None)\n\n    def increment(self, key, val=1):\n      \
    \  \"\"\"\n        Increment the value of C{key} by given value (default to 1).\n\
    \        C{key} must be consistent with an int. Return the new value.\n\n    \
    \    @param key: the key to modify.\n        @type key: L{bytes}\n\n        @param\
    \ val: the value to increment.\n        @type val: L{int}\n\n        @return:\
    \ a deferred with will be called back with the new value\n            associated\
    \ with the key (after the increment).\n        @rtype: L{Deferred}\n        \"\
    \"\"\n        return self._incrdecr(b\"incr\", key, val)\n\n    def decrement(self,\
    \ key, val=1):\n        \"\"\"\n        Decrement the value of C{key} by given\
    \ value (default to 1).\n        C{key} must be consistent with an int. Return\
    \ the new value, coerced to\n        0 if negative.\n\n        @param key: the\
    \ key to modify.\n        @type key: L{bytes}\n\n        @param val: the value\
    \ to decrement.\n        @type val: L{int}\n\n        @return: a deferred with\
    \ will be called back with the new value\n            associated with the key\
    \ (after the decrement).\n        @rtype: L{Deferred}\n        \"\"\"\n      \
    \  return self._incrdecr(b\"decr\", key, val)\n\n    def _incrdecr(self, cmd,\
    \ key, val):\n        \"\"\"\n        Internal wrapper for incr/decr.\n      \
    \  \"\"\"\n        if self._disconnected:\n            return fail(RuntimeError(\"\
    not connected\"))\n        if not isinstance(key, bytes):\n            return\
    \ fail(\n                ClientError(f\"Invalid type for key: {type(key)}, expecting\
    \ bytes\")\n            )\n        if len(key) > self.MAX_KEY_LENGTH:\n      \
    \      return fail(ClientError(\"Key too long\"))\n        fullcmd = b\" \".join([cmd,\
    \ key, b\"%d\" % (int(val),)])\n        self.sendLine(fullcmd)\n        cmdObj\
    \ = Command(cmd, key=key)\n        self._current.append(cmdObj)\n        return\
    \ cmdObj._deferred\n\n    def replace(self, key, val, flags=0, expireTime=0):\n\
    \        \"\"\"\n        Replace the given C{key}. It must already exist in the\
    \ server.\n\n        @param key: the key to replace.\n        @type key: L{bytes}\n\
    \n        @param val: the new value associated with the key.\n        @type val:\
    \ L{bytes}\n\n        @param flags: the flags to store with the key.\n       \
    \ @type flags: L{int}\n\n        @param expireTime: if different from 0, the relative\
    \ time in seconds\n            when the key will be deleted from the store.\n\
    \        @type expireTime: L{int}\n\n        @return: a deferred that will fire\
    \ with C{True} if the operation has\n            succeeded, and C{False} with\
    \ the key didn't previously exist.\n        @rtype: L{Deferred}\n        \"\"\"\
    \n        return self._set(b\"replace\", key, val, flags, expireTime, b\"\")\n\
    \n    def add(self, key, val, flags=0, expireTime=0):\n        \"\"\"\n      \
    \  Add the given C{key}. It must not exist in the server.\n\n        @param key:\
    \ the key to add.\n        @type key: L{bytes}\n\n        @param val: the value\
    \ associated with the key.\n        @type val: L{bytes}\n\n        @param flags:\
    \ the flags to store with the key.\n        @type flags: L{int}\n\n        @param\
    \ expireTime: if different from 0, the relative time in seconds\n            when\
    \ the key will be deleted from the store.\n        @type expireTime: L{int}\n\n\
    \        @return: a deferred that will fire with C{True} if the operation has\n\
    \            succeeded, and C{False} with the key already exists.\n        @rtype:\
    \ L{Deferred}\n        \"\"\"\n        return self._set(b\"add\", key, val, flags,\
    \ expireTime, b\"\")\n\n    def set(self, key, val, flags=0, expireTime=0):\n\
    \        \"\"\"\n        Set the given C{key}.\n\n        @param key: the key\
    \ to set.\n        @type key: L{bytes}\n\n        @param val: the value associated\
    \ with the key.\n        @type val: L{bytes}\n\n        @param flags: the flags\
    \ to store with the key.\n        @type flags: L{int}\n\n        @param expireTime:\
    \ if different from 0, the relative time in seconds\n            when the key\
    \ will be deleted from the store.\n        @type expireTime: L{int}\n\n      \
    \  @return: a deferred that will fire with C{True} if the operation has\n    \
    \        succeeded.\n        @rtype: L{Deferred}\n        \"\"\"\n        return\
    \ self._set(b\"set\", key, val, flags, expireTime, b\"\")\n\n    def checkAndSet(self,\
    \ key, val, cas, flags=0, expireTime=0):\n        \"\"\"\n        Change the content\
    \ of C{key} only if the C{cas} value matches the\n        current one associated\
    \ with the key. Use this to store a value which\n        hasn't been modified\
    \ since last time you fetched it.\n\n        @param key: The key to set.\n   \
    \     @type key: L{bytes}\n\n        @param val: The value associated with the\
    \ key.\n        @type val: L{bytes}\n\n        @param cas: Unique 64-bit value\
    \ returned by previous call of C{get}.\n        @type cas: L{bytes}\n\n      \
    \  @param flags: The flags to store with the key.\n        @type flags: L{int}\n\
    \n        @param expireTime: If different from 0, the relative time in seconds\n\
    \            when the key will be deleted from the store.\n        @type expireTime:\
    \ L{int}\n\n        @return: A deferred that will fire with C{True} if the operation\
    \ has\n            succeeded, C{False} otherwise.\n        @rtype: L{Deferred}\n\
    \        \"\"\"\n        return self._set(b\"cas\", key, val, flags, expireTime,\
    \ cas)\n\n    def _set(self, cmd, key, val, flags, expireTime, cas):\n       \
    \ \"\"\"\n        Internal wrapper for setting values.\n        \"\"\"\n     \
    \   if self._disconnected:\n            return fail(RuntimeError(\"not connected\"\
    ))\n        if not isinstance(key, bytes):\n            return fail(\n       \
    \         ClientError(f\"Invalid type for key: {type(key)}, expecting bytes\"\
    )\n            )\n        if len(key) > self.MAX_KEY_LENGTH:\n            return\
    \ fail(ClientError(\"Key too long\"))\n        if not isinstance(val, bytes):\n\
    \            return fail(\n                ClientError(f\"Invalid type for value:\
    \ {type(val)}, expecting bytes\")\n            )\n        if cas:\n          \
    \  cas = b\" \" + cas\n        length = len(val)\n        fullcmd = (\n      \
    \      b\" \".join(\n                [cmd, key, networkString(\"%d %d %d\" % (flags,\
    \ expireTime, length))]\n            )\n            + cas\n        )\n       \
    \ self.sendLine(fullcmd)\n        self.sendLine(val)\n        cmdObj = Command(cmd,\
    \ key=key, flags=flags, length=length)\n        self._current.append(cmdObj)\n\
    \        return cmdObj._deferred\n\n    def append(self, key, val):\n        \"\
    \"\"\n        Append given data to the value of an existing key.\n\n        @param\
    \ key: The key to modify.\n        @type key: L{bytes}\n\n        @param val:\
    \ The value to append to the current value associated with\n            the key.\n\
    \        @type val: L{bytes}\n\n        @return: A deferred that will fire with\
    \ C{True} if the operation has\n            succeeded, C{False} otherwise.\n \
    \       @rtype: L{Deferred}\n        \"\"\"\n        # Even if flags and expTime\
    \ values are ignored, we have to pass them\n        return self._set(b\"append\"\
    , key, val, 0, 0, b\"\")\n\n    def prepend(self, key, val):\n        \"\"\"\n\
    \        Prepend given data to the value of an existing key.\n\n        @param\
    \ key: The key to modify.\n        @type key: L{bytes}\n\n        @param val:\
    \ The value to prepend to the current value associated with\n            the key.\n\
    \        @type val: L{bytes}\n\n        @return: A deferred that will fire with\
    \ C{True} if the operation has\n            succeeded, C{False} otherwise.\n \
    \       @rtype: L{Deferred}\n        \"\"\"\n        # Even if flags and expTime\
    \ values are ignored, we have to pass them\n        return self._set(b\"prepend\"\
    , key, val, 0, 0, b\"\")\n\n    def get(self, key, withIdentifier=False):\n  \
    \      \"\"\"\n        Get the given C{key}. It doesn't support multiple keys.\
    \ If\n        C{withIdentifier} is set to C{True}, the command issued is a C{gets},\n\
    \        that will return the current identifier associated with the value. This\n\
    \        identifier has to be used when issuing C{checkAndSet} update later,\n\
    \        using the corresponding method.\n\n        @param key: The key to retrieve.\n\
    \        @type key: L{bytes}\n\n        @param withIdentifier: If set to C{True},\
    \ retrieve the current\n            identifier along with the value and the flags.\n\
    \        @type withIdentifier: L{bool}\n\n        @return: A deferred that will\
    \ fire with the tuple (flags, value) if\n            C{withIdentifier} is C{False},\
    \ or (flags, cas identifier, value)\n            if C{True}.  If the server indicates\
    \ there is no value\n            associated with C{key}, the returned value will\
    \ be L{None} and\n            the returned flags will be C{0}.\n        @rtype:\
    \ L{Deferred}\n        \"\"\"\n        return self._get([key], withIdentifier,\
    \ False)\n\n    def getMultiple(self, keys, withIdentifier=False):\n        \"\
    \"\"\n        Get the given list of C{keys}.  If C{withIdentifier} is set to C{True},\n\
    \        the command issued is a C{gets}, that will return the identifiers\n \
    \       associated with each values. This identifier has to be used when\n   \
    \     issuing C{checkAndSet} update later, using the corresponding method.\n\n\
    \        @param keys: The keys to retrieve.\n        @type keys: L{list} of L{bytes}\n\
    \n        @param withIdentifier: If set to C{True}, retrieve the identifiers\n\
    \            along with the values and the flags.\n        @type withIdentifier:\
    \ L{bool}\n\n        @return: A deferred that will fire with a dictionary with\
    \ the elements\n            of C{keys} as keys and the tuples (flags, value) as\
    \ values if\n            C{withIdentifier} is C{False}, or (flags, cas identifier,\
    \ value) if\n            C{True}.  If the server indicates there is no value associated\
    \ with\n            C{key}, the returned values will be L{None} and the returned\
    \ flags\n            will be C{0}.\n        @rtype: L{Deferred}\n\n        @since:\
    \ 9.0\n        \"\"\"\n        return self._get(keys, withIdentifier, True)\n\n\
    \    def _get(self, keys, withIdentifier, multiple):\n        \"\"\"\n       \
    \ Helper method for C{get} and C{getMultiple}.\n        \"\"\"\n        keys =\
    \ list(keys)\n        if self._disconnected:\n            return fail(RuntimeError(\"\
    not connected\"))\n        for key in keys:\n            if not isinstance(key,\
    \ bytes):\n                return fail(\n                    ClientError(f\"Invalid\
    \ type for key: {type(key)}, expecting bytes\")\n                )\n         \
    \   if len(key) > self.MAX_KEY_LENGTH:\n                return fail(ClientError(\"\
    Key too long\"))\n        if withIdentifier:\n            cmd = b\"gets\"\n  \
    \      else:\n            cmd = b\"get\"\n        fullcmd = b\" \".join([cmd]\
    \ + keys)\n        self.sendLine(fullcmd)\n        if multiple:\n            values\
    \ = {key: (0, b\"\", None) for key in keys}\n            cmdObj = Command(cmd,\
    \ keys=keys, values=values, multiple=True)\n        else:\n            cmdObj\
    \ = Command(\n                cmd, key=keys[0], value=None, flags=0, cas=b\"\"\
    , multiple=False\n            )\n        self._current.append(cmdObj)\n      \
    \  return cmdObj._deferred\n\n    def stats(self, arg=None):\n        \"\"\"\n\
    \        Get some stats from the server. It will be available as a dict.\n\n \
    \       @param arg: An optional additional string which will be sent along\n \
    \           with the I{stats} command.  The interpretation of this value by\n\
    \            the server is left undefined by the memcache protocol\n         \
    \   specification.\n        @type arg: L{None} or L{bytes}\n\n        @return:\
    \ a deferred that will fire with a L{dict} of the available\n            statistics.\n\
    \        @rtype: L{Deferred}\n        \"\"\"\n        if arg:\n            cmd\
    \ = b\"stats \" + arg\n        else:\n            cmd = b\"stats\"\n        if\
    \ self._disconnected:\n            return fail(RuntimeError(\"not connected\"\
    ))\n        self.sendLine(cmd)\n        cmdObj = Command(b\"stats\", values={})\n\
    \        self._current.append(cmdObj)\n        return cmdObj._deferred\n\n   \
    \ def version(self):\n        \"\"\"\n        Get the version of the server.\n\
    \n        @return: a deferred that will fire with the string value of the\n  \
    \          version.\n        @rtype: L{Deferred}\n        \"\"\"\n        if self._disconnected:\n\
    \            return fail(RuntimeError(\"not connected\"))\n        self.sendLine(b\"\
    version\")\n        cmdObj = Command(b\"version\")\n        self._current.append(cmdObj)\n\
    \        return cmdObj._deferred\n\n    def delete(self, key):\n        \"\"\"\
    \n        Delete an existing C{key}.\n\n        @param key: the key to delete.\n\
    \        @type key: L{bytes}\n\n        @return: a deferred that will be called\
    \ back with C{True} if the key\n            was successfully deleted, or C{False}\
    \ if not.\n        @rtype: L{Deferred}\n        \"\"\"\n        if self._disconnected:\n\
    \            return fail(RuntimeError(\"not connected\"))\n        if not isinstance(key,\
    \ bytes):\n            return fail(\n                ClientError(f\"Invalid type\
    \ for key: {type(key)}, expecting bytes\")\n            )\n        self.sendLine(b\"\
    delete \" + key)\n        cmdObj = Command(b\"delete\", key=key)\n        self._current.append(cmdObj)\n\
    \        return cmdObj._deferred\n\n    def flushAll(self):\n        \"\"\"\n\
    \        Flush all cached values.\n\n        @return: a deferred that will be\
    \ called back with C{True} when the\n            operation has succeeded.\n  \
    \      @rtype: L{Deferred}\n        \"\"\"\n        if self._disconnected:\n \
    \           return fail(RuntimeError(\"not connected\"))\n        self.sendLine(b\"\
    flush_all\")\n        cmdObj = Command(b\"flush_all\")\n        self._current.append(cmdObj)\n\
    \        return cmdObj._deferred\n\n\n__all__ = [\n    \"MemCacheProtocol\",\n\
    \    \"DEFAULT_PORT\",\n    \"NoSuchCommand\",\n    \"ClientError\",\n    \"ServerError\"\
    ,\n]\n\n### Source File Dependency Files Content\n### Dependency File: basic.py\n\
    # -*- test-case-name: twisted.protocols.test.test_basic -*-\n# Copyright (c) Twisted\
    \ Matrix Laboratories.\n# See LICENSE for details.\n\n\n\"\"\"\nBasic protocols,\
    \ such as line-oriented, netstring, and int prefixed strings.\n\"\"\"\n\n\nimport\
    \ math\n\n# System imports\nimport re\nfrom io import BytesIO\nfrom struct import\
    \ calcsize, pack, unpack\n\nfrom zope.interface import implementer\n\n# Twisted\
    \ imports\nfrom twisted.internet import defer, interfaces, protocol\nfrom twisted.python\
    \ import log\n\n\n# Unfortunately we cannot use regular string formatting on Python\
    \ 3; see\n# http://bugs.python.org/issue3982 for details.\ndef _formatNetstring(data):\n\
    \    return b\"\".join([str(len(data)).encode(\"ascii\"), b\":\", data, b\",\"\
    ])\n\n\n_formatNetstring.__doc__ = \"\"\"\nConvert some C{bytes} into netstring\
    \ format.\n\n@param data: C{bytes} that will be reformatted.\n\"\"\"\n\n\nDEBUG\
    \ = 0\n\n\nclass NetstringParseError(ValueError):\n    \"\"\"\n    The incoming\
    \ data is not in valid Netstring format.\n    \"\"\"\n\n\nclass IncompleteNetstring(Exception):\n\
    \    \"\"\"\n    Not enough data to complete a netstring.\n    \"\"\"\n\n\nclass\
    \ NetstringReceiver(protocol.Protocol):\n    \"\"\"\n    A protocol that sends\
    \ and receives netstrings.\n\n    See U{http://cr.yp.to/proto/netstrings.txt}\
    \ for the specification of\n    netstrings. Every netstring starts with digits\
    \ that specify the length\n    of the data. This length specification is separated\
    \ from the data by\n    a colon. The data is terminated with a comma.\n\n    Override\
    \ L{stringReceived} to handle received netstrings. This\n    method is called\
    \ with the netstring payload as a single argument\n    whenever a complete netstring\
    \ is received.\n\n    Security features:\n        1. Messages are limited in size,\
    \ useful if you don't want\n           someone sending you a 500MB netstring (change\
    \ C{self.MAX_LENGTH}\n           to the maximum length you wish to accept).\n\
    \        2. The connection is lost if an illegal message is received.\n\n    @ivar\
    \ MAX_LENGTH: Defines the maximum length of netstrings that can be\n        received.\n\
    \    @type MAX_LENGTH: C{int}\n\n    @ivar _LENGTH: A pattern describing all strings\
    \ that contain a netstring\n        length specification. Examples for length\
    \ specifications are C{b'0:'},\n        C{b'12:'}, and C{b'179:'}. C{b'007:'}\
    \ is not a valid length\n        specification, since leading zeros are not allowed.\n\
    \    @type _LENGTH: C{re.Match}\n\n    @ivar _LENGTH_PREFIX: A pattern describing\
    \ all strings that contain\n        the first part of a netstring length specification\
    \ (without the\n        trailing comma). Examples are '0', '12', and '179'. '007'\
    \ does not\n        start a netstring length specification, since leading zeros\
    \ are\n        not allowed.\n    @type _LENGTH_PREFIX: C{re.Match}\n\n    @ivar\
    \ _PARSING_LENGTH: Indicates that the C{NetstringReceiver} is in\n        the\
    \ state of parsing the length portion of a netstring.\n    @type _PARSING_LENGTH:\
    \ C{int}\n\n    @ivar _PARSING_PAYLOAD: Indicates that the C{NetstringReceiver}\
    \ is in\n        the state of parsing the payload portion (data and trailing comma)\n\
    \        of a netstring.\n    @type _PARSING_PAYLOAD: C{int}\n\n    @ivar brokenPeer:\
    \ Indicates if the connection is still functional\n    @type brokenPeer: C{int}\n\
    \n    @ivar _state: Indicates if the protocol is consuming the length portion\n\
    \        (C{PARSING_LENGTH}) or the payload (C{PARSING_PAYLOAD}) of a netstring\n\
    \    @type _state: C{int}\n\n    @ivar _remainingData: Holds the chunk of data\
    \ that has not yet been consumed\n    @type _remainingData: C{string}\n\n    @ivar\
    \ _payload: Holds the payload portion of a netstring including the\n        trailing\
    \ comma\n    @type _payload: C{BytesIO}\n\n    @ivar _expectedPayloadSize: Holds\
    \ the payload size plus one for the trailing\n        comma.\n    @type _expectedPayloadSize:\
    \ C{int}\n    \"\"\"\n\n    MAX_LENGTH = 99999\n    _LENGTH = re.compile(rb\"\
    (0|[1-9]\\d*)(:)\")\n\n    _LENGTH_PREFIX = re.compile(rb\"(0|[1-9]\\d*)$\")\n\
    \n    # Some error information for NetstringParseError instances.\n    _MISSING_LENGTH\
    \ = (\n        \"The received netstring does not start with a \" \"length specification.\"\
    \n    )\n    _OVERFLOW = (\n        \"The length specification of the received\
    \ netstring \"\n        \"cannot be represented in Python - it causes an \"\n\
    \        \"OverflowError!\"\n    )\n    _TOO_LONG = (\n        \"The received\
    \ netstring is longer than the maximum %s \"\n        \"specified by self.MAX_LENGTH\"\
    \n    )\n    _MISSING_COMMA = \"The received netstring is not terminated by a\
    \ comma.\"\n\n    # The following constants are used for determining if the NetstringReceiver\n\
    \    # is parsing the length portion of a netstring, or the payload.\n    _PARSING_LENGTH,\
    \ _PARSING_PAYLOAD = range(2)\n\n    def makeConnection(self, transport):\n  \
    \      \"\"\"\n        Initializes the protocol.\n        \"\"\"\n        protocol.Protocol.makeConnection(self,\
    \ transport)\n        self._remainingData = b\"\"\n        self._currentPayloadSize\
    \ = 0\n        self._payload = BytesIO()\n        self._state = self._PARSING_LENGTH\n\
    \        self._expectedPayloadSize = 0\n        self.brokenPeer = 0\n\n    def\
    \ sendString(self, string):\n        \"\"\"\n        Sends a netstring.\n\n  \
    \      Wraps up C{string} by adding length information and a\n        trailing\
    \ comma; writes the result to the transport.\n\n        @param string: The string\
    \ to send.  The necessary framing (length\n            prefix, etc) will be added.\n\
    \        @type string: C{bytes}\n        \"\"\"\n        self.transport.write(_formatNetstring(string))\n\
    \n    def dataReceived(self, data):\n        \"\"\"\n        Receives some characters\
    \ of a netstring.\n\n        Whenever a complete netstring is received, this method\
    \ extracts\n        its payload and calls L{stringReceived} to process it.\n\n\
    \        @param data: A chunk of data representing a (possibly partial)\n    \
    \        netstring\n        @type data: C{bytes}\n        \"\"\"\n        self._remainingData\
    \ += data\n        while self._remainingData:\n            try:\n            \
    \    self._consumeData()\n            except IncompleteNetstring:\n          \
    \      break\n            except NetstringParseError:\n                self._handleParseError()\n\
    \                break\n\n    def stringReceived(self, string):\n        \"\"\"\
    \n        Override this for notification when each complete string is received.\n\
    \n        @param string: The complete string which was received with all\n   \
    \         framing (length prefix, etc) removed.\n        @type string: C{bytes}\n\
    \n        @raise NotImplementedError: because the method has to be implemented\n\
    \            by the child class.\n        \"\"\"\n        raise NotImplementedError()\n\
    \n    def _maxLengthSize(self):\n        \"\"\"\n        Calculate and return\
    \ the string size of C{self.MAX_LENGTH}.\n\n        @return: The size of the string\
    \ representation for C{self.MAX_LENGTH}\n        @rtype: C{float}\n        \"\"\
    \"\n        return math.ceil(math.log10(self.MAX_LENGTH)) + 1\n\n    def _consumeData(self):\n\
    \        \"\"\"\n        Consumes the content of C{self._remainingData}.\n\n \
    \       @raise IncompleteNetstring: if C{self._remainingData} does not\n     \
    \       contain enough data to complete the current netstring.\n        @raise\
    \ NetstringParseError: if the received data do not\n            form a valid netstring.\n\
    \        \"\"\"\n        if self._state == self._PARSING_LENGTH:\n           \
    \ self._consumeLength()\n            self._prepareForPayloadConsumption()\n  \
    \      if self._state == self._PARSING_PAYLOAD:\n            self._consumePayload()\n\
    \n    def _consumeLength(self):\n        \"\"\"\n        Consumes the length portion\
    \ of C{self._remainingData}.\n\n        @raise IncompleteNetstring: if C{self._remainingData}\
    \ contains\n            a partial length specification (digits without trailing\n\
    \            comma).\n        @raise NetstringParseError: if the received data\
    \ do not form a valid\n            netstring.\n        \"\"\"\n        lengthMatch\
    \ = self._LENGTH.match(self._remainingData)\n        if not lengthMatch:\n   \
    \         self._checkPartialLengthSpecification()\n            raise IncompleteNetstring()\n\
    \        self._processLength(lengthMatch)\n\n    def _checkPartialLengthSpecification(self):\n\
    \        \"\"\"\n        Makes sure that the received data represents a valid\
    \ number.\n\n        Checks if C{self._remainingData} represents a number smaller\
    \ or\n        equal to C{self.MAX_LENGTH}.\n\n        @raise NetstringParseError:\
    \ if C{self._remainingData} is no\n            number or is too big (checked by\
    \ L{_extractLength}).\n        \"\"\"\n        partialLengthMatch = self._LENGTH_PREFIX.match(self._remainingData)\n\
    \        if not partialLengthMatch:\n            raise NetstringParseError(self._MISSING_LENGTH)\n\
    \        lengthSpecification = partialLengthMatch.group(1)\n        self._extractLength(lengthSpecification)\n\
    \n    def _processLength(self, lengthMatch):\n        \"\"\"\n        Processes\
    \ the length definition of a netstring.\n\n        Extracts and stores in C{self._expectedPayloadSize}\
    \ the number\n        representing the netstring size.  Removes the prefix\n \
    \       representing the length specification from\n        C{self._remainingData}.\n\
    \n        @raise NetstringParseError: if the received netstring does not\n   \
    \         start with a number or the number is bigger than\n            C{self.MAX_LENGTH}.\n\
    \        @param lengthMatch: A regular expression match object matching\n    \
    \        a netstring length specification\n        @type lengthMatch: C{re.Match}\n\
    \        \"\"\"\n        endOfNumber = lengthMatch.end(1)\n        startOfData\
    \ = lengthMatch.end(2)\n        lengthString = self._remainingData[:endOfNumber]\n\
    \        # Expect payload plus trailing comma:\n        self._expectedPayloadSize\
    \ = self._extractLength(lengthString) + 1\n        self._remainingData = self._remainingData[startOfData:]\n\
    \n    def _extractLength(self, lengthAsString):\n        \"\"\"\n        Attempts\
    \ to extract the length information of a netstring.\n\n        @raise NetstringParseError:\
    \ if the number is bigger than\n            C{self.MAX_LENGTH}.\n        @param\
    \ lengthAsString: A chunk of data starting with a length\n            specification\n\
    \        @type lengthAsString: C{bytes}\n        @return: The length of the netstring\n\
    \        @rtype: C{int}\n        \"\"\"\n        self._checkStringSize(lengthAsString)\n\
    \        length = int(lengthAsString)\n        if length > self.MAX_LENGTH:\n\
    \            raise NetstringParseError(self._TOO_LONG % (self.MAX_LENGTH,))\n\
    \        return length\n\n    def _checkStringSize(self, lengthAsString):\n  \
    \      \"\"\"\n        Checks the sanity of lengthAsString.\n\n        Checks\
    \ if the size of the length specification exceeds the\n        size of the string\
    \ representing self.MAX_LENGTH. If this is\n        not the case, the number represented\
    \ by lengthAsString is\n        certainly bigger than self.MAX_LENGTH, and a\n\
    \        NetstringParseError can be raised.\n\n        This method should make\
    \ sure that netstrings with extremely\n        long length specifications are\
    \ refused before even attempting\n        to convert them to an integer (which\
    \ might trigger a\n        MemoryError).\n        \"\"\"\n        if len(lengthAsString)\
    \ > self._maxLengthSize():\n            raise NetstringParseError(self._TOO_LONG\
    \ % (self.MAX_LENGTH,))\n\n    def _prepareForPayloadConsumption(self):\n    \
    \    \"\"\"\n        Sets up variables necessary for consuming the payload of\
    \ a netstring.\n        \"\"\"\n        self._state = self._PARSING_PAYLOAD\n\
    \        self._currentPayloadSize = 0\n        self._payload.seek(0)\n       \
    \ self._payload.truncate()\n\n    def _consumePayload(self):\n        \"\"\"\n\
    \        Consumes the payload portion of C{self._remainingData}.\n\n        If\
    \ the payload is complete, checks for the trailing comma and\n        processes\
    \ the payload. If not, raises an L{IncompleteNetstring}\n        exception.\n\n\
    \        @raise IncompleteNetstring: if the payload received so far\n        \
    \    contains fewer characters than expected.\n        @raise NetstringParseError:\
    \ if the payload does not end with a\n        comma.\n        \"\"\"\n       \
    \ self._extractPayload()\n        if self._currentPayloadSize < self._expectedPayloadSize:\n\
    \            raise IncompleteNetstring()\n        self._checkForTrailingComma()\n\
    \        self._state = self._PARSING_LENGTH\n        self._processPayload()\n\n\
    \    def _extractPayload(self):\n        \"\"\"\n        Extracts payload information\
    \ from C{self._remainingData}.\n\n        Splits C{self._remainingData} at the\
    \ end of the netstring.  The\n        first part becomes C{self._payload}, the\
    \ second part is stored\n        in C{self._remainingData}.\n\n        If the\
    \ netstring is not yet complete, the whole content of\n        C{self._remainingData}\
    \ is moved to C{self._payload}.\n        \"\"\"\n        if self._payloadComplete():\n\
    \            remainingPayloadSize = self._expectedPayloadSize - self._currentPayloadSize\n\
    \            self._payload.write(self._remainingData[:remainingPayloadSize])\n\
    \            self._remainingData = self._remainingData[remainingPayloadSize:]\n\
    \            self._currentPayloadSize = self._expectedPayloadSize\n        else:\n\
    \            self._payload.write(self._remainingData)\n            self._currentPayloadSize\
    \ += len(self._remainingData)\n            self._remainingData = b\"\"\n\n   \
    \ def _payloadComplete(self):\n        \"\"\"\n        Checks if enough data have\
    \ been received to complete the netstring.\n\n        @return: C{True} iff the\
    \ received data contain at least as many\n            characters as specified\
    \ in the length section of the\n            netstring\n        @rtype: C{bool}\n\
    \        \"\"\"\n        return (\n            len(self._remainingData) + self._currentPayloadSize\n\
    \            >= self._expectedPayloadSize\n        )\n\n    def _processPayload(self):\n\
    \        \"\"\"\n        Processes the actual payload with L{stringReceived}.\n\
    \n        Strips C{self._payload} of the trailing comma and calls\n        L{stringReceived}\
    \ with the result.\n        \"\"\"\n        self.stringReceived(self._payload.getvalue()[:-1])\n\
    \n    def _checkForTrailingComma(self):\n        \"\"\"\n        Checks if the\
    \ netstring has a trailing comma at the expected position.\n\n        @raise NetstringParseError:\
    \ if the last payload character is\n            anything but a comma.\n      \
    \  \"\"\"\n        if self._payload.getvalue()[-1:] != b\",\":\n            raise\
    \ NetstringParseError(self._MISSING_COMMA)\n\n    def _handleParseError(self):\n\
    \        \"\"\"\n        Terminates the connection and sets the flag C{self.brokenPeer}.\n\
    \        \"\"\"\n        self.transport.loseConnection()\n        self.brokenPeer\
    \ = 1\n\n\nclass LineOnlyReceiver(protocol.Protocol):\n    \"\"\"\n    A protocol\
    \ that receives only lines.\n\n    This is purely a speed optimisation over LineReceiver,\
    \ for the\n    cases that raw mode is known to be unnecessary.\n\n    @cvar delimiter:\
    \ The line-ending delimiter to use. By default this is\n                     C{b'\\\
    \\r\\\\n'}.\n    @cvar MAX_LENGTH: The maximum length of a line to allow (If a\n\
    \                      sent line is longer than this, the connection is dropped).\n\
    \                      Default is 16384.\n    \"\"\"\n\n    _buffer = b\"\"\n\
    \    delimiter = b\"\\r\\n\"\n    MAX_LENGTH = 16384\n\n    def dataReceived(self,\
    \ data):\n        \"\"\"\n        Translates bytes into lines, and calls lineReceived.\n\
    \        \"\"\"\n        lines = (self._buffer + data).split(self.delimiter)\n\
    \        self._buffer = lines.pop(-1)\n        for line in lines:\n          \
    \  if self.transport.disconnecting:\n                # this is necessary because\
    \ the transport may be told to lose\n                # the connection by a line\
    \ within a larger packet, and it is\n                # important to disregard\
    \ all the lines in that packet following\n                # the one that told\
    \ it to close.\n                return\n            if len(line) > self.MAX_LENGTH:\n\
    \                return self.lineLengthExceeded(line)\n            else:\n   \
    \             self.lineReceived(line)\n        if len(self._buffer) > self.MAX_LENGTH:\n\
    \            return self.lineLengthExceeded(self._buffer)\n\n    def lineReceived(self,\
    \ line):\n        \"\"\"\n        Override this for when each line is received.\n\
    \n        @param line: The line which was received with the delimiter removed.\n\
    \        @type line: C{bytes}\n        \"\"\"\n        raise NotImplementedError\n\
    \n    def sendLine(self, line):\n        \"\"\"\n        Sends a line to the other\
    \ end of the connection.\n\n        @param line: The line to send, not including\
    \ the delimiter.\n        @type line: C{bytes}\n        \"\"\"\n        return\
    \ self.transport.writeSequence((line, self.delimiter))\n\n    def lineLengthExceeded(self,\
    \ line):\n        \"\"\"\n        Called when the maximum line length has been\
    \ reached.\n        Override if it needs to be dealt with in some special way.\n\
    \        \"\"\"\n        return self.transport.loseConnection()\n\n\nclass _PauseableMixin:\n\
    \    paused = False\n\n    def pauseProducing(self):\n        self.paused = True\n\
    \        self.transport.pauseProducing()\n\n    def resumeProducing(self):\n \
    \       self.paused = False\n        self.transport.resumeProducing()\n      \
    \  self.dataReceived(b\"\")\n\n    def stopProducing(self):\n        self.paused\
    \ = True\n        self.transport.stopProducing()\n\n\nclass LineReceiver(protocol.Protocol,\
    \ _PauseableMixin):\n    \"\"\"\n    A protocol that receives lines and/or raw\
    \ data, depending on mode.\n\n    In line mode, each line that's received becomes\
    \ a callback to\n    L{lineReceived}.  In raw data mode, each chunk of raw data\
    \ becomes a\n    callback to L{LineReceiver.rawDataReceived}.\n    The L{setLineMode}\
    \ and L{setRawMode} methods switch between the two modes.\n\n    This is useful\
    \ for line-oriented protocols such as IRC, HTTP, POP, etc.\n\n    @cvar delimiter:\
    \ The line-ending delimiter to use. By default this is\n                     C{b'\\\
    \\r\\\\n'}.\n    @cvar MAX_LENGTH: The maximum length of a line to allow (If a\n\
    \                      sent line is longer than this, the connection is dropped).\n\
    \                      Default is 16384.\n    \"\"\"\n\n    line_mode = 1\n  \
    \  _buffer = b\"\"\n    _busyReceiving = False\n    delimiter = b\"\\r\\n\"\n\
    \    MAX_LENGTH = 16384\n\n    def clearLineBuffer(self):\n        \"\"\"\n  \
    \      Clear buffered data.\n\n        @return: All of the cleared buffered data.\n\
    \        @rtype: C{bytes}\n        \"\"\"\n        b, self._buffer = self._buffer,\
    \ b\"\"\n        return b\n\n    def dataReceived(self, data):\n        \"\"\"\
    \n        Protocol.dataReceived.\n        Translates bytes into lines, and calls\
    \ lineReceived (or\n        rawDataReceived, depending on mode.)\n        \"\"\
    \"\n        if self._busyReceiving:\n            self._buffer += data\n      \
    \      return\n\n        try:\n            self._busyReceiving = True\n      \
    \      self._buffer += data\n            while self._buffer and not self.paused:\n\
    \                if self.line_mode:\n                    try:\n              \
    \          line, self._buffer = self._buffer.split(self.delimiter, 1)\n      \
    \              except ValueError:\n                        if len(self._buffer)\
    \ >= (self.MAX_LENGTH + len(self.delimiter)):\n                            line,\
    \ self._buffer = self._buffer, b\"\"\n                            return self.lineLengthExceeded(line)\n\
    \                        return\n                    else:\n                 \
    \       lineLength = len(line)\n                        if lineLength > self.MAX_LENGTH:\n\
    \                            exceeded = line + self.delimiter + self._buffer\n\
    \                            self._buffer = b\"\"\n                          \
    \  return self.lineLengthExceeded(exceeded)\n                        why = self.lineReceived(line)\n\
    \                        if why or self.transport and self.transport.disconnecting:\n\
    \                            return why\n                else:\n             \
    \       data = self._buffer\n                    self._buffer = b\"\"\n      \
    \              why = self.rawDataReceived(data)\n                    if why:\n\
    \                        return why\n        finally:\n            self._busyReceiving\
    \ = False\n\n    def setLineMode(self, extra=b\"\"):\n        \"\"\"\n       \
    \ Sets the line-mode of this receiver.\n\n        If you are calling this from\
    \ a rawDataReceived callback,\n        you can pass in extra unhandled data, and\
    \ that data will\n        be parsed for lines.  Further data received will be\
    \ sent\n        to lineReceived rather than rawDataReceived.\n\n        Do not\
    \ pass extra data if calling this function from\n        within a lineReceived\
    \ callback.\n        \"\"\"\n        self.line_mode = 1\n        if extra:\n \
    \           return self.dataReceived(extra)\n\n    def setRawMode(self):\n   \
    \     \"\"\"\n        Sets the raw mode of this receiver.\n        Further data\
    \ received will be sent to rawDataReceived rather\n        than lineReceived.\n\
    \        \"\"\"\n        self.line_mode = 0\n\n    def rawDataReceived(self, data):\n\
    \        \"\"\"\n        Override this for when raw data is received.\n      \
    \  \"\"\"\n        raise NotImplementedError\n\n    def lineReceived(self, line):\n\
    \        \"\"\"\n        Override this for when each line is received.\n\n   \
    \     @param line: The line which was received with the delimiter removed.\n \
    \       @type line: C{bytes}\n        \"\"\"\n        raise NotImplementedError\n\
    \n    def sendLine(self, line):\n        \"\"\"\n        Sends a line to the other\
    \ end of the connection.\n\n        @param line: The line to send, not including\
    \ the delimiter.\n        @type line: C{bytes}\n        \"\"\"\n        return\
    \ self.transport.write(line + self.delimiter)\n\n    def lineLengthExceeded(self,\
    \ line):\n        \"\"\"\n        Called when the maximum line length has been\
    \ reached.\n        Override if it needs to be dealt with in some special way.\n\
    \n        The argument 'line' contains the remainder of the buffer, starting\n\
    \        with (at least some part) of the line which is too long. This may\n \
    \       be more than one line, or may be only the initial portion of the\n   \
    \     line.\n        \"\"\"\n        return self.transport.loseConnection()\n\n\
    \nclass StringTooLongError(AssertionError):\n    \"\"\"\n    Raised when trying\
    \ to send a string too long for a length prefixed\n    protocol.\n    \"\"\"\n\
    \n\nclass _RecvdCompatHack:\n    \"\"\"\n    Emulates the to-be-deprecated C{IntNStringReceiver.recvd}\
    \ attribute.\n\n    The C{recvd} attribute was where the working buffer for buffering\
    \ and\n    parsing netstrings was kept.  It was updated each time new data arrived\
    \ and\n    each time some of that data was parsed and delivered to application\
    \ code.\n    The piecemeal updates to its string value were expensive and have\
    \ been\n    removed from C{IntNStringReceiver} in the normal case.  However, for\n\
    \    applications directly reading this attribute, this descriptor restores that\n\
    \    behavior.  It only copies the working buffer when necessary (ie, when\n \
    \   accessed).  This avoids the cost for applications not using the data.\n\n\
    \    This is a custom descriptor rather than a property, because we still need\n\
    \    the default __set__ behavior in both new-style and old-style subclasses.\n\
    \    \"\"\"\n\n    def __get__(self, oself, type=None):\n        return oself._unprocessed[oself._compatibilityOffset\
    \ :]\n\n\nclass IntNStringReceiver(protocol.Protocol, _PauseableMixin):\n    \"\
    \"\"\n    Generic class for length prefixed protocols.\n\n    @ivar _unprocessed:\
    \ bytes received, but not yet broken up into messages /\n        sent to stringReceived.\
    \  _compatibilityOffset must be updated when this\n        value is updated so\
    \ that the C{recvd} attribute can be generated\n        correctly.\n    @type\
    \ _unprocessed: C{bytes}\n\n    @ivar structFormat: format used for struct packing/unpacking.\
    \ Define it in\n        subclass.\n    @type structFormat: C{str}\n\n    @ivar\
    \ prefixLength: length of the prefix, in bytes. Define it in subclass,\n     \
    \   using C{struct.calcsize(structFormat)}\n    @type prefixLength: C{int}\n\n\
    \    @ivar _compatibilityOffset: the offset within C{_unprocessed} to the next\n\
    \        message to be parsed. (used to generate the recvd attribute)\n    @type\
    \ _compatibilityOffset: C{int}\n    \"\"\"\n\n    MAX_LENGTH = 99999\n    _unprocessed\
    \ = b\"\"\n    _compatibilityOffset = 0\n\n    # Backwards compatibility support\
    \ for applications which directly touch the\n    # \"internal\" parse buffer.\n\
    \    recvd = _RecvdCompatHack()\n\n    def stringReceived(self, string):\n   \
    \     \"\"\"\n        Override this for notification when each complete string\
    \ is received.\n\n        @param string: The complete string which was received\
    \ with all\n            framing (length prefix, etc) removed.\n        @type string:\
    \ C{bytes}\n        \"\"\"\n        raise NotImplementedError\n\n    def lengthLimitExceeded(self,\
    \ length):\n        \"\"\"\n        Callback invoked when a length prefix greater\
    \ than C{MAX_LENGTH} is\n        received.  The default implementation disconnects\
    \ the transport.\n        Override this.\n\n        @param length: The length\
    \ prefix which was received.\n        @type length: C{int}\n        \"\"\"\n \
    \       self.transport.loseConnection()\n\n    def dataReceived(self, data):\n\
    \        \"\"\"\n        Convert int prefixed strings into calls to stringReceived.\n\
    \        \"\"\"\n        # Try to minimize string copying (via slices) by keeping\
    \ one buffer\n        # containing all the data we have so far and a separate\
    \ offset into that\n        # buffer.\n        alldata = self._unprocessed + data\n\
    \        currentOffset = 0\n        prefixLength = self.prefixLength\n       \
    \ fmt = self.structFormat\n        self._unprocessed = alldata\n\n        while\
    \ len(alldata) >= (currentOffset + prefixLength) and not self.paused:\n      \
    \      messageStart = currentOffset + prefixLength\n            (length,) = unpack(fmt,\
    \ alldata[currentOffset:messageStart])\n            if length > self.MAX_LENGTH:\n\
    \                self._unprocessed = alldata\n                self._compatibilityOffset\
    \ = currentOffset\n                self.lengthLimitExceeded(length)\n        \
    \        return\n            messageEnd = messageStart + length\n            if\
    \ len(alldata) < messageEnd:\n                break\n\n            # Here we have\
    \ to slice the working buffer so we can send just the\n            # netstring\
    \ into the stringReceived callback.\n            packet = alldata[messageStart:messageEnd]\n\
    \            currentOffset = messageEnd\n            self._compatibilityOffset\
    \ = currentOffset\n            self.stringReceived(packet)\n\n            # Check\
    \ to see if the backwards compat \"recvd\" attribute got written\n           \
    \ # to by application code.  If so, drop the current data buffer and\n       \
    \     # switch to the new buffer given by that attribute's value.\n          \
    \  if \"recvd\" in self.__dict__:\n                alldata = self.__dict__.pop(\"\
    recvd\")\n                self._unprocessed = alldata\n                self._compatibilityOffset\
    \ = currentOffset = 0\n                if alldata:\n                    continue\n\
    \                return\n\n        # Slice off all the data that has been processed,\
    \ avoiding holding onto\n        # memory to store it, and update the compatibility\
    \ attributes to reflect\n        # that change.\n        self._unprocessed = alldata[currentOffset:]\n\
    \        self._compatibilityOffset = 0\n\n    def sendString(self, string):\n\
    \        \"\"\"\n        Send a prefixed string to the other end of the connection.\n\
    \n        @param string: The string to send.  The necessary framing (length\n\
    \            prefix, etc) will be added.\n        @type string: C{bytes}\n   \
    \     \"\"\"\n        if len(string) >= 2 ** (8 * self.prefixLength):\n      \
    \      raise StringTooLongError(\n                \"Try to send %s bytes whereas\
    \ maximum is %s\"\n                % (len(string), 2 ** (8 * self.prefixLength))\n\
    \            )\n        self.transport.write(pack(self.structFormat, len(string))\
    \ + string)\n\n\nclass Int32StringReceiver(IntNStringReceiver):\n    \"\"\"\n\
    \    A receiver for int32-prefixed strings.\n\n    An int32 string is a string\
    \ prefixed by 4 bytes, the 32-bit length of\n    the string encoded in network\
    \ byte order.\n\n    This class publishes the same interface as NetstringReceiver.\n\
    \    \"\"\"\n\n    structFormat = \"!I\"\n    prefixLength = calcsize(structFormat)\n\
    \n\nclass Int16StringReceiver(IntNStringReceiver):\n    \"\"\"\n    A receiver\
    \ for int16-prefixed strings.\n\n    An int16 string is a string prefixed by 2\
    \ bytes, the 16-bit length of\n    the string encoded in network byte order.\n\
    \n    This class publishes the same interface as NetstringReceiver.\n    \"\"\"\
    \n\n    structFormat = \"!H\"\n    prefixLength = calcsize(structFormat)\n\n\n\
    class Int8StringReceiver(IntNStringReceiver):\n    \"\"\"\n    A receiver for\
    \ int8-prefixed strings.\n\n    An int8 string is a string prefixed by 1 byte,\
    \ the 8-bit length of\n    the string.\n\n    This class publishes the same interface\
    \ as NetstringReceiver.\n    \"\"\"\n\n    structFormat = \"!B\"\n    prefixLength\
    \ = calcsize(structFormat)\n\n\nclass StatefulStringProtocol:\n    \"\"\"\n  \
    \  A stateful string protocol.\n\n    This is a mixin for string protocols (L{Int32StringReceiver},\n\
    \    L{NetstringReceiver}) which translates L{stringReceived} into a callback\n\
    \    (prefixed with C{'proto_'}) depending on state.\n\n    The state C{'done'}\
    \ is special; if a C{proto_*} method returns it, the\n    connection will be closed\
    \ immediately.\n\n    @ivar state: Current state of the protocol. Defaults to\
    \ C{'init'}.\n    @type state: C{str}\n    \"\"\"\n\n    state = \"init\"\n\n\
    \    def stringReceived(self, string):\n        \"\"\"\n        Choose a protocol\
    \ phase function and call it.\n\n        Call back to the appropriate protocol\
    \ phase; this begins with\n        the function C{proto_init} and moves on to\
    \ C{proto_*} depending on\n        what each C{proto_*} function returns.  (For\
    \ example, if\n        C{self.proto_init} returns 'foo', then C{self.proto_foo}\
    \ will be the\n        next function called when a protocol message is received.\n\
    \        \"\"\"\n        try:\n            pto = \"proto_\" + self.state\n   \
    \         statehandler = getattr(self, pto)\n        except AttributeError:\n\
    \            log.msg(\"callback\", self.state, \"not found\")\n        else:\n\
    \            self.state = statehandler(string)\n            if self.state == \"\
    done\":\n                self.transport.loseConnection()\n\n\n@implementer(interfaces.IProducer)\n\
    class FileSender:\n    \"\"\"\n    A producer that sends the contents of a file\
    \ to a consumer.\n\n    This is a helper for protocols that, at some point, will\
    \ take a\n    file-like object, read its contents, and write them out to the network,\n\
    \    optionally performing some transformation on the bytes in between.\n    \"\
    \"\"\n\n    CHUNK_SIZE = 2**14\n\n    lastSent = \"\"\n    deferred = None\n\n\
    \    def beginFileTransfer(self, file, consumer, transform=None):\n        \"\"\
    \"\n        Begin transferring a file\n\n        @type file: Any file-like object\n\
    \        @param file: The file object to read data from\n\n        @type consumer:\
    \ Any implementor of IConsumer\n        @param consumer: The object to write data\
    \ to\n\n        @param transform: A callable taking one string argument and returning\n\
    \        the same.  All bytes read from the file are passed through this before\n\
    \        being written to the consumer.\n\n        @rtype: C{Deferred}\n     \
    \   @return: A deferred whose callback will be invoked when the file has\n   \
    \     been completely written to the consumer. The last byte written to the\n\
    \        consumer is passed to the callback.\n        \"\"\"\n        self.file\
    \ = file\n        self.consumer = consumer\n        self.transform = transform\n\
    \n        self.deferred = deferred = defer.Deferred()\n        self.consumer.registerProducer(self,\
    \ False)\n        return deferred\n\n    def resumeProducing(self):\n        chunk\
    \ = \"\"\n        if self.file:\n            chunk = self.file.read(self.CHUNK_SIZE)\n\
    \        if not chunk:\n            self.file = None\n            self.consumer.unregisterProducer()\n\
    \            if self.deferred:\n                self.deferred.callback(self.lastSent)\n\
    \                self.deferred = None\n            return\n\n        if self.transform:\n\
    \            chunk = self.transform(chunk)\n        self.consumer.write(chunk)\n\
    \        self.lastSent = chunk[-1:]\n\n    def pauseProducing(self):\n       \
    \ pass\n\n    def stopProducing(self):\n        if self.deferred:\n          \
    \  self.deferred.errback(Exception(\"Consumer asked us to stop producing\"))\n\
    \            self.deferred = None\n\n\n### Dependency File: compat.py\n# -*- test-case-name:\
    \ twisted.test.test_compat -*-\n#\n# Copyright (c) Twisted Matrix Laboratories.\n\
    # See LICENSE for details.\n\n\n\"\"\"\nCompatibility module to provide backwards\
    \ compatibility for useful Python\nfeatures.\n\nThis is mainly for use of internal\
    \ Twisted code. We encourage you to use\nthe latest version of Python directly\
    \ from your code, if possible.\n\n@var unicode: The type of Unicode strings, C{unicode}\
    \ on Python 2 and C{str}\n    on Python 3.\n\n@var NativeStringIO: An in-memory\
    \ file-like object that operates on the native\n    string type (bytes in Python\
    \ 2, unicode in Python 3).\n\n@var urllib_parse: a URL-parsing module (urlparse\
    \ on Python 2, urllib.parse on\n    Python 3)\n\"\"\"\n\n\nimport inspect\nimport\
    \ os\nimport platform\nimport socket\nimport urllib.parse as urllib_parse\nfrom\
    \ collections.abc import Sequence\nfrom functools import reduce\nfrom html import\
    \ escape\nfrom http import cookiejar as cookielib\nfrom io import IOBase, StringIO\
    \ as NativeStringIO, TextIOBase\nfrom sys import intern\nfrom types import FrameType,\
    \ MethodType as _MethodType\nfrom typing import Any, AnyStr, cast\nfrom urllib.parse\
    \ import quote as urlquote, unquote as urlunquote\n\nfrom incremental import Version\n\
    \nfrom twisted.python.deprecate import deprecated, deprecatedModuleAttribute\n\
    \nif platform.python_implementation() == \"PyPy\":\n    _PYPY = True\nelse:\n\
    \    _PYPY = False\n\nFileType = IOBase\ndeprecatedModuleAttribute(\n    Version(\"\
    Twisted\", 21, 2, 0),\n    \"Obsolete alias for io.IOBase\",\n    __name__,\n\
    \    \"FileType\",\n)\n\nfrozenset = frozenset\ndeprecatedModuleAttribute(\n \
    \   Version(\"Twisted\", 21, 2, 0),\n    \"Obsolete alias for frozenset builtin\
    \ type\",\n    __name__,\n    \"frozenset\",\n)\n\nInstanceType = object\ndeprecatedModuleAttribute(\n\
    \    Version(\"Twisted\", 21, 2, 0),\n    \"Old-style classes don't exist in Python\
    \ 3\",\n    __name__,\n    \"InstanceType\",\n)\n\nizip = zip\ndeprecatedModuleAttribute(\n\
    \    Version(\"Twisted\", 21, 2, 0),\n    \"Obsolete alias for zip() builtin\"\
    ,\n    __name__,\n    \"izip\",\n)\n\nlong = int\ndeprecatedModuleAttribute(\n\
    \    Version(\"Twisted\", 21, 2, 0),\n    \"Obsolete alias for int builtin type\"\
    ,\n    __name__,\n    \"long\",\n)\n\nrange = range\ndeprecatedModuleAttribute(\n\
    \    Version(\"Twisted\", 21, 2, 0),\n    \"Obsolete alias for range() builtin\"\
    ,\n    __name__,\n    \"range\",\n)\n\nraw_input = input\ndeprecatedModuleAttribute(\n\
    \    Version(\"Twisted\", 21, 2, 0),\n    \"Obsolete alias for input() builtin\"\
    ,\n    __name__,\n    \"raw_input\",\n)\n\nset = set\ndeprecatedModuleAttribute(\n\
    \    Version(\"Twisted\", 21, 2, 0),\n    \"Obsolete alias for set builtin type\"\
    ,\n    __name__,\n    \"set\",\n)\n\nStringType = str\ndeprecatedModuleAttribute(\n\
    \    Version(\"Twisted\", 21, 2, 0),\n    \"Obsolete alias for str builtin type\"\
    ,\n    __name__,\n    \"StringType\",\n)\n\nunichr = chr\ndeprecatedModuleAttribute(\n\
    \    Version(\"Twisted\", 21, 2, 0),\n    \"Obsolete alias for chr() builtin\"\
    ,\n    __name__,\n    \"unichr\",\n)\n\nunicode = str\ndeprecatedModuleAttribute(\n\
    \    Version(\"Twisted\", 21, 2, 0),\n    \"Obsolete alias for str builtin type\"\
    ,\n    __name__,\n    \"unicode\",\n)\n\nxrange = range\ndeprecatedModuleAttribute(\n\
    \    Version(\"Twisted\", 21, 2, 0),\n    \"Obsolete alias for range() builtin\"\
    ,\n    __name__,\n    \"xrange\",\n)\n\n\n@deprecated(Version(\"Twisted\", 21,\
    \ 2, 0), replacement=\"d.items()\")\ndef iteritems(d):\n    \"\"\"\n    Return\
    \ an iterable of the items of C{d}.\n\n    @type d: L{dict}\n    @rtype: iterable\n\
    \    \"\"\"\n    return d.items()\n\n\n@deprecated(Version(\"Twisted\", 21, 2,\
    \ 0), replacement=\"d.values()\")\ndef itervalues(d):\n    \"\"\"\n    Return\
    \ an iterable of the values of C{d}.\n\n    @type d: L{dict}\n    @rtype: iterable\n\
    \    \"\"\"\n    return d.values()\n\n\n@deprecated(Version(\"Twisted\", 21, 2,\
    \ 0), replacement=\"list(d.items())\")\ndef items(d):\n    \"\"\"\n    Return\
    \ a list of the items of C{d}.\n\n    @type d: L{dict}\n    @rtype: L{list}\n\
    \    \"\"\"\n    return list(d.items())\n\n\ndef currentframe(n: int = 0) -> FrameType:\n\
    \    \"\"\"\n    In Python 3, L{inspect.currentframe} does not take a stack-level\
    \ argument.\n    Restore that functionality from Python 2 so we don't have to\
    \ re-implement\n    the C{f_back}-walking loop in places where it's called.\n\n\
    \    @param n: The number of stack levels above the caller to walk.\n\n    @return:\
    \ a frame, n levels up the stack from the caller.\n    \"\"\"\n    f = inspect.currentframe()\n\
    \    for x in range(n + 1):\n        assert f is not None\n        f = f.f_back\n\
    \    assert f is not None\n    return f\n\n\ndef execfile(filename, globals, locals=None):\n\
    \    \"\"\"\n    Execute a Python script in the given namespaces.\n\n    Similar\
    \ to the execfile builtin, but a namespace is mandatory, partly\n    because that's\
    \ a sensible thing to require, and because otherwise we'd\n    have to do some\
    \ frame hacking.\n\n    This is a compatibility implementation for Python 3 porting,\
    \ to avoid the\n    use of the deprecated builtin C{execfile} function.\n    \"\
    \"\"\n    if locals is None:\n        locals = globals\n    with open(filename,\
    \ \"rb\") as fin:\n        source = fin.read()\n    code = compile(source, filename,\
    \ \"exec\")\n    exec(code, globals, locals)\n\n\n# type note: Can't find a Comparable\
    \ type, despite\n# https://github.com/python/typing/issues/59\ndef cmp(a: object,\
    \ b: object) -> int:\n    \"\"\"\n    Compare two objects.\n\n    Returns a negative\
    \ number if C{a < b}, zero if they are equal, and a\n    positive number if C{a\
    \ > b}.\n    \"\"\"\n    if a < b:  # type: ignore[operator]\n        return -1\n\
    \    elif a == b:\n        return 0\n    else:\n        return 1\n\n\ndef comparable(klass):\n\
    \    \"\"\"\n    Class decorator that ensures support for the special C{__cmp__}\
    \ method.\n\n    C{__eq__}, C{__lt__}, etc. methods are added to the class, relying\
    \ on\n    C{__cmp__} to implement their comparisons.\n    \"\"\"\n\n    def __eq__(self:\
    \ Any, other: object) -> bool:\n        c = cast(bool, self.__cmp__(other))\n\
    \        if c is NotImplemented:\n            return c\n        return c == 0\n\
    \n    def __ne__(self: Any, other: object) -> bool:\n        c = cast(bool, self.__cmp__(other))\n\
    \        if c is NotImplemented:\n            return c\n        return c != 0\n\
    \n    def __lt__(self: Any, other: object) -> bool:\n        c = cast(bool, self.__cmp__(other))\n\
    \        if c is NotImplemented:\n            return c\n        return c < 0\n\
    \n    def __le__(self: Any, other: object) -> bool:\n        c = cast(bool, self.__cmp__(other))\n\
    \        if c is NotImplemented:\n            return c\n        return c <= 0\n\
    \n    def __gt__(self: Any, other: object) -> bool:\n        c = cast(bool, self.__cmp__(other))\n\
    \        if c is NotImplemented:\n            return c\n        return c > 0\n\
    \n    def __ge__(self: Any, other: object) -> bool:\n        c = cast(bool, self.__cmp__(other))\n\
    \        if c is NotImplemented:\n            return c\n        return c >= 0\n\
    \n    klass.__lt__ = __lt__\n    klass.__gt__ = __gt__\n    klass.__le__ = __le__\n\
    \    klass.__ge__ = __ge__\n    klass.__eq__ = __eq__\n    klass.__ne__ = __ne__\n\
    \    return klass\n\n\ndef ioType(fileIshObject, default=str):\n    \"\"\"\n \
    \   Determine the type which will be returned from the given file object's\n \
    \   read() and accepted by its write() method as an argument.\n\n    In other\
    \ words, determine whether the given file is 'opened in text mode'.\n\n    @param\
    \ fileIshObject: Any object, but ideally one which resembles a file.\n    @type\
    \ fileIshObject: L{object}\n\n    @param default: A default value to return when\
    \ the type of C{fileIshObject}\n        cannot be determined.\n    @type default:\
    \ L{type}\n\n    @return: There are 3 possible return values:\n\n            1.\
    \ L{str}, if the file is unambiguously opened in text mode.\n\n            2.\
    \ L{bytes}, if the file is unambiguously opened in binary mode.\n\n          \
    \  3. The C{default} parameter, if the given type is not understood.\n\n    @rtype:\
    \ L{type}\n    \"\"\"\n    if isinstance(fileIshObject, TextIOBase):\n       \
    \ # If it's for text I/O, then it's for text I/O.\n        return str\n    if\
    \ isinstance(fileIshObject, IOBase):\n        # If it's for I/O but it's _not_\
    \ for text I/O, it's for bytes I/O.\n        return bytes\n    encoding = getattr(fileIshObject,\
    \ \"encoding\", None)\n    import codecs\n\n    if isinstance(fileIshObject, (codecs.StreamReader,\
    \ codecs.StreamWriter)):\n        # On StreamReaderWriter, the 'encoding' attribute\
    \ has special meaning;\n        # it is unambiguously text.\n        if encoding:\n\
    \            return str\n        else:\n            return bytes\n    return default\n\
    \n\ndef nativeString(s: AnyStr) -> str:\n    \"\"\"\n    Convert C{bytes} or C{str}\
    \ to C{str} type, using ASCII encoding if\n    conversion is necessary.\n\n  \
    \  @raise UnicodeError: The input string is not ASCII encodable/decodable.\n \
    \   @raise TypeError: The input is neither C{bytes} nor C{str}.\n    \"\"\"\n\
    \    if not isinstance(s, (bytes, str)):\n        raise TypeError(\"%r is neither\
    \ bytes nor str\" % s)\n    if isinstance(s, bytes):\n        return s.decode(\"\
    ascii\")\n    else:\n        # Ensure we're limited to ASCII subset:\n       \
    \ s.encode(\"ascii\")\n    return s\n\n\ndef _matchingString(constantString, inputString):\n\
    \    \"\"\"\n    Some functions, such as C{os.path.join}, operate on string arguments\
    \ which\n    may be bytes or text, and wish to return a value of the same type.\
    \  In\n    those cases you may wish to have a string constant (in the case of\n\
    \    C{os.path.join}, that constant would be C{os.path.sep}) involved in the\n\
    \    parsing or processing, that must be of a matching type in order to use\n\
    \    string operations on it.  L{_matchingString} will take a constant string\n\
    \    (either L{bytes} or L{str}) and convert it to the same type as the\n    input\
    \ string.  C{constantString} should contain only characters from ASCII;\n    to\
    \ ensure this, it will be encoded or decoded regardless.\n\n    @param constantString:\
    \ A string literal used in processing.\n    @type constantString: L{str} or L{bytes}\n\
    \n    @param inputString: A byte string or text string provided by the user.\n\
    \    @type inputString: L{str} or L{bytes}\n\n    @return: C{constantString} converted\
    \ into the same type as C{inputString}\n    @rtype: the type of C{inputString}\n\
    \    \"\"\"\n    if isinstance(constantString, bytes):\n        otherType = constantString.decode(\"\
    ascii\")\n    else:\n        otherType = constantString.encode(\"ascii\")\n  \
    \  if type(constantString) == type(inputString):\n        return constantString\n\
    \    else:\n        return otherType\n\n\n@deprecated(\n    Version(\"Twisted\"\
    , 21, 2, 0),\n    replacement=\"raise exception.with_traceback(traceback)\",\n\
    )\ndef reraise(exception, traceback):\n    \"\"\"\n    Re-raise an exception,\
    \ with an optional traceback.\n\n    Re-raised exceptions will be mutated, with\
    \ their C{__traceback__} attribute\n    being set.\n\n    @param exception: The\
    \ exception instance.\n    @param traceback: The traceback to use, or L{None}\
    \ indicating a new\n    traceback.\n    \"\"\"\n    raise exception.with_traceback(traceback)\n\
    \n\ndef iterbytes(originalBytes):\n    \"\"\"\n    Return an iterable wrapper\
    \ for a C{bytes} object that provides the behavior\n    of iterating over C{bytes}\
    \ on Python 2.\n\n    In particular, the results of iteration are the individual\
    \ bytes (rather\n    than integers as on Python 3).\n\n    @param originalBytes:\
    \ A C{bytes} object that will be wrapped.\n    \"\"\"\n    for i in range(len(originalBytes)):\n\
    \        yield originalBytes[i : i + 1]\n\n\n@deprecated(Version(\"Twisted\",\
    \ 21, 2, 0), replacement=\"b'%d'\")\ndef intToBytes(i: int) -> bytes:\n    \"\"\
    \"\n    Convert the given integer into C{bytes}, as ASCII-encoded Arab numeral.\n\
    \n    @param i: The C{int} to convert to C{bytes}.\n    @rtype: C{bytes}\n   \
    \ \"\"\"\n    return b\"%d\" % (i,)\n\n\ndef lazyByteSlice(object, offset=0, size=None):\n\
    \    \"\"\"\n    Return a memory view of the given bytes-like object.\n\n    If\
    \ an offset is given, the view starts at that offset. If a size is\n    given,\
    \ the view will only be of that length.\n\n    @param object: C{bytes} to be sliced.\n\
    \n    @param offset: C{int}, starting index of view.\n\n    @param size: Optional,\
    \ if an C{int} is given limit the length of the view\n        to this size.\n\
    \    \"\"\"\n    view = memoryview(object)\n    if size is None:\n        return\
    \ view[offset:]\n    else:\n        return view[offset : (offset + size)]\n\n\n\
    def networkString(s: str) -> bytes:\n    \"\"\"\n    Convert a string to L{bytes}\
    \ using ASCII encoding.\n\n    This is useful for sending text-like bytes that\
    \ are constructed using\n    string interpolation.  For example::\n\n        networkString(\"\
    Hello %d\" % (n,))\n\n    @param s: A string to convert to bytes.\n    @type s:\
    \ L{str}\n\n    @raise UnicodeError: The input string is not ASCII encodable.\n\
    \    @raise TypeError: The input is not L{str}.\n\n    @rtype: L{bytes}\n    \"\
    \"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Can only convert\
    \ strings to bytes\")\n    return s.encode(\"ascii\")\n\n\n@deprecated(Version(\"\
    Twisted\", 21, 2, 0), replacement=\"os.environb\")\ndef bytesEnviron():\n    \"\
    \"\"\n    Return a L{dict} of L{os.environ} where all text-strings are encoded\
    \ into\n    L{bytes}.\n\n    This function is POSIX only; environment variables\
    \ are always text strings\n    on Windows.\n    \"\"\"\n    encodekey = os.environ.encodekey\n\
    \    encodevalue = os.environ.encodevalue\n\n    return {encodekey(x): encodevalue(y)\
    \ for x, y in os.environ.items()}\n\n\ndef _constructMethod(cls, name, self):\n\
    \    \"\"\"\n    Construct a bound method.\n\n    @param cls: The class that the\
    \ method should be bound to.\n    @type cls: L{type}\n\n    @param name: The name\
    \ of the method.\n    @type name: native L{str}\n\n    @param self: The object\
    \ that the method is bound to.\n    @type self: any object\n\n    @return: a bound\
    \ method\n    @rtype: L{_MethodType}\n    \"\"\"\n    func = cls.__dict__[name]\n\
    \    return _MethodType(func, self)\n\n\ndef _pypy3BlockingHack():\n    \"\"\"\
    \n    Work around U{https://foss.heptapod.net/pypy/pypy/-/issues/3051}\n    by\
    \ replacing C{socket.fromfd} with a more conservative version.\n    \"\"\"\n \
    \   try:\n        from fcntl import F_GETFL, F_SETFL, fcntl\n    except ImportError:\n\
    \        return\n    if not _PYPY:\n        return\n\n    def fromFDWithoutModifyingFlags(fd,\
    \ family, type, proto=None):\n        passproto = [proto] * (proto is not None)\n\
    \        flags = fcntl(fd, F_GETFL)\n        try:\n            return realFromFD(fd,\
    \ family, type, *passproto)\n        finally:\n            fcntl(fd, F_SETFL,\
    \ flags)\n\n    realFromFD = socket.fromfd\n    if realFromFD.__name__ == fromFDWithoutModifyingFlags.__name__:\n\
    \        return\n    socket.fromfd = fromFDWithoutModifyingFlags\n\n\n_pypy3BlockingHack()\n\
    \n\ndeprecatedModuleAttribute(\n    Version(\"Twisted\", 21, 2, 0),\n    \"Use\
    \ functools.reduce() directly\",\n    __name__,\n    \"reduce\",\n)\n\ndeprecatedModuleAttribute(\n\
    \    Version(\"Twisted\", 21, 2, 0),\n    \"Use io.StringIO directly\",\n    __name__,\n\
    \    \"NativeStringIO\",\n)\n\ndeprecatedModuleAttribute(\n    Version(\"Twisted\"\
    , 21, 2, 0),\n    \"Import urllib.parse directly\",\n    __name__,\n    \"urllib_parse\"\
    ,\n)\n\ndeprecatedModuleAttribute(\n    Version(\"Twisted\", 21, 2, 0), \"Use\
    \ html.escape directly\", __name__, \"escape\"\n)\n\ndeprecatedModuleAttribute(\n\
    \    Version(\"Twisted\", 21, 2, 0),\n    \"Use urllib.parse.quote() directly\"\
    ,\n    __name__,\n    \"urlquote\",\n)\n\ndeprecatedModuleAttribute(\n    Version(\"\
    Twisted\", 21, 2, 0),\n    \"Use urllib.parse.unquote() directly\",\n    __name__,\n\
    \    \"urlunquote\",\n)\n\ndeprecatedModuleAttribute(\n    Version(\"Twisted\"\
    , 21, 2, 0),\n    \"Use http.cookiejar directly\",\n    __name__,\n    \"cookielib\"\
    ,\n)\n\ndeprecatedModuleAttribute(\n    Version(\"Twisted\", 21, 2, 0), \"Use\
    \ sys.intern() directly\", __name__, \"intern\"\n)\n\ndeprecatedModuleAttribute(\n\
    \    Version(\"Twisted\", 21, 2, 0),\n    \"Use collections.abc.Sequence directly\"\
    ,\n    __name__,\n    \"Sequence\",\n)\n\n\n__all__ = [\n    \"reraise\",\n  \
    \  \"execfile\",\n    \"frozenset\",\n    \"reduce\",\n    \"set\",\n    \"cmp\"\
    ,\n    \"comparable\",\n    \"nativeString\",\n    \"NativeStringIO\",\n    \"\
    networkString\",\n    \"unicode\",\n    \"iterbytes\",\n    \"intToBytes\",\n\
    \    \"lazyByteSlice\",\n    \"StringType\",\n    \"InstanceType\",\n    \"FileType\"\
    ,\n    \"items\",\n    \"iteritems\",\n    \"itervalues\",\n    \"range\",\n \
    \   \"xrange\",\n    \"urllib_parse\",\n    \"bytesEnviron\",\n    \"escape\"\
    ,\n    \"urlquote\",\n    \"urlunquote\",\n    \"cookielib\",\n    \"intern\"\
    ,\n    \"unichr\",\n    \"raw_input\",\n    \"Sequence\",\n]\n\n\n### Dependency\
    \ File: defer.py\n# -*- test-case-name: twisted.test.test_defer -*-\n# Copyright\
    \ (c) Twisted Matrix Laboratories.\n# See LICENSE for details.\n\n\"\"\"\nSupport\
    \ for results that aren't immediately available.\n\nMaintainer: Glyph Lefkowitz\n\
    \"\"\"\nfrom __future__ import annotations\n\nimport inspect\nimport traceback\n\
    import warnings\nfrom abc import ABC, abstractmethod\nfrom asyncio import AbstractEventLoop,\
    \ Future, iscoroutine\nfrom contextvars import Context as _Context, copy_context\
    \ as _copy_context\nfrom enum import Enum\nfrom functools import wraps\nfrom sys\
    \ import exc_info, implementation\nfrom types import CoroutineType, GeneratorType,\
    \ MappingProxyType, TracebackType\nfrom typing import (\n    TYPE_CHECKING,\n\
    \    Any,\n    Awaitable,\n    Callable,\n    Coroutine,\n    Generator,\n   \
    \ Generic,\n    Iterable,\n    List,\n    Mapping,\n    NoReturn,\n    Optional,\n\
    \    Sequence,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    cast,\n \
    \   overload,\n)\n\nimport attr\nfrom incremental import Version\nfrom typing_extensions\
    \ import Concatenate, Literal, ParamSpec, Self\n\nfrom twisted.internet.interfaces\
    \ import IDelayedCall, IReactorTime\nfrom twisted.logger import Logger\nfrom twisted.python\
    \ import lockfile\nfrom twisted.python.compat import _PYPY, cmp, comparable\n\
    from twisted.python.deprecate import deprecated, deprecatedProperty, warnAboutFunction\n\
    from twisted.python.failure import Failure, _extraneous\n\nlog = Logger()\n\n\n\
    _T = TypeVar(\"_T\")\n_P = ParamSpec(\"_P\")\n\n# See use in _inlineCallbacks\
    \ for explanation and removal timeline.\n_oldPypyStack = _PYPY and implementation.version\
    \ < (7, 3, 14)\n\n\nclass AlreadyCalledError(Exception):\n    \"\"\"\n    This\
    \ error is raised when one of L{Deferred.callback} or L{Deferred.errback}\n  \
    \  is called after one of the two had already been called.\n    \"\"\"\n\n\nclass\
    \ CancelledError(Exception):\n    \"\"\"\n    This error is raised by default\
    \ when a L{Deferred} is cancelled.\n    \"\"\"\n\n\nclass TimeoutError(Exception):\n\
    \    \"\"\"\n    This error is raised by default when a L{Deferred} times out.\n\
    \    \"\"\"\n\n\nclass NotACoroutineError(TypeError):\n    \"\"\"\n    This error\
    \ is raised when a coroutine is expected and something else is\n    encountered.\n\
    \    \"\"\"\n\n\ndef logError(err: Failure) -> Failure:\n    \"\"\"\n    Log and\
    \ return failure.\n\n    This method can be used as an errback that passes the\
    \ failure on to the\n    next errback unmodified. Note that if this is the last\
    \ errback, and the\n    deferred gets garbage collected after being this errback\
    \ has been called,\n    the clean up code logs it again.\n    \"\"\"\n    log.failure(\"\
    \", err)\n    return err\n\n\ndef succeed(result: _T) -> \"Deferred[_T]\":\n \
    \   \"\"\"\n    Return a L{Deferred} that has already had C{.callback(result)}\
    \ called.\n\n    This is useful when you're writing synchronous code to an\n \
    \   asynchronous interface: i.e., some code is calling you expecting a\n    L{Deferred}\
    \ result, but you don't actually need to do anything\n    asynchronous. Just return\
    \ C{defer.succeed(theResult)}.\n\n    See L{fail} for a version of this function\
    \ that uses a failing\n    L{Deferred} rather than a successful one.\n\n    @param\
    \ result: The result to give to the Deferred's 'callback'\n           method.\n\
    \    \"\"\"\n    d: Deferred[_T] = Deferred()\n    # This violate abstraction\
    \ boundaries, so code that is not internal to\n    # Twisted shouldn't do it,\
    \ but it's a significant performance optimization:\n    d.result = result\n  \
    \  d.called = True\n    d._chainedTo = None\n    return d\n\n\ndef fail(result:\
    \ Optional[Union[Failure, BaseException]] = None) -> \"Deferred[Any]\":\n    \"\
    \"\"\n    Return a L{Deferred} that has already had C{.errback(result)} called.\n\
    \n    See L{succeed}'s docstring for rationale.\n\n    @param result: The same\
    \ argument that L{Deferred.errback} takes.\n\n    @raise NoCurrentExceptionError:\
    \ If C{result} is L{None} but there is no\n        current exception state.\n\
    \    \"\"\"\n    d: Deferred[Any] = Deferred()\n    d.errback(result)\n    return\
    \ d\n\n\ndef execute(\n    callable: Callable[_P, _T], *args: _P.args, **kwargs:\
    \ _P.kwargs\n) -> \"Deferred[_T]\":\n    \"\"\"\n    Create a L{Deferred} from\
    \ a callable and arguments.\n\n    Call the given function with the given arguments.\
    \  Return a L{Deferred}\n    which has been fired with its callback as the result\
    \ of that invocation\n    or its C{errback} with a L{Failure} for the exception\
    \ thrown.\n    \"\"\"\n    try:\n        result = callable(*args, **kwargs)\n\
    \    except BaseException:\n        return fail()\n    else:\n        return succeed(result)\n\
    \n\n@overload\ndef maybeDeferred(\n    f: Callable[_P, Deferred[_T]], *args: _P.args,\
    \ **kwargs: _P.kwargs\n) -> \"Deferred[_T]\":\n    ...\n\n\n@overload\ndef maybeDeferred(\n\
    \    f: Callable[_P, Coroutine[Deferred[Any], Any, _T]],\n    *args: _P.args,\n\
    \    **kwargs: _P.kwargs,\n) -> \"Deferred[_T]\":\n    ...\n\n\n@overload\ndef\
    \ maybeDeferred(\n    f: Callable[_P, _T], *args: _P.args, **kwargs: _P.kwargs\n\
    ) -> \"Deferred[_T]\":\n    ...\n\n\ndef maybeDeferred(\n    f: Callable[_P, Union[Deferred[_T],\
    \ Coroutine[Deferred[Any], Any, _T], _T]],\n    *args: _P.args,\n    **kwargs:\
    \ _P.kwargs,\n) -> \"Deferred[_T]\":\n    \"\"\"\n    Invoke a function that may\
    \ or may not return a L{Deferred} or coroutine.\n\n    Call the given function\
    \ with the given arguments.  Then:\n\n      - If the returned object is a L{Deferred},\
    \ return it.\n\n      - If the returned object is a L{Failure}, wrap it with L{fail}\
    \ and\n        return it.\n\n      - If the returned object is a L{types.CoroutineType},\
    \ wrap it with\n        L{Deferred.fromCoroutine} and return it.\n\n      - Otherwise,\
    \ wrap it in L{succeed} and return it.\n\n      - If an exception is raised, convert\
    \ it to a L{Failure}, wrap it in\n        L{fail}, and then return it.\n\n   \
    \ @param f: The callable to invoke\n    @param args: The arguments to pass to\
    \ C{f}\n    @param kwargs: The keyword arguments to pass to C{f}\n\n    @return:\
    \ The result of the function call, wrapped in a L{Deferred} if\n    necessary.\n\
    \    \"\"\"\n    try:\n        result = f(*args, **kwargs)\n    except BaseException:\n\
    \        return fail(Failure(captureVars=Deferred.debug))\n\n    if type(result)\
    \ in _DEFERRED_SUBCLASSES:\n        return result  # type: ignore[return-value]\n\
    \    elif isinstance(result, Failure):\n        return fail(result)\n    elif\
    \ type(result) is CoroutineType:\n        # A note on how we identify this case\
    \ ...\n        #\n        # inspect.iscoroutinefunction(f) should be the simplest\
    \ and easiest\n        # way to determine if we want to apply coroutine handling.\
    \  However,\n        # the value may be returned by a regular function that calls\
    \ a\n        # coroutine function and returns its result.  It would be confusing\
    \ if\n        # cases like this led to different handling of the coroutine (even\n\
    \        # though it is a mistake to have a regular function call a coroutine\n\
    \        # function to return its result - doing so immediately destroys a\n \
    \       # large part of the value of coroutine functions: that they can only\n\
    \        # have a coroutine result).\n        #\n        # There are many ways\
    \ we could inspect ``result`` to determine if it\n        # is a \"coroutine\"\
    \ but most of these are mistakes.  The goal is only\n        # to determine whether\
    \ the value came from ``async def`` or not\n        # because these are the only\
    \ values we're trying to handle with this\n        # case.  Such values always\
    \ have exactly one type: CoroutineType.\n        return Deferred.fromCoroutine(result)\n\
    \    else:\n        returned: _T = result  # type: ignore\n        return succeed(returned)\n\
    \n\n@deprecated(\n    Version(\"Twisted\", 17, 1, 0),\n    replacement=\"twisted.internet.defer.Deferred.addTimeout\"\
    ,\n)\ndef timeout(deferred: \"Deferred[object]\") -> None:\n    deferred.errback(Failure(TimeoutError(\"\
    Callback timed out\")))\n\n\ndef passthru(arg: _T) -> _T:\n    return arg\n\n\n\
    def _failthru(arg: Failure) -> Failure:\n    return arg\n\n\ndef setDebugging(on:\
    \ bool) -> None:\n    \"\"\"\n    Enable or disable L{Deferred} debugging.\n\n\
    \    When debugging is on, the call stacks from creation and invocation are\n\
    \    recorded, and added to any L{AlreadyCalledError}s we raise.\n    \"\"\"\n\
    \    Deferred.debug = bool(on)\n\n\ndef getDebugging() -> bool:\n    \"\"\"\n\
    \    Determine whether L{Deferred} debugging is enabled.\n    \"\"\"\n    return\
    \ Deferred.debug\n\n\ndef _cancelledToTimedOutError(value: _T, timeout: float)\
    \ -> _T:\n    \"\"\"\n    A default translation function that translates L{Failure}s\
    \ that are\n    L{CancelledError}s to L{TimeoutError}s.\n\n    @param value: Anything\n\
    \    @param timeout: The timeout\n\n    @raise TimeoutError: If C{value} is a\
    \ L{Failure} that is a L{CancelledError}.\n    @raise Exception: If C{value} is\
    \ a L{Failure} that is not a L{CancelledError},\n        it is re-raised.\n\n\
    \    @since: 16.5\n    \"\"\"\n    if isinstance(value, Failure):\n        value.trap(CancelledError)\n\
    \        raise TimeoutError(timeout, \"Deferred\")\n    return value\n\n\nclass\
    \ _Sentinel(Enum):\n    \"\"\"\n    @cvar _NO_RESULT:\n        The result used\
    \ to represent the fact that there is no result.\n        B{Never ever ever use\
    \ this as an actual result for a Deferred}.\n        You have been warned.\n \
    \   @cvar _CONTINUE:\n        A marker left in L{Deferred.callback}s to indicate\
    \ a Deferred chain.\n        Always accompanied by a Deferred instance in the\
    \ args tuple pointing at\n        the Deferred which is chained to the Deferred\
    \ which has this marker.\n    \"\"\"\n\n    _NO_RESULT = object()\n    _CONTINUE\
    \ = object()\n\n\n# Cache these values for use without the extra lookup in deferred\
    \ hot code paths\n_NO_RESULT = _Sentinel._NO_RESULT\n_CONTINUE = _Sentinel._CONTINUE\n\
    \n\n# type note: this should be Callable[[object, ...], object] but mypy doesn't\
    \ allow.\n#     Callable[[object], object] is next best, but disallows valid callback\
    \ signatures\nDeferredCallback = Callable[..., object]\n# type note: this should\
    \ be Callable[[Failure, ...], object] but mypy doesn't allow.\n#     Callable[[Failure],\
    \ object] is next best, but disallows valid callback signatures\nDeferredErrback\
    \ = Callable[..., object]\n\n_CallbackOrderedArguments = Tuple[object, ...]\n\
    _CallbackKeywordArguments = Mapping[str, object]\n_CallbackChain = Tuple[\n  \
    \  Tuple[\n        Union[DeferredCallback, Literal[_Sentinel._CONTINUE]],\n  \
    \      _CallbackOrderedArguments,\n        _CallbackKeywordArguments,\n    ],\n\
    \    Tuple[\n        Union[DeferredErrback, DeferredCallback, Literal[_Sentinel._CONTINUE]],\n\
    \        _CallbackOrderedArguments,\n        _CallbackKeywordArguments,\n    ],\n\
    ]\n\n_NONE_KWARGS: _CallbackKeywordArguments = MappingProxyType({})\n\n\n_SelfResultT\
    \ = TypeVar(\"_SelfResultT\")\n_NextResultT = TypeVar(\"_NextResultT\")\n\n\n\
    class DebugInfo:\n    \"\"\"\n    Deferred debug helper.\n    \"\"\"\n\n    failResult:\
    \ Optional[Failure] = None\n    creator: Optional[List[str]] = None\n    invoker:\
    \ Optional[List[str]] = None\n\n    def _getDebugTracebacks(self) -> str:\n  \
    \      info = \"\"\n        if self.creator is not None:\n            info +=\
    \ \" C: Deferred was created:\\n C:\"\n            info += \"\".join(self.creator).rstrip().replace(\"\
    \\n\", \"\\n C:\")\n            info += \"\\n\"\n        if self.invoker is not\
    \ None:\n            info += \" I: First Invoker was:\\n I:\"\n            info\
    \ += \"\".join(self.invoker).rstrip().replace(\"\\n\", \"\\n I:\")\n         \
    \   info += \"\\n\"\n        return info\n\n    def __del__(self) -> None:\n \
    \       \"\"\"\n        Print tracebacks and die.\n\n        If the *last* (and\
    \ I do mean *last*) callback leaves me in an error\n        state, print a traceback\
    \ (if said errback is a L{Failure}).\n        \"\"\"\n        if self.failResult\
    \ is not None:\n            # Note: this is two separate messages for compatibility\
    \ with\n            # earlier tests; arguably it should be a single error message.\n\
    \            log.critical(\"Unhandled error in Deferred:\", isError=True)\n\n\
    \            debugInfo = self._getDebugTracebacks()\n            if debugInfo:\n\
    \                format = \"(debug: {debugInfo})\"\n            else:\n      \
    \          format = \"\"\n\n            log.failure(format, self.failResult, debugInfo=debugInfo)\n\
    \n\nclass Deferred(Awaitable[_SelfResultT]):\n    \"\"\"\n    This is a callback\
    \ which will be put off until later.\n\n    Why do we want this? Well, in cases\
    \ where a function in a threaded\n    program would block until it gets a result,\
    \ for Twisted it should\n    not block. Instead, it should return a L{Deferred}.\n\
    \n    This can be implemented for protocols that run over the network by\n   \
    \ writing an asynchronous protocol for L{twisted.internet}. For methods\n    that\
    \ come from outside packages that are not under our control, we use\n    threads\
    \ (see for example L{twisted.enterprise.adbapi}).\n\n    For more information\
    \ about Deferreds, see doc/core/howto/defer.html or\n    U{http://twistedmatrix.com/documents/current/core/howto/defer.html}\n\
    \n    When creating a Deferred, you may provide a canceller function, which\n\
    \    will be called by d.cancel() to let you do any clean-up necessary if the\n\
    \    user decides not to wait for the deferred to complete.\n\n    @ivar called:\
    \ A flag which is C{False} until either C{callback} or\n        C{errback} is\
    \ called and afterwards always C{True}.\n    @ivar paused: A counter of how many\
    \ unmatched C{pause} calls have been made\n        on this instance.\n    @ivar\
    \ _suppressAlreadyCalled: A flag used by the cancellation mechanism\n        which\
    \ is C{True} if the Deferred has no canceller and has been\n        cancelled,\
    \ C{False} otherwise.  If C{True}, it can be expected that\n        C{callback}\
    \ or C{errback} will eventually be called and the result\n        should be silently\
    \ discarded.\n    @ivar _runningCallbacks: A flag which is C{True} while this\
    \ instance is\n        executing its callback chain, used to stop recursive execution\
    \ of\n        L{_runCallbacks}\n    @ivar _chainedTo: If this L{Deferred} is waiting\
    \ for the result of another\n        L{Deferred}, this is a reference to the other\
    \ Deferred.  Otherwise,\n        L{None}.\n    \"\"\"\n\n    called = False\n\
    \    paused = 0\n    _debugInfo: Optional[DebugInfo] = None\n    _suppressAlreadyCalled\
    \ = False\n\n    # Are we currently running a user-installed callback?  Meant\
    \ to prevent\n    # recursive running of callbacks when a reentrant call to add\
    \ a callback is\n    # used.\n    _runningCallbacks = False\n\n    # Keep this\
    \ class attribute for now, for compatibility with code that\n    # sets it directly.\n\
    \    debug = False\n\n    _chainedTo: \"Optional[Deferred[Any]]\" = None\n\n \
    \   def __init__(\n        self, canceller: Optional[Callable[[\"Deferred[Any]\"\
    ], None]] = None\n    ) -> None:\n        \"\"\"\n        Initialize a L{Deferred}.\n\
    \n        @param canceller: a callable used to stop the pending operation\n  \
    \          scheduled by this L{Deferred} when L{Deferred.cancel} is invoked.\n\
    \            The canceller will be passed the deferred whose cancellation is\n\
    \            requested (i.e., C{self}).\n\n            If a canceller is not given,\
    \ or does not invoke its argument's\n            C{callback} or C{errback} method,\
    \ L{Deferred.cancel} will\n            invoke L{Deferred.errback} with a L{CancelledError}.\n\
    \n            Note that if a canceller is not given, C{callback} or\n        \
    \    C{errback} may still be invoked exactly once, even though\n            defer.py\
    \ will have already invoked C{errback}, as described\n            above.  This\
    \ allows clients of code which returns a L{Deferred}\n            to cancel it\
    \ without requiring the L{Deferred} instantiator to\n            provide any specific\
    \ implementation support for cancellation.\n            New in 10.1.\n\n     \
    \   @type canceller: a 1-argument callable which takes a L{Deferred}. The\n  \
    \          return result is ignored.\n        \"\"\"\n        self._callbacks:\
    \ List[_CallbackChain] = []\n        self._canceller = canceller\n        if self.debug:\n\
    \            self._debugInfo = DebugInfo()\n            self._debugInfo.creator\
    \ = traceback.format_stack()[:-1]\n\n    @deprecatedProperty(Version(\"Twisted\"\
    , \"NEXT\", 0, 0))\n    def callbacks(self) -> List[_CallbackChain]:\n       \
    \ return self._callbacks\n\n    def addCallbacks(\n        self,\n        callback:\
    \ Union[\n            Callable[..., _NextResultT],\n            Callable[...,\
    \ Deferred[_NextResultT]],\n            Callable[..., Failure],\n            Callable[\n\
    \                ...,\n                Union[_NextResultT, Deferred[_NextResultT],\
    \ Failure],\n            ],\n        ],\n        errback: Union[\n           \
    \ Callable[..., _NextResultT],\n            Callable[..., Deferred[_NextResultT]],\n\
    \            Callable[..., Failure],\n            Callable[\n                ...,\n\
    \                Union[_NextResultT, Deferred[_NextResultT], Failure],\n     \
    \       ],\n            None,\n        ] = None,\n        callbackArgs: Tuple[Any,\
    \ ...] = (),\n        callbackKeywords: Mapping[str, Any] = _NONE_KWARGS,\n  \
    \      errbackArgs: _CallbackOrderedArguments = (),\n        errbackKeywords:\
    \ _CallbackKeywordArguments = _NONE_KWARGS,\n    ) -> \"Deferred[_NextResultT]\"\
    :\n        \"\"\"\n        Add a pair of callbacks (success and error) to this\
    \ L{Deferred}.\n\n        These will be executed when the 'master' callback is\
    \ run.\n\n        @note: The signature of this function was designed many years\
    \ before\n            PEP 612; ParamSpec provides no mechanism to annotate parameters\n\
    \            like C{callbackArgs}; this is therefore inherently less type-safe\n\
    \            than calling C{addCallback} and C{addErrback} separately.\n\n   \
    \     @return: C{self}.\n        \"\"\"\n        if errback is None:\n       \
    \     errback = _failthru\n\n        # Default value used to be None and callers\
    \ may be using None\n        if callbackArgs is None:\n            callbackArgs\
    \ = ()  # type: ignore[unreachable]\n        if callbackKeywords is None:\n  \
    \          callbackKeywords = {}  # type: ignore[unreachable]\n        if errbackArgs\
    \ is None:\n            errbackArgs = ()  # type: ignore[unreachable]\n      \
    \  if errbackKeywords is None:\n            errbackKeywords = {}  # type: ignore[unreachable]\n\
    \n        # Note that this logic is duplicated in addCallbac/addErrback/addBoth\n\
    \        # for performance reasons.\n        self._callbacks.append(\n       \
    \     (\n                (callback, callbackArgs, callbackKeywords),\n       \
    \         (errback, errbackArgs, errbackKeywords),\n            )\n        )\n\
    \n        if self.called:\n            self._runCallbacks()\n\n        # type\
    \ note: The Deferred's type has changed here, but *idiomatically*\n        # \
    \    the caller should treat the result as the new type, consistently.\n     \
    \   return self  # type:ignore[return-value]\n\n    # BEGIN way too many @overload-s\
    \ for addCallback, addErrback, and addBoth:\n    # these must be accomplished\
    \ with @overloads, rather than a big Union on\n    # the result type as you might\
    \ expect, because the fact that\n    # _NextResultT has no bound makes mypy get\
    \ confused and require the\n    # return types of functions to be combinations\
    \ of Deferred and Failure\n    # rather than the actual return type.  I'm not\
    \ entirely sure what about the\n    # semantics of <nothing> create this overzealousness\
    \ on the part of trying\n    # to assign a type; there *might* be a mypy bug in\
    \ there somewhere.\n    # Possibly https://github.com/python/typing/issues/548\
    \ is implicated here\n    # because TypeVar for the *callable* with a variadic\
    \ bound might express to\n    # Mypy the actual constraint that we want on its\
    \ type.\n\n    @overload\n    def addCallback(\n        self,\n        callback:\
    \ Callable[Concatenate[_SelfResultT, _P], Failure],\n        *args: _P.args,\n\
    \        **kwargs: _P.kwargs,\n    ) -> Deferred[_NextResultT]:\n        ...\n\
    \n    @overload\n    def addCallback(\n        self,\n        callback: Callable[\n\
    \            Concatenate[_SelfResultT, _P],\n            Union[Failure, Deferred[_NextResultT]],\n\
    \        ],\n        *args: _P.args,\n        **kwargs: _P.kwargs,\n    ) -> Deferred[_NextResultT]:\n\
    \        ...\n\n    @overload\n    def addCallback(\n        self,\n        callback:\
    \ Callable[Concatenate[_SelfResultT, _P], Union[Failure, _NextResultT]],\n   \
    \     *args: _P.args,\n        **kwargs: _P.kwargs,\n    ) -> Deferred[_NextResultT]:\n\
    \        ...\n\n    @overload\n    def addCallback(\n        self,\n        callback:\
    \ Callable[Concatenate[_SelfResultT, _P], Deferred[_NextResultT]],\n        *args:\
    \ _P.args,\n        **kwargs: _P.kwargs,\n    ) -> Deferred[_NextResultT]:\n \
    \       ...\n\n    @overload\n    def addCallback(\n        self,\n        callback:\
    \ Callable[\n            Concatenate[_SelfResultT, _P],\n            Union[Deferred[_NextResultT],\
    \ _NextResultT],\n        ],\n        *args: _P.args,\n        **kwargs: _P.kwargs,\n\
    \    ) -> Deferred[_NextResultT]:\n        ...\n\n    @overload\n    def addCallback(\n\
    \        self,\n        callback: Callable[Concatenate[_SelfResultT, _P], _NextResultT],\n\
    \        *args: _P.args,\n        **kwargs: _P.kwargs,\n    ) -> Deferred[_NextResultT]:\n\
    \        ...\n\n    def addCallback(self, callback: Any, *args: Any, **kwargs:\
    \ Any) -> \"Deferred[Any]\":\n        \"\"\"\n        Convenience method for adding\
    \ just a callback.\n\n        See L{addCallbacks}.\n        \"\"\"\n        #\
    \ This could be implemented as a call to addCallbacks, but doing it\n        #\
    \ directly is faster.\n        self._callbacks.append(((callback, args, kwargs),\
    \ (_failthru, (), {})))\n\n        if self.called:\n            self._runCallbacks()\n\
    \n        return self\n\n    @overload\n    def addErrback(\n        self,\n \
    \       errback: Callable[Concatenate[Failure, _P], Deferred[_NextResultT]],\n\
    \        *args: _P.args,\n        **kwargs: _P.kwargs,\n    ) -> \"Deferred[Union[_SelfResultT,\
    \ _NextResultT]]\":\n        ...\n\n    @overload\n    def addErrback(\n     \
    \   self,\n        errback: Callable[Concatenate[Failure, _P], Failure],\n   \
    \     *args: _P.args,\n        **kwargs: _P.kwargs,\n    ) -> \"Deferred[Union[_SelfResultT]]\"\
    :\n        ...\n\n    @overload\n    def addErrback(\n        self,\n        errback:\
    \ Callable[Concatenate[Failure, _P], _NextResultT],\n        *args: _P.args,\n\
    \        **kwargs: _P.kwargs,\n    ) -> \"Deferred[Union[_SelfResultT, _NextResultT]]\"\
    :\n        ...\n\n    def addErrback(self, errback: Any, *args: Any, **kwargs:\
    \ Any) -> \"Deferred[Any]\":\n        \"\"\"\n        Convenience method for adding\
    \ just an errback.\n\n        See L{addCallbacks}.\n        \"\"\"\n        #\
    \ This could be implemented as a call to addCallbacks, but doing it\n        #\
    \ directly is faster.\n        self._callbacks.append(((passthru, (), {}), (errback,\
    \ args, kwargs)))\n\n        if self.called:\n            self._runCallbacks()\n\
    \n        return self\n\n    @overload\n    def addBoth(\n        self,\n    \
    \    callback: Callable[Concatenate[Union[_SelfResultT, Failure], _P], Failure],\n\
    \        *args: _P.args,\n        **kwargs: _P.kwargs,\n    ) -> Deferred[_NextResultT]:\n\
    \        ...\n\n    @overload\n    def addBoth(\n        self,\n        callback:\
    \ Callable[\n            Concatenate[Union[_SelfResultT, Failure], _P],\n    \
    \        Union[Failure, Deferred[_NextResultT]],\n        ],\n        *args: _P.args,\n\
    \        **kwargs: _P.kwargs,\n    ) -> Deferred[_NextResultT]:\n        ...\n\
    \n    @overload\n    def addBoth(\n        self,\n        callback: Callable[\n\
    \            Concatenate[Union[_SelfResultT, Failure], _P], Union[Failure, _NextResultT]\n\
    \        ],\n        *args: _P.args,\n        **kwargs: _P.kwargs,\n    ) -> Deferred[_NextResultT]:\n\
    \        ...\n\n    @overload\n    def addBoth(\n        self,\n        callback:\
    \ Callable[\n            Concatenate[Union[_SelfResultT, Failure], _P], Deferred[_NextResultT]\n\
    \        ],\n        *args: _P.args,\n        **kwargs: _P.kwargs,\n    ) -> Deferred[_NextResultT]:\n\
    \        ...\n\n    @overload\n    def addBoth(\n        self,\n        callback:\
    \ Callable[\n            Concatenate[Union[_SelfResultT, Failure], _P],\n    \
    \        Union[Deferred[_NextResultT], _NextResultT],\n        ],\n        *args:\
    \ _P.args,\n        **kwargs: _P.kwargs,\n    ) -> Deferred[_NextResultT]:\n \
    \       ...\n\n    @overload\n    def addBoth(\n        self,\n        callback:\
    \ Callable[Concatenate[Union[_SelfResultT, Failure], _P], _NextResultT],\n   \
    \     *args: _P.args,\n        **kwargs: _P.kwargs,\n    ) -> Deferred[_NextResultT]:\n\
    \        ...\n\n    @overload\n    def addBoth(\n        self,\n        callback:\
    \ Callable[Concatenate[_T, _P], _T],\n        *args: _P.args,\n        **kwargs:\
    \ _P.kwargs,\n    ) -> Deferred[_SelfResultT]:\n        ...\n\n    def addBoth(self,\
    \ callback: Any, *args: Any, **kwargs: Any) -> \"Deferred[Any]\":\n        \"\"\
    \"\n        Convenience method for adding a single callable as both a callback\n\
    \        and an errback.\n\n        See L{addCallbacks}.\n        \"\"\"\n   \
    \     # This could be implemented as a call to addCallbacks, but doing it\n  \
    \      # directly is faster.\n        call = (callback, args, kwargs)\n      \
    \  self._callbacks.append((call, call))\n\n        if self.called:\n         \
    \   self._runCallbacks()\n\n        return self\n\n    # END way too many overloads\n\
    \n    def addTimeout(\n        self,\n        timeout: float,\n        clock:\
    \ IReactorTime,\n        onTimeoutCancel: Optional[\n            Callable[\n \
    \               [Union[_SelfResultT, Failure], float],\n                Union[_NextResultT,\
    \ Failure],\n            ]\n        ] = None,\n    ) -> \"Deferred[Union[_SelfResultT,\
    \ _NextResultT]]\":\n        \"\"\"\n        Time out this L{Deferred} by scheduling\
    \ it to be cancelled after\n        C{timeout} seconds.\n\n        The timeout\
    \ encompasses all the callbacks and errbacks added to this\n        L{defer.Deferred}\
    \ before the call to L{addTimeout}, and none added\n        after the call.\n\n\
    \        If this L{Deferred} gets timed out, it errbacks with a L{TimeoutError},\n\
    \        unless a cancelable function was passed to its initialization or unless\n\
    \        a different C{onTimeoutCancel} callable is provided.\n\n        @param\
    \ timeout: number of seconds to wait before timing out this\n            L{Deferred}\n\
    \        @param clock: The object which will be used to schedule the timeout.\n\
    \        @param onTimeoutCancel: A callable which is called immediately after\n\
    \            this L{Deferred} times out, and not if this L{Deferred} is\n    \
    \        otherwise cancelled before the timeout. It takes an arbitrary\n     \
    \       value, which is the value of this L{Deferred} at that exact point\n  \
    \          in time (probably a L{CancelledError} L{Failure}), and the\n      \
    \      C{timeout}.  The default callable (if C{None} is provided) will\n     \
    \       translate a L{CancelledError} L{Failure} into a L{TimeoutError}.\n\n \
    \       @return: C{self}.\n\n        @since: 16.5\n        \"\"\"\n\n        timedOut\
    \ = [False]\n\n        def timeItOut() -> None:\n            timedOut[0] = True\n\
    \            self.cancel()\n\n        delayedCall = clock.callLater(timeout, timeItOut)\n\
    \n        def convertCancelled(\n            result: Union[_SelfResultT, Failure],\n\
    \        ) -> Union[_SelfResultT, _NextResultT, Failure]:\n            # if C{deferred}\
    \ was timed out, call the translation function,\n            # if provided, otherwise\
    \ just use L{cancelledToTimedOutError}\n            if timedOut[0]:\n        \
    \        toCall = onTimeoutCancel or _cancelledToTimedOutError\n             \
    \   return toCall(result, timeout)\n            return result\n\n        def cancelTimeout(result:\
    \ _T) -> _T:\n            # stop the pending call to cancel the deferred if it's\
    \ been fired\n            if delayedCall.active():\n                delayedCall.cancel()\n\
    \            return result\n\n        # Note: Mypy cannot infer this type, apparently\
    \ thanks to the ambiguity\n        # of _SelfResultT / _NextResultT both being\
    \ unbound.  Explicitly\n        # annotating it seems to do the trick though.\n\
    \        converted: Deferred[Union[_SelfResultT, _NextResultT]] = self.addBoth(\n\
    \            convertCancelled\n        )\n        return converted.addBoth(cancelTimeout)\n\
    \n    def chainDeferred(self, d: \"Deferred[_SelfResultT]\") -> \"Deferred[None]\"\
    :\n        \"\"\"\n        Chain another L{Deferred} to this L{Deferred}.\n\n\
    \        This method adds callbacks to this L{Deferred} to call C{d}'s callback\n\
    \        or errback, as appropriate. It is merely a shorthand way of performing\n\
    \        the following::\n\n            d1.addCallbacks(d2.callback, d2.errback)\n\
    \n        When you chain a deferred C{d2} to another deferred C{d1} with\n   \
    \     C{d1.chainDeferred(d2)}, you are making C{d2} participate in the\n     \
    \   callback chain of C{d1}.\n        Thus any event that fires C{d1} will also\
    \ fire C{d2}.\n        However, the converse is B{not} true; if C{d2} is fired,\
    \ C{d1} will not\n        be affected.\n\n        Note that unlike the case where\
    \ chaining is caused by a L{Deferred}\n        being returned from a callback,\
    \ it is possible to cause the call\n        stack size limit to be exceeded by\
    \ chaining many L{Deferred}s\n        together with C{chainDeferred}.\n\n    \
    \    @return: C{self}.\n        \"\"\"\n        d._chainedTo = self\n        return\
    \ self.addCallbacks(d.callback, d.errback)\n\n    def callback(self, result: Union[_SelfResultT,\
    \ Failure]) -> None:\n        \"\"\"\n        Run all success callbacks that have\
    \ been added to this L{Deferred}.\n\n        Each callback will have its result\
    \ passed as the first argument to\n        the next; this way, the callbacks act\
    \ as a 'processing chain'.  If\n        the success-callback returns a L{Failure}\
    \ or raises an L{Exception},\n        processing will continue on the *error*\
    \ callback chain.  If a\n        callback (or errback) returns another L{Deferred},\
    \ this L{Deferred}\n        will be chained to it (and further callbacks will\
    \ not run until that\n        L{Deferred} has a result).\n\n        An instance\
    \ of L{Deferred} may only have either L{callback} or\n        L{errback} called\
    \ on it, and only once.\n\n        @param result: The object which will be passed\
    \ to the first callback\n            added to this L{Deferred} (via L{addCallback}),\
    \ unless C{result} is\n            a L{Failure}, in which case the behavior is\
    \ the same as calling\n            C{errback(result)}.\n\n        @raise AlreadyCalledError:\
    \ If L{callback} or L{errback} has already been\n            called on this L{Deferred}.\n\
    \        \"\"\"\n        self._startRunCallbacks(result)\n\n    def errback(self,\
    \ fail: Optional[Union[Failure, BaseException]] = None) -> None:\n        \"\"\
    \"\n        Run all error callbacks that have been added to this L{Deferred}.\n\
    \n        Each callback will have its result passed as the first\n        argument\
    \ to the next; this way, the callbacks act as a\n        'processing chain'. Also,\
    \ if the error-callback returns a non-Failure\n        or doesn't raise an L{Exception},\
    \ processing will continue on the\n        *success*-callback chain.\n\n     \
    \   If the argument that's passed to me is not a L{Failure} instance,\n      \
    \  it will be embedded in one. If no argument is passed, a\n        L{Failure}\
    \ instance will be created based on the current\n        traceback stack.\n\n\
    \        Passing a string as `fail' is deprecated, and will be punished with\n\
    \        a warning message.\n\n        An instance of L{Deferred} may only have\
    \ either L{callback} or\n        L{errback} called on it, and only once.\n\n \
    \       @param fail: The L{Failure} object which will be passed to the first\n\
    \            errback added to this L{Deferred} (via L{addErrback}).\n        \
    \    Alternatively, a L{Exception} instance from which a L{Failure} will\n   \
    \         be constructed (with no traceback) or L{None} to create a L{Failure}\n\
    \            instance from the current exception state (with a traceback).\n\n\
    \        @raise AlreadyCalledError: If L{callback} or L{errback} has already been\n\
    \            called on this L{Deferred}.\n        @raise NoCurrentExceptionError:\
    \ If C{fail} is L{None} but there is\n            no current exception state.\n\
    \        \"\"\"\n        if fail is None:\n            fail = Failure(captureVars=self.debug)\n\
    \        elif not isinstance(fail, Failure):\n            fail = Failure(fail)\n\
    \n        self._startRunCallbacks(fail)\n\n    def pause(self) -> None:\n    \
    \    \"\"\"\n        Stop processing on a L{Deferred} until L{unpause}() is called.\n\
    \        \"\"\"\n        self.paused += 1\n\n    def unpause(self) -> None:\n\
    \        \"\"\"\n        Process all callbacks made since L{pause}() was called.\n\
    \        \"\"\"\n        self.paused -= 1\n        if self.paused:\n         \
    \   return\n        if self.called:\n            self._runCallbacks()\n\n    def\
    \ cancel(self) -> None:\n        \"\"\"\n        Cancel this L{Deferred}.\n\n\
    \        If the L{Deferred} has not yet had its C{errback} or C{callback} method\n\
    \        invoked, call the canceller function provided to the constructor. If\n\
    \        that function does not invoke C{callback} or C{errback}, or if no\n \
    \       canceller function was provided, errback with L{CancelledError}.\n\n \
    \       If this L{Deferred} is waiting on another L{Deferred}, forward the\n \
    \       cancellation to the other L{Deferred}.\n        \"\"\"\n        if not\
    \ self.called:\n            canceller = self._canceller\n            if canceller:\n\
    \                canceller(self)\n            else:\n                # Arrange\
    \ to eat the callback that will eventually be fired\n                # since there\
    \ was no real canceller.\n                self._suppressAlreadyCalled = True\n\
    \            if not self.called:\n                # There was no canceller, or\
    \ the canceller didn't call\n                # callback or errback.\n        \
    \        self.errback(Failure(CancelledError()))\n        elif isinstance(self.result,\
    \ Deferred):\n            # Waiting for another deferred -- cancel it instead.\n\
    \            self.result.cancel()\n\n    def _startRunCallbacks(self, result:\
    \ object) -> None:\n        if self.called:\n            if self._suppressAlreadyCalled:\n\
    \                self._suppressAlreadyCalled = False\n                return\n\
    \            if self.debug:\n                if self._debugInfo is None:\n   \
    \                 self._debugInfo = DebugInfo()\n                extra = \"\\\
    n\" + self._debugInfo._getDebugTracebacks()\n                raise AlreadyCalledError(extra)\n\
    \            raise AlreadyCalledError\n        if self.debug:\n            if\
    \ self._debugInfo is None:\n                self._debugInfo = DebugInfo()\n  \
    \          self._debugInfo.invoker = traceback.format_stack()[:-2]\n        self.called\
    \ = True\n\n        # Clear the canceller to avoid any circular references. This\
    \ is safe to\n        # do as the canceller does not get called after the deferred\
    \ has fired\n        self._canceller = None\n\n        self.result = result\n\
    \        self._runCallbacks()\n\n    def _continuation(self) -> _CallbackChain:\n\
    \        \"\"\"\n        Build a tuple of callback and errback with L{_Sentinel._CONTINUE}.\n\
    \        \"\"\"\n        triple = (_CONTINUE, (self,), _NONE_KWARGS)\n       \
    \ return (triple, triple)  # type: ignore[return-value]\n\n    def _runCallbacks(self)\
    \ -> None:\n        \"\"\"\n        Run the chain of callbacks once a result is\
    \ available.\n\n        This consists of a simple loop over all of the callbacks,\
    \ calling each\n        with the current result and making the current result\
    \ equal to the\n        return value (or raised exception) of that call.\n\n \
    \       If L{_runningCallbacks} is true, this loop won't run at all, since\n \
    \       it is already running above us on the call stack.  If C{self.paused} is\n\
    \        true, the loop also won't run, because that's what it means to be\n \
    \       paused.\n\n        The loop will terminate before processing all of the\
    \ callbacks if a\n        L{Deferred} without a result is encountered.\n\n   \
    \     If a L{Deferred} I{with} a result is encountered, that result is taken\n\
    \        and the loop proceeds.\n\n        @note: The implementation is complicated\
    \ slightly by the fact that\n            chaining (associating two L{Deferred}s\
    \ with each other such that one\n            will wait for the result of the other,\
    \ as happens when a Deferred is\n            returned from a callback on another\
    \ L{Deferred}) is supported\n            iteratively rather than recursively,\
    \ to avoid running out of stack\n            frames when processing long chains.\n\
    \        \"\"\"\n        if self._runningCallbacks:\n            # Don't recursively\
    \ run callbacks\n            return\n\n        # Keep track of all the Deferreds\
    \ encountered while propagating results\n        # up a chain.  The way a Deferred\
    \ gets onto this stack is by having\n        # added its _continuation() to the\
    \ callbacks list of a second Deferred\n        # and then that second Deferred\
    \ being fired.  ie, if ever had _chainedTo\n        # set to something other than\
    \ None, you might end up on this stack.\n        chain: List[Deferred[Any]] =\
    \ [self]\n\n        while chain:\n            current = chain[-1]\n\n        \
    \    if current.paused:\n                # This Deferred isn't going to produce\
    \ a result at all.  All the\n                # Deferreds up the chain waiting\
    \ on it will just have to...\n                # wait.\n                return\n\
    \n            finished = True\n            current._chainedTo = None\n       \
    \     while current._callbacks:\n                item = current._callbacks.pop(0)\n\
    \                if not isinstance(current.result, Failure):\n               \
    \     callback, args, kwargs = item[0]\n                else:\n              \
    \      # type note: Callback signature also works for Errbacks in\n          \
    \          #     this context.\n                    callback, args, kwargs = item[1]\n\
    \n                # Avoid recursion if we can.\n                if callback is\
    \ _CONTINUE:\n                    # Give the waiting Deferred our current result\
    \ and then\n                    # forget about that result ourselves.\n\n    \
    \                # We don't use cast() for performance reasons:\n            \
    \        chainee: Deferred[object] = args[0]  # type: ignore[assignment]\n   \
    \                 chainee.result = current.result\n                    current.result\
    \ = None\n                    # Making sure to update _debugInfo\n           \
    \         if current._debugInfo is not None:\n                        current._debugInfo.failResult\
    \ = None\n                    chainee.paused -= 1\n                    chain.append(chainee)\n\
    \                    # Delay cleaning this Deferred and popping it from the chain\n\
    \                    # until after we've dealt with chainee.\n               \
    \     finished = False\n                    break\n\n                try:\n  \
    \                  current._runningCallbacks = True\n                    try:\n\
    \                        # type note: mypy sees `callback is _CONTINUE` above\
    \ and\n                        #    then decides that `callback` is not callable.\n\
    \                        #    This goes away when we use `_Sentinel._CONTINUE`\n\
    \                        #    instead, but we don't want to do that attribute\n\
    \                        #    lookup in this hot code path, so we ignore the mypy\n\
    \                        #    complaint here.\n                        current.result\
    \ = callback(  # type: ignore[misc]\n                            current.result,\
    \ *args, **kwargs\n                        )\n\n                        if current.result\
    \ is current:\n                            warnAboutFunction(\n              \
    \                  callback,\n                                \"Callback returned\
    \ the Deferred \"\n                                \"it was attached to; this\
    \ breaks the \"\n                                \"callback chain and will raise\
    \ an \"\n                                \"exception in the future.\",\n     \
    \                       )\n                    finally:\n                    \
    \    current._runningCallbacks = False\n                except BaseException:\n\
    \                    # Including full frame information in the Failure is quite\n\
    \                    # expensive, so we avoid it unless self.debug is set.\n \
    \                   current.result = Failure(captureVars=self.debug)\n       \
    \         else:\n                    # isinstance() with Awaitable subclass is\
    \ expensive:\n                    if type(current.result) in _DEFERRED_SUBCLASSES:\n\
    \                        # Can't use cast() cause it's in the performance hot\
    \ path:\n                        currentResult: Deferred[_SelfResultT] = current.result\
    \  # type: ignore[assignment]\n                        # The result is another\
    \ Deferred.  If it has a result,\n                        # we can take it and\
    \ keep going.\n                        resultResult = getattr(currentResult, \"\
    result\", _NO_RESULT)\n                        if (\n                        \
    \    resultResult is _NO_RESULT\n                            or type(resultResult)\
    \ in _DEFERRED_SUBCLASSES\n                            or currentResult.paused\n\
    \                        ):\n                            # Nope, it didn't.  Pause\
    \ and chain.\n                            current.pause()\n                  \
    \          current._chainedTo = currentResult\n                            # Note:\
    \ current.result has no result, so it's not\n                            # running\
    \ its callbacks right now.  Therefore we can\n                            # append\
    \ to the callbacks list directly instead of\n                            # using\
    \ addCallbacks.\n                            currentResult._callbacks.append(current._continuation())\n\
    \                            break\n                        else:\n          \
    \                  # Yep, it did.  Steal it.\n                            currentResult.result\
    \ = None\n                            # Make sure _debugInfo's failure state is\
    \ updated.\n                            if currentResult._debugInfo is not None:\n\
    \                                currentResult._debugInfo.failResult = None\n\
    \                            current.result = resultResult\n\n            if finished:\n\
    \                # As much of the callback chain - perhaps all of it - as can\
    \ be\n                # processed right now has been.  The current Deferred is\
    \ waiting on\n                # another Deferred or for more callbacks.  Before\
    \ finishing with it,\n                # make sure its _debugInfo is in the proper\
    \ state.\n                if isinstance(current.result, Failure):\n          \
    \          # Stash the Failure in the _debugInfo for unhandled error\n       \
    \             # reporting.\n                    if current._debugInfo is None:\n\
    \                        current._debugInfo = DebugInfo()\n                  \
    \  current._debugInfo.failResult = current.result\n                else:\n   \
    \                 # Clear out any Failure in the _debugInfo, since the result\n\
    \                    # is no longer a Failure.\n                    if current._debugInfo\
    \ is not None:\n                        current._debugInfo.failResult = None\n\
    \n                # This Deferred is done, pop it from the chain and move back\
    \ up\n                # to the Deferred which supplied us with our result.\n \
    \               chain.pop()\n\n    def __str__(self) -> str:\n        \"\"\"\n\
    \        Return a string representation of this L{Deferred}.\n        \"\"\"\n\
    \        cname = self.__class__.__name__\n        result = getattr(self, \"result\"\
    , _NO_RESULT)\n        myID = id(self)\n        if self._chainedTo is not None:\n\
    \            result = f\" waiting on Deferred at 0x{id(self._chainedTo):x}\"\n\
    \        elif result is _NO_RESULT:\n            result = \"\"\n        else:\n\
    \            result = f\" current result: {result!r}\"\n        return f\"<{cname}\
    \ at 0x{myID:x}{result}>\"\n\n    __repr__ = __str__\n\n    def __iter__(self)\
    \ -> Generator[Deferred[_SelfResultT], None, _SelfResultT]:\n        while True:\n\
    \            if self.paused:\n                # If we're paused, we have no result\
    \ to give\n                yield self\n                continue\n\n          \
    \  result = getattr(self, \"result\", _NO_RESULT)\n            if result is _NO_RESULT:\n\
    \                yield self\n                continue\n\n            if isinstance(result,\
    \ Failure):\n                # Clear the failure on debugInfo so it doesn't raise\
    \ \"unhandled\n                # exception\"\n                assert self._debugInfo\
    \ is not None\n                self._debugInfo.failResult = None\n           \
    \     result.raiseException()\n            else:\n                return result\
    \  # type: ignore[return-value]\n\n    __await__ = __iter__\n\n    def asFuture(self,\
    \ loop: AbstractEventLoop) -> \"Future[_SelfResultT]\":\n        \"\"\"\n    \
    \    Adapt this L{Deferred} into a L{Future} which is bound to C{loop}.\n\n  \
    \      @note: converting a L{Deferred} to an L{Future} consumes both\n       \
    \     its result and its errors, so this method implicitly converts\n        \
    \    C{self} into a L{Deferred} firing with L{None}, regardless of what\n    \
    \        its result previously would have been.\n\n        @since: Twisted 17.5.0\n\
    \n        @param loop: The L{asyncio} event loop to bind the L{Future} to.\n\n\
    \        @return: A L{Future} which will fire when the L{Deferred} fires.\n  \
    \      \"\"\"\n        future = loop.create_future()\n\n        def checkCancel(futureAgain:\
    \ \"Future[_SelfResultT]\") -> None:\n            if futureAgain.cancelled():\n\
    \                self.cancel()\n\n        def maybeFail(failure: Failure) -> None:\n\
    \            if not future.cancelled():\n                future.set_exception(failure.value)\n\
    \n        def maybeSucceed(result: object) -> None:\n            if not future.cancelled():\n\
    \                future.set_result(result)\n\n        self.addCallbacks(maybeSucceed,\
    \ maybeFail)\n        future.add_done_callback(checkCancel)\n\n        return\
    \ future\n\n    @classmethod\n    def fromFuture(cls, future: \"Future[_SelfResultT]\"\
    ) -> \"Deferred[_SelfResultT]\":\n        \"\"\"\n        Adapt a L{Future} to\
    \ a L{Deferred}.\n\n        @note: This creates a L{Deferred} from a L{Future},\
    \ I{not} from\n            a C{coroutine}; in other words, you will need to call\n\
    \            L{asyncio.ensure_future}, L{asyncio.loop.create_task} or create an\n\
    \            L{asyncio.Task} yourself to get from a C{coroutine} to a\n      \
    \      L{Future} if what you have is an awaitable coroutine and\n            not\
    \ a L{Future}.  (The length of this list of techniques is\n            exactly\
    \ why we have left it to the caller!)\n\n        @since: Twisted 17.5.0\n\n  \
    \      @param future: The L{Future} to adapt.\n\n        @return: A L{Deferred}\
    \ which will fire when the L{Future} fires.\n        \"\"\"\n\n        def adapt(result:\
    \ Future[_SelfResultT]) -> None:\n            try:\n                extracted:\
    \ _SelfResultT | Failure = result.result()\n            except BaseException:\n\
    \                extracted = Failure()\n            actual.callback(extracted)\n\
    \n        futureCancel = object()\n\n        def cancel(reself: Deferred[object])\
    \ -> None:\n            future.cancel()\n            reself.callback(futureCancel)\n\
    \n        self = cls(cancel)\n        actual = self\n\n        def uncancel(\n\
    \            result: _SelfResultT,\n        ) -> Union[_SelfResultT, Deferred[_SelfResultT]]:\n\
    \            if result is futureCancel:\n                nonlocal actual\n   \
    \             actual = Deferred()\n                return actual\n           \
    \ return result\n\n        self.addCallback(uncancel)\n        future.add_done_callback(adapt)\n\
    \n        return self\n\n    @classmethod\n    def fromCoroutine(\n        cls,\n\
    \        coro: Union[\n            Coroutine[Deferred[Any], Any, _T],\n      \
    \      Generator[Deferred[Any], Any, _T],\n        ],\n    ) -> \"Deferred[_T]\"\
    :\n        \"\"\"\n        Schedule the execution of a coroutine that awaits on\
    \ L{Deferred}s,\n        wrapping it in a L{Deferred} that will fire on success/failure\
    \ of the\n        coroutine.\n\n        Coroutine functions return a coroutine\
    \ object, similar to how\n        generators work. This function turns that coroutine\
    \ into a Deferred,\n        meaning that it can be used in regular Twisted code.\
    \ For example::\n\n            import treq\n            from twisted.internet.defer\
    \ import Deferred\n            from twisted.internet.task import react\n\n   \
    \         async def crawl(pages):\n                results = {}\n            \
    \    for page in pages:\n                    results[page] = await treq.content(await\
    \ treq.get(page))\n                return results\n\n            def main(reactor):\n\
    \                pages = [\n                    \"http://localhost:8080\"\n  \
    \              ]\n                d = Deferred.fromCoroutine(crawl(pages))\n \
    \               d.addCallback(print)\n                return d\n\n           \
    \ react(main)\n\n        @since: Twisted 21.2.0\n\n        @param coro: The coroutine\
    \ object to schedule.\n\n        @raise ValueError: If C{coro} is not a coroutine\
    \ or generator.\n        \"\"\"\n        # asyncio.iscoroutine <3.12 identifies\
    \ generators as coroutines, too.\n        # for >=3.12 we need to check isgenerator\
    \ also\n        # see https://github.com/python/cpython/issues/102748\n      \
    \  if iscoroutine(coro) or inspect.isgenerator(coro):\n            return _cancellableInlineCallbacks(coro)\n\
    \        raise NotACoroutineError(f\"{coro!r} is not a coroutine\")\n\n    def\
    \ __init_subclass__(cls: Type[Deferred[Any]], **kwargs: Any):\n        # Whenever\
    \ a subclass is created, record it in L{_DEFERRED_SUBCLASSES}\n        # so we\
    \ can emulate C{isinstance()} more efficiently.\n        _DEFERRED_SUBCLASSES.append(cls)\n\
    \n\n_DEFERRED_SUBCLASSES = [Deferred]\n\n\ndef ensureDeferred(\n    coro: Union[\n\
    \        Coroutine[Deferred[Any], Any, _T],\n        Generator[Deferred[Any],\
    \ Any, _T],\n        Deferred[_T],\n    ]\n) -> Deferred[_T]:\n    \"\"\"\n  \
    \  Schedule the execution of a coroutine that awaits/yields from L{Deferred}s,\n\
    \    wrapping it in a L{Deferred} that will fire on success/failure of the\n \
    \   coroutine. If a Deferred is passed to this function, it will be returned\n\
    \    directly (mimicking the L{asyncio.ensure_future} function).\n\n    See L{Deferred.fromCoroutine}\
    \ for examples of coroutines.\n\n    @param coro: The coroutine object to schedule,\
    \ or a L{Deferred}.\n    \"\"\"\n    if type(coro) in _DEFERRED_SUBCLASSES:\n\
    \        return coro  # type: ignore[return-value]\n    else:\n        try:\n\
    \            return Deferred.fromCoroutine(coro)  # type: ignore[arg-type]\n \
    \       except NotACoroutineError:\n            # It's not a coroutine. Raise\
    \ an exception, but say that it's also\n            # not a Deferred so the error\
    \ makes sense.\n            raise NotACoroutineError(f\"{coro!r} is not a coroutine\
    \ or a Deferred\")\n\n\n@comparable\nclass FirstError(Exception):\n    \"\"\"\n\
    \    First error to occur in a L{DeferredList} if C{fireOnOneErrback} is set.\n\
    \n    @ivar subFailure: The L{Failure} that occurred.\n    @ivar index: The index\
    \ of the L{Deferred} in the L{DeferredList} where\n        it happened.\n    \"\
    \"\"\n\n    def __init__(self, failure: Failure, index: int) -> None:\n      \
    \  Exception.__init__(self, failure, index)\n        self.subFailure = failure\n\
    \        self.index = index\n\n    def __repr__(self) -> str:\n        \"\"\"\n\
    \        The I{repr} of L{FirstError} instances includes the repr of the\n   \
    \     wrapped failure's exception and the index of the L{FirstError}.\n      \
    \  \"\"\"\n        return \"FirstError[#%d, %r]\" % (self.index, self.subFailure.value)\n\
    \n    def __str__(self) -> str:\n        \"\"\"\n        The I{str} of L{FirstError}\
    \ instances includes the I{str} of the\n        entire wrapped failure (including\
    \ its traceback and exception) and\n        the index of the L{FirstError}.\n\
    \        \"\"\"\n        return \"FirstError[#%d, %s]\" % (self.index, self.subFailure)\n\
    \n    def __cmp__(self, other: object) -> int:\n        \"\"\"\n        Comparison\
    \ between L{FirstError} and other L{FirstError} instances\n        is defined\
    \ as the comparison of the index and sub-failure of each\n        instance.  L{FirstError}\
    \ instances don't compare equal to anything\n        that isn't a L{FirstError}\
    \ instance.\n\n        @since: 8.2\n        \"\"\"\n        if isinstance(other,\
    \ FirstError):\n            return cmp((self.index, self.subFailure), (other.index,\
    \ other.subFailure))\n        return -1\n\n\n_DeferredListSingleResultT = Tuple[_SelfResultT,\
    \ int]\n_DeferredListResultItemT = Tuple[bool, _SelfResultT]\n_DeferredListResultListT\
    \ = List[_DeferredListResultItemT[_SelfResultT]]\n\nif TYPE_CHECKING:\n    # The\
    \ result type is different depending on whether fireOnOneCallback\n    # is True\
    \ or False.  The type system is not flexible enough to handle\n    # that in a\
    \ class definition, so instead we pretend that DeferredList\n    # is a function\
    \ that returns a Deferred.\n\n    @overload\n    def _DeferredList(\n        deferredList:\
    \ Iterable[Deferred[_SelfResultT]],\n        fireOnOneCallback: Literal[True],\n\
    \        fireOnOneErrback: bool = False,\n        consumeErrors: bool = False,\n\
    \    ) -> Deferred[_DeferredListSingleResultT[_SelfResultT]]:\n        ...\n\n\
    \    @overload\n    def _DeferredList(\n        deferredList: Iterable[Deferred[_SelfResultT]],\n\
    \        fireOnOneCallback: Literal[False] = False,\n        fireOnOneErrback:\
    \ bool = False,\n        consumeErrors: bool = False,\n    ) -> Deferred[_DeferredListResultListT[_SelfResultT]]:\n\
    \        ...\n\n    def _DeferredList(\n        deferredList: Iterable[Deferred[_SelfResultT]],\n\
    \        fireOnOneCallback: bool = False,\n        fireOnOneErrback: bool = False,\n\
    \        consumeErrors: bool = False,\n    ) -> Union[\n        Deferred[_DeferredListSingleResultT[_SelfResultT]],\n\
    \        Deferred[_DeferredListResultListT[_SelfResultT]],\n    ]:\n        ...\n\
    \n    DeferredList = _DeferredList\n\n\nclass DeferredList(  # type: ignore[no-redef]\
    \ # noqa:F811\n    Deferred[_DeferredListResultListT[Any]]\n):\n    \"\"\"\n \
    \   L{DeferredList} is a tool for collecting the results of several Deferreds.\n\
    \n    This tracks a list of L{Deferred}s for their results, and makes a single\n\
    \    callback when they have all completed.  By default, the ultimate result is\
    \ a\n    list of (success, result) tuples, 'success' being a boolean.\n    L{DeferredList}\
    \ exposes the same API that L{Deferred} does, so callbacks and\n    errbacks can\
    \ be added to it in the same way.\n\n    L{DeferredList} is implemented by adding\
    \ callbacks and errbacks to each\n    L{Deferred} in the list passed to it.  This\
    \ means callbacks and errbacks\n    added to the Deferreds before they are passed\
    \ to L{DeferredList} will change\n    the result that L{DeferredList} sees (i.e.,\
    \ L{DeferredList} is not special).\n    Callbacks and errbacks can also be added\
    \ to the Deferreds after they are\n    passed to L{DeferredList} and L{DeferredList}\
    \ may change the result that\n    they see.\n\n    See the documentation for the\
    \ C{__init__} arguments for more information.\n\n    @ivar _deferredList: The\
    \ L{list} of L{Deferred}s to track.\n    \"\"\"\n\n    fireOnOneCallback = False\n\
    \    fireOnOneErrback = False\n\n    def __init__(\n        self,\n        deferredList:\
    \ Iterable[Deferred[_SelfResultT]],\n        fireOnOneCallback: bool = False,\n\
    \        fireOnOneErrback: bool = False,\n        consumeErrors: bool = False,\n\
    \    ):\n        \"\"\"\n        Initialize a DeferredList.\n\n        @param\
    \ deferredList: The deferreds to track.\n        @param fireOnOneCallback: (keyword\
    \ param) a flag indicating that this\n            L{DeferredList} will fire when\
    \ the first L{Deferred} in\n            C{deferredList} fires with a non-failure\
    \ result without waiting for\n            any of the other Deferreds.  When this\
    \ flag is set, the DeferredList\n            will fire with a two-tuple: the first\
    \ element is the result of the\n            Deferred which fired; the second element\
    \ is the index in\n            C{deferredList} of that Deferred.\n        @param\
    \ fireOnOneErrback: (keyword param) a flag indicating that this\n            L{DeferredList}\
    \ will fire when the first L{Deferred} in\n            C{deferredList} fires with\
    \ a failure result without waiting for any\n            of the other Deferreds.\
    \  When this flag is set, if a Deferred in the\n            list errbacks, the\
    \ DeferredList will errback with a L{FirstError}\n            failure wrapping\
    \ the failure of that Deferred.\n        @param consumeErrors: (keyword param)\
    \ a flag indicating that failures in\n            any of the included L{Deferred}s\
    \ should not be propagated to\n            errbacks added to the individual L{Deferred}s\
    \ after this\n            L{DeferredList} is constructed.  After constructing\
    \ the\n            L{DeferredList}, any errors in the individual L{Deferred}s\
    \ will be\n            converted to a callback result of L{None}.  This is useful\
    \ to\n            prevent spurious 'Unhandled error in Deferred' messages from\
    \ being\n            logged.  This does not prevent C{fireOnOneErrback} from working.\n\
    \        \"\"\"\n        self._deferredList = list(deferredList)\n\n        #\
    \ Note this contains optional result values as the DeferredList is\n        #\
    \ processing its results, even though the callback result will not,\n        #\
    \ which is why we aren't using _DeferredListResultListT here.\n        self.resultList:\
    \ List[Optional[_DeferredListResultItemT[Any]]] = [None] * len(\n            self._deferredList\n\
    \        )\n        \"\"\"\n        The final result, in progress.\n        Each\
    \ item in the list corresponds to the L{Deferred} at the same\n        position\
    \ in L{_deferredList}. It will be L{None} if the L{Deferred}\n        did not\
    \ complete yet, or a C{(success, result)} pair if it did.\n        \"\"\"\n\n\
    \        Deferred.__init__(self)\n        if len(self._deferredList) == 0 and\
    \ not fireOnOneCallback:\n            self.callback([])\n\n        # These flags\
    \ need to be set *before* attaching callbacks to the\n        # deferreds, because\
    \ the callbacks use these flags, and will run\n        # synchronously if any\
    \ of the deferreds are already fired.\n        self.fireOnOneCallback = fireOnOneCallback\n\
    \        self.fireOnOneErrback = fireOnOneErrback\n        self.consumeErrors\
    \ = consumeErrors\n        self.finishedCount = 0\n\n        index = 0\n     \
    \   for deferred in self._deferredList:\n            deferred.addCallbacks(\n\
    \                self._cbDeferred,\n                self._cbDeferred,\n      \
    \          callbackArgs=(index, SUCCESS),\n                errbackArgs=(index,\
    \ FAILURE),\n            )\n            index = index + 1\n\n    def _cbDeferred(\n\
    \        self, result: _SelfResultT, index: int, succeeded: bool\n    ) -> Optional[_SelfResultT]:\n\
    \        \"\"\"\n        (internal) Callback for when one of my deferreds fires.\n\
    \        \"\"\"\n        self.resultList[index] = (succeeded, result)\n\n    \
    \    self.finishedCount += 1\n        if not self.called:\n            if succeeded\
    \ == SUCCESS and self.fireOnOneCallback:\n                self.callback((result,\
    \ index))  # type: ignore[arg-type]\n            elif succeeded == FAILURE and\
    \ self.fireOnOneErrback:\n                assert isinstance(result, Failure)\n\
    \                self.errback(Failure(FirstError(result, index)))\n          \
    \  elif self.finishedCount == len(self.resultList):\n                # At this\
    \ point, None values in self.resultList have been\n                # replaced\
    \ by result values, so we cast it to\n                # _DeferredListResultListT\
    \ to match the callback result type.\n                self.callback(cast(_DeferredListResultListT[Any],\
    \ self.resultList))\n\n        if succeeded == FAILURE and self.consumeErrors:\n\
    \            return None\n\n        return result\n\n    def cancel(self) -> None:\n\
    \        \"\"\"\n        Cancel this L{DeferredList}.\n\n        If the L{DeferredList}\
    \ hasn't fired yet, cancel every L{Deferred} in\n        the list.\n\n       \
    \ If the L{DeferredList} has fired, including the case where the\n        C{fireOnOneCallback}/C{fireOnOneErrback}\
    \ flag is set and the\n        L{DeferredList} fires because one L{Deferred} in\
    \ the list fires with a\n        non-failure/failure result, do nothing in the\
    \ C{cancel} method.\n        \"\"\"\n        if not self.called:\n           \
    \ for deferred in self._deferredList:\n                try:\n                \
    \    deferred.cancel()\n                except BaseException:\n              \
    \      log.failure(\"Exception raised from user supplied canceller\")\n\n\ndef\
    \ _parseDeferredListResult(\n    resultList: List[_DeferredListResultItemT[_T]],\
    \ fireOnOneErrback: bool = False, /\n) -> List[_T]:\n    if __debug__:\n     \
    \   for result in resultList:\n            assert result is not None\n       \
    \     success, value = result\n            assert success\n    return [x[1] for\
    \ x in resultList]\n\n\ndef gatherResults(\n    deferredList: Iterable[Deferred[_T]],\
    \ consumeErrors: bool = False\n) -> Deferred[List[_T]]:\n    \"\"\"\n    Returns,\
    \ via a L{Deferred}, a list with the results of the given\n    L{Deferred}s -\
    \ in effect, a \"join\" of multiple deferred operations.\n\n    The returned L{Deferred}\
    \ will fire when I{all} of the provided L{Deferred}s\n    have fired, or when\
    \ any one of them has failed.\n\n    This method can be cancelled by calling the\
    \ C{cancel} method of the\n    L{Deferred}, all the L{Deferred}s in the list will\
    \ be cancelled.\n\n    This differs from L{DeferredList} in that you don't need\
    \ to parse\n    the result for success/failure.\n\n    @param consumeErrors: (keyword\
    \ param) a flag, defaulting to False,\n        indicating that failures in any\
    \ of the given L{Deferred}s should not be\n        propagated to errbacks added\
    \ to the individual L{Deferred}s after this\n        L{gatherResults} invocation.\
    \  Any such errors in the individual\n        L{Deferred}s will be converted to\
    \ a callback result of L{None}.  This\n        is useful to prevent spurious 'Unhandled\
    \ error in Deferred' messages\n        from being logged.  This parameter is available\
    \ since 11.1.0.\n    \"\"\"\n    return DeferredList(\n        deferredList, fireOnOneErrback=True,\
    \ consumeErrors=consumeErrors\n    ).addCallback(_parseDeferredListResult)\n\n\
    \nclass FailureGroup(Exception):\n    \"\"\"\n    More than one failure occurred.\n\
    \    \"\"\"\n\n    def __init__(self, failures: Sequence[Failure]) -> None:\n\
    \        super(FailureGroup, self).__init__()\n        self.failures = failures\n\
    \n\ndef race(ds: Sequence[Deferred[_T]]) -> Deferred[tuple[int, _T]]:\n    \"\"\
    \"\n    Select the first available result from the sequence of Deferreds and\n\
    \    cancel the rest.\n\n    @return: A cancellable L{Deferred} that fires with\
    \ the index and output of\n        the element of C{ds} to have a success result\
    \ first, or that fires\n        with L{FailureGroup} holding a list of their failures\
    \ if they all\n        fail.\n    \"\"\"\n    # Keep track of the Deferred for\
    \ the action which completed first.  When\n    # it completes, all of the other\
    \ Deferreds will get cancelled but this one\n    # shouldn't be.  Even though\
    \ it \"completed\" it isn't really done - the\n    # caller will still be using\
    \ it for something.  If we cancelled it,\n    # cancellation could propagate down\
    \ to them.\n    winner: Optional[Deferred[_T]] = None\n\n    # The cancellation\
    \ function for the Deferred this function returns.\n    def cancel(result: Deferred[_T])\
    \ -> None:\n        # If it is cancelled then we cancel all of the Deferreds for\
    \ the\n        # individual actions because there is no longer the possibility\
    \ of\n        # delivering any of their results anywhere.  We don't have to fire\n\
    \        # `result` because the Deferred will do that for us.\n        for d in\
    \ to_cancel:\n            d.cancel()\n\n    # The Deferred that this function\
    \ will return.  It will fire with the\n    # index and output of the action that\
    \ completes first, or errback if all\n    # of the actions fail.  If it is cancelled,\
    \ all of the actions will be\n    # cancelled.\n    final_result: Deferred[tuple[int,\
    \ _T]] = Deferred(canceller=cancel)\n\n    # A callback for an individual action.\n\
    \    def succeeded(this_output: _T, this_index: int) -> None:\n        # If it\
    \ is the first action to succeed then it becomes the \"winner\",\n        # its\
    \ index/output become the externally visible result, and the rest\n        # of\
    \ the action Deferreds get cancelled.  If it is not the first\n        # action\
    \ to succeed (because some action did not support\n        # cancellation), just\
    \ ignore the result.  It is uncommon for this\n        # callback to be entered\
    \ twice.  The only way it can happen is if one\n        # of the input Deferreds\
    \ has a cancellation function that fires the\n        # Deferred with a success\
    \ result.\n        nonlocal winner\n        if winner is None:\n            #\
    \ This is the first success.  Act on it.\n            winner = to_cancel[this_index]\n\
    \n            # Cancel the rest.\n            for d in to_cancel:\n          \
    \      if d is not winner:\n                    d.cancel()\n\n            # Fire\
    \ our Deferred\n            final_result.callback((this_index, this_output))\n\
    \n    # Keep track of how many actions have failed.  If they all fail we need\
    \ to\n    # deliver failure notification on our externally visible result.\n \
    \   failure_state = []\n\n    def failed(failure: Failure, this_index: int) ->\
    \ None:\n        failure_state.append((this_index, failure))\n        if len(failure_state)\
    \ == len(to_cancel):\n            # Every operation failed.\n            failure_state.sort()\n\
    \            failures = [f for (ignored, f) in failure_state]\n            final_result.errback(FailureGroup(failures))\n\
    \n    # Copy the sequence of Deferreds so we know it doesn't get mutated out\n\
    \    # from under us.\n    to_cancel = list(ds)\n    for index, d in enumerate(ds):\n\
    \        # Propagate the position of this action as well as the argument to f\n\
    \        # to the success callback so we can cancel the right Deferreds and\n\
    \        # propagate the result outwards.\n        d.addCallbacks(succeeded, failed,\
    \ callbackArgs=(index,), errbackArgs=(index,))\n\n    return final_result\n\n\n\
    # Constants for use with DeferredList\nSUCCESS = True\nFAILURE = False\n\n\n##\
    \ inlineCallbacks\n\n\nclass _DefGen_Return(BaseException):\n    def __init__(self,\
    \ value: object) -> None:\n        self.value = value\n\n\n@deprecated(\n    Version(\"\
    Twisted\", 24, 7, 0),\n    replacement=\"standard return statement\",\n)\ndef\
    \ returnValue(val: object) -> NoReturn:\n    \"\"\"\n    Return val from a L{inlineCallbacks}\
    \ generator.\n\n    Note: this is currently implemented by raising an exception\n\
    \    derived from L{BaseException}.  You might want to change any\n    'except:'\
    \ clauses to an 'except Exception:' clause so as not to\n    catch this exception.\n\
    \n    Also: while this function currently will work when called from\n    within\
    \ arbitrary functions called from within the generator, do\n    not rely upon\
    \ this behavior.\n    \"\"\"\n    raise _DefGen_Return(val)\n\n\n@attr.s(auto_attribs=True)\n\
    class _CancellationStatus(Generic[_SelfResultT]):\n    \"\"\"\n    Cancellation\
    \ status of an L{inlineCallbacks} invocation.\n\n    @ivar deferred: the L{Deferred}\
    \ to callback or errback when the generator\n        invocation has finished.\n\
    \    @ivar waitingOn: the L{Deferred} being waited upon (which\n        L{_inlineCallbacks}\
    \ must fill out before returning)\n    \"\"\"\n\n    deferred: Deferred[_SelfResultT]\n\
    \    waitingOn: Optional[Deferred[_SelfResultT]] = None\n\n\ndef _gotResultInlineCallbacks(\n\
    \    r: object,\n    waiting: List[Any],\n    gen: Union[\n        Generator[Deferred[Any],\
    \ Any, _T],\n        Coroutine[Deferred[Any], Any, _T],\n    ],\n    status: _CancellationStatus[_T],\n\
    \    context: _Context,\n) -> None:\n    \"\"\"\n    Helper for L{_inlineCallbacks}\
    \ to handle a nested L{Deferred} firing.\n\n    @param r: The result of the L{Deferred}\n\
    \    @param waiting: Whether the L{_inlineCallbacks} was waiting, and the result.\n\
    \    @param gen: a generator object returned by calling a function or method\n\
    \        decorated with C{@}L{inlineCallbacks}\n    @param status: a L{_CancellationStatus}\
    \ tracking the current status of C{gen}\n    @param context: the contextvars context\
    \ to run `gen` in\n    \"\"\"\n    if waiting[0]:\n        waiting[0] = False\n\
    \        waiting[1] = r\n    else:\n        _inlineCallbacks(r, gen, status, context)\n\
    \n\n@_extraneous\ndef _inlineCallbacks(\n    result: object,\n    gen: Union[\n\
    \        Generator[Deferred[Any], Any, _T],\n        Coroutine[Deferred[Any],\
    \ Any, _T],\n    ],\n    status: _CancellationStatus[_T],\n    context: _Context,\n\
    ) -> None:\n    \"\"\"\n    Carry out the work of L{inlineCallbacks}.\n\n    Iterate\
    \ the generator produced by an C{@}L{inlineCallbacks}-decorated\n    function,\
    \ C{gen}, C{send()}ing it the results of each value C{yield}ed by\n    that generator,\
    \ until a L{Deferred} is yielded, at which point a callback\n    is added to that\
    \ L{Deferred} to call this function again.\n\n    @param result: The last result\
    \ seen by this generator.  Note that this is\n        never a L{Deferred} - by\
    \ the time this function is invoked, the\n        L{Deferred} has been called\
    \ back and this will be a particular result\n        at a point in its callback\
    \ chain.\n\n    @param gen: a generator object returned by calling a function\
    \ or method\n        decorated with C{@}L{inlineCallbacks}\n\n    @param status:\
    \ a L{_CancellationStatus} tracking the current status of C{gen}\n\n    @param\
    \ context: the contextvars context to run `gen` in\n    \"\"\"\n    # This function\
    \ is complicated by the need to prevent unbounded recursion\n    # arising from\
    \ repeatedly yielding immediately ready deferreds.  This while\n    # loop and\
    \ the waiting variable solve that by manually unfolding the\n    # recursion.\n\
    \n    # waiting for result?  # result\n    waiting: List[Any] = [True, None]\n\
    \n    stopIteration: bool = False\n    callbackValue: Any = None\n\n    while\
    \ 1:\n        try:\n            # Send the last result back as the result of the\
    \ yield expression.\n            isFailure = isinstance(result, Failure)\n\n \
    \           if isFailure:\n                result = context.run(\n           \
    \         cast(Failure, result).throwExceptionIntoGenerator, gen\n           \
    \     )\n            else:\n                result = context.run(gen.send, result)\n\
    \        except StopIteration as e:\n            # fell off the end, or \"return\"\
    \ statement\n            stopIteration = True\n            callbackValue = getattr(e,\
    \ \"value\", None)\n\n        except _DefGen_Return as e:\n            # returnValue()\
    \ was called; time to give a result to the original\n            # Deferred. \
    \ First though, let's try to identify the potentially\n            # confusing\
    \ situation which results when returnValue() is\n            # accidentally invoked\
    \ from a different function, one that wasn't\n            # decorated with @inlineCallbacks.\n\
    \n            # The traceback starts in this frame (the one for\n            #\
    \ _inlineCallbacks); the next one down should be the application\n           \
    \ # code.\n            excInfo = exc_info()\n            assert excInfo is not\
    \ None\n\n            traceback = excInfo[2]\n            assert traceback is\
    \ not None\n\n            appCodeTrace = traceback.tb_next\n            assert\
    \ appCodeTrace is not None\n\n            if _oldPypyStack:\n                #\
    \ PyPy versions through 7.3.13 add an extra frame; 7.3.14 fixed\n            \
    \    # this discrepancy with CPython.  This code can be removed once\n       \
    \         # we no longer need to support PyPy 7.3.13 or older.\n             \
    \   appCodeTrace = appCodeTrace.tb_next\n                assert appCodeTrace is\
    \ not None\n\n            if isFailure:\n                # If we invoked this\
    \ generator frame by throwing an exception\n                # into it, then throwExceptionIntoGenerator\
    \ will consume an\n                # additional stack frame itself, so we need\
    \ to skip that too.\n                appCodeTrace = appCodeTrace.tb_next\n   \
    \             assert appCodeTrace is not None\n\n            # Now that we've\
    \ identified the frame being exited by the\n            # exception, let's figure\
    \ out if returnValue was called from it\n            # directly.  returnValue\
    \ itself consumes a stack frame, so the\n            # application code will have\
    \ a tb_next, but it will *not* have a\n            # second tb_next.\n       \
    \     #\n            # Note that there's one additional level due to returnValue\
    \ being\n            # deprecated\n            assert appCodeTrace.tb_next is\
    \ not None\n            assert appCodeTrace.tb_next.tb_next is not None\n    \
    \        if appCodeTrace.tb_next.tb_next.tb_next:\n                # If returnValue\
    \ was invoked non-local to the frame which it is\n                # exiting, identify\
    \ the frame that ultimately invoked\n                # returnValue so that we\
    \ can warn the user, as this behavior is\n                # confusing.\n     \
    \           #\n                # Note that there's one additional level due to\
    \ returnValue being\n                # deprecated\n                ultimateTrace\
    \ = appCodeTrace\n\n                assert ultimateTrace is not None\n       \
    \         assert ultimateTrace.tb_next is not None\n\n                # Note that\
    \ there's one additional level due to returnValue being\n                # deprecated\n\
    \                assert ultimateTrace.tb_next.tb_next is not None\n          \
    \      while ultimateTrace.tb_next.tb_next.tb_next:\n                    ultimateTrace\
    \ = ultimateTrace.tb_next\n                    assert ultimateTrace is not None\n\
    \n                filename = ultimateTrace.tb_frame.f_code.co_filename\n     \
    \           lineno = ultimateTrace.tb_lineno\n\n                assert ultimateTrace.tb_frame\
    \ is not None\n                assert appCodeTrace.tb_frame is not None\n    \
    \            warnings.warn_explicit(\n                    \"returnValue() in %r\
    \ causing %r to exit: \"\n                    \"returnValue should only be invoked\
    \ by functions decorated \"\n                    \"with inlineCallbacks\"\n  \
    \                  % (\n                        ultimateTrace.tb_frame.f_code.co_name,\n\
    \                        appCodeTrace.tb_frame.f_code.co_name,\n             \
    \       ),\n                    DeprecationWarning,\n                    filename,\n\
    \                    lineno,\n                )\n\n            stopIteration =\
    \ True\n            callbackValue = e.value\n\n        except BaseException:\n\
    \            status.deferred.errback()\n            return\n\n        if stopIteration:\n\
    \            # Call the callback outside of the exception handler to avoid inappropriate/confusing\n\
    \            # \"During handling of the above exception, another exception occurred:\"\
    \ if the callback\n            # itself throws an exception.\n            status.deferred.callback(callbackValue)\n\
    \            return\n\n        isDeferred = type(result) in _DEFERRED_SUBCLASSES\n\
    \        # iscoroutine() is pretty expensive in this context, so avoid calling\n\
    \        # it unnecessarily:\n        if not isDeferred and (iscoroutine(result)\
    \ or inspect.isgenerator(result)):\n            result = _cancellableInlineCallbacks(result)\n\
    \            isDeferred = True\n\n        if isDeferred:\n            # We don't\
    \ cast() to Deferred because that does more work in the hot path\n\n         \
    \   # a deferred was yielded, get the result.\n            result.addBoth(_gotResultInlineCallbacks,\
    \ waiting, gen, status, context)  # type: ignore[attr-defined]\n            if\
    \ waiting[0]:\n                # Haven't called back yet, set flag so that we\
    \ get reinvoked\n                # and return from the loop\n                waiting[0]\
    \ = False\n                status.waitingOn = result  # type: ignore[assignment]\n\
    \                return\n\n            result = waiting[1]\n            # Reset\
    \ waiting to initial values for next loop.  gotResult uses\n            # waiting,\
    \ but this isn't a problem because gotResult is only\n            # executed once,\
    \ and if it hasn't been executed yet, the return\n            # branch above would\
    \ have been taken.\n\n            waiting[0] = True\n            waiting[1] =\
    \ None\n\n\ndef _addCancelCallbackToDeferred(\n    it: Deferred[_T], status: _CancellationStatus[_T]\n\
    ) -> None:\n    \"\"\"\n    Helper for L{_cancellableInlineCallbacks} to add\n\
    \    L{_handleCancelInlineCallbacks} as the first errback.\n\n    @param it: The\
    \ L{Deferred} to add the errback to.\n    @param status: a L{_CancellationStatus}\
    \ tracking the current status of C{gen}\n    \"\"\"\n    it._callbacks, tmp =\
    \ [], it._callbacks\n    it = it.addErrback(_handleCancelInlineCallbacks, status)\n\
    \    it._callbacks.extend(tmp)\n    it.errback(_InternalInlineCallbacksCancelledError())\n\
    \n\ndef _handleCancelInlineCallbacks(\n    result: Failure, status: _CancellationStatus[_T],\
    \ /\n) -> Deferred[_T]:\n    \"\"\"\n    Propagate the cancellation of an C{@}L{inlineCallbacks}\
    \ to the\n    L{Deferred} it is waiting on.\n\n    @param result: An L{_InternalInlineCallbacksCancelledError}\
    \ from\n        C{cancel()}.\n    @param status: a L{_CancellationStatus} tracking\
    \ the current status of C{gen}\n    @return: A new L{Deferred} that the C{@}L{inlineCallbacks}\
    \ generator\n        can callback or errback through.\n    \"\"\"\n    result.trap(_InternalInlineCallbacksCancelledError)\n\
    \    status.deferred = Deferred(lambda d: _addCancelCallbackToDeferred(d, status))\n\
    \n    # We would only end up here if the inlineCallback is waiting on\n    # another\
    \ Deferred.  It needs to be cancelled.\n    awaited = status.waitingOn\n    assert\
    \ awaited is not None\n    awaited.cancel()\n\n    return status.deferred\n\n\n\
    def _cancellableInlineCallbacks(\n    gen: Union[\n        Generator[Deferred[Any],\
    \ object, _T],\n        Coroutine[Deferred[Any], object, _T],\n    ]\n) -> Deferred[_T]:\n\
    \    \"\"\"\n    Make an C{@}L{inlineCallbacks} cancellable.\n\n    @param gen:\
    \ a generator object returned by calling a function or method\n        decorated\
    \ with C{@}L{inlineCallbacks}\n\n    @return: L{Deferred} for the C{@}L{inlineCallbacks}\
    \ that is cancellable.\n    \"\"\"\n\n    deferred: Deferred[_T] = Deferred(lambda\
    \ d: _addCancelCallbackToDeferred(d, status))\n    status = _CancellationStatus(deferred)\n\
    \n    _inlineCallbacks(None, gen, status, _copy_context())\n\n    return deferred\n\
    \n\nclass _InternalInlineCallbacksCancelledError(Exception):\n    \"\"\"\n   \
    \ A unique exception used only in L{_cancellableInlineCallbacks} to verify\n \
    \   that an L{inlineCallbacks} is being cancelled as expected.\n    \"\"\"\n\n\
    \ndef inlineCallbacks(\n    f: Callable[_P, Generator[Deferred[Any], Any, _T]]\n\
    ) -> Callable[_P, Deferred[_T]]:\n    \"\"\"\n    L{inlineCallbacks} helps you\
    \ write L{Deferred}-using code that looks like a\n    regular sequential function.\
    \ For example::\n\n        @inlineCallbacks\n        def thingummy():\n      \
    \      thing = yield makeSomeRequestResultingInDeferred()\n            print(thing)\
    \  # the result! hoorj!\n\n    When you call anything that results in a L{Deferred},\
    \ you can simply yield it;\n    your generator will automatically be resumed when\
    \ the Deferred's result is\n    available. The generator will be sent the result\
    \ of the L{Deferred} with the\n    'send' method on generators, or if the result\
    \ was a failure, 'throw'.\n\n    Things that are not L{Deferred}s may also be\
    \ yielded, and your generator\n    will be resumed with the same object sent back.\
    \ This means C{yield}\n    performs an operation roughly equivalent to L{maybeDeferred}.\n\
    \n    Your inlineCallbacks-enabled generator will return a L{Deferred} object,\
    \ which\n    will result in the return value of the generator (or will fail with\
    \ a\n    failure object if your generator raises an unhandled exception). Inside\n\
    \    the generator simply use C{return result} to return a value.\n\n    Be aware\
    \ that generator must not return a L{Deferred}.\n    If you believe the thing\
    \ you'd like to return could be a L{Deferred}, do\n    this::\n\n        result\
    \ = yield result\n        return result\n\n    The L{Deferred} returned from your\
    \ deferred generator may errback if your\n    generator raised an exception::\n\
    \n        @inlineCallbacks\n        def thingummy():\n            thing = yield\
    \ makeSomeRequestResultingInDeferred()\n            if thing == 'I love Twisted':\n\
    \                # will become the result of the Deferred\n                return\
    \ 'TWISTED IS GREAT!'\n            else:\n                # will trigger an errback\n\
    \                raise Exception('DESTROY ALL LIFE')\n\n    You can cancel the\
    \ L{Deferred} returned from your L{inlineCallbacks}\n    generator before it is\
    \ fired by your generator completing (either by\n    reaching its end, a C{return}\
    \ statement, or by calling L{returnValue}).\n    A C{CancelledError} will be raised\
    \ from the C{yield}ed L{Deferred} that\n    has been cancelled if that C{Deferred}\
    \ does not otherwise suppress it.\n\n    C{inlineCallbacks} behaves very similarly\
    \ to coroutines. Since Twisted 24.7.0\n    it is possible to rewrite functions\
    \ using C{inlineCallbacks} to C{async def}\n    in piecewise manner and be mostly\
    \ compatible to existing code.\n\n    The rewrite process is simply replacing\
    \ C{inlineCallbacks} decorator with\n    C{async def} and all C{yield} occurrences\
    \ in the function body with C{await}.\n    The function will no longer return\
    \ a C{Deferred} but a awaitable coroutine.\n    This return value will obviously\
    \ not have C{Deferred} methods such as\n    C{addCallback}, but it will be possible\
    \ to C{yield} it in other code based\n    on C{inlineCallbacks}.\n    \"\"\"\n\
    \n    @wraps(f)\n    def unwindGenerator(*args: _P.args, **kwargs: _P.kwargs)\
    \ -> Deferred[_T]:\n        try:\n            gen = f(*args, **kwargs)\n     \
    \   except _DefGen_Return:\n            raise TypeError(\n                \"inlineCallbacks\
    \ requires %r to produce a generator; instead\"\n                \"caught returnValue\
    \ being used in a non-generator\" % (f,)\n            )\n        if not isinstance(gen,\
    \ GeneratorType):\n            raise TypeError(\n                \"inlineCallbacks\
    \ requires %r to produce a generator; \"\n                \"instead got %r\" %\
    \ (f, gen)\n            )\n        return _cancellableInlineCallbacks(gen)\n\n\
    \    return unwindGenerator\n\n\n## DeferredLock/DeferredQueue\n\n\nclass _ConcurrencyPrimitive(ABC):\n\
    \    def __init__(self: Self) -> None:\n        self.waiting: List[Deferred[Self]]\
    \ = []\n\n    def _releaseAndReturn(self, r: _T) -> _T:\n        self.release()\n\
    \        return r\n\n    @overload\n    def run(\n        self: Self,\n      \
    \  /,\n        f: Callable[_P, Deferred[_T]],\n        *args: _P.args,\n     \
    \   **kwargs: _P.kwargs,\n    ) -> Deferred[_T]:\n        ...\n\n    @overload\n\
    \    def run(\n        self: Self,\n        /,\n        f: Callable[_P, Coroutine[Deferred[Any],\
    \ Any, _T]],\n        *args: _P.args,\n        **kwargs: _P.kwargs,\n    ) ->\
    \ Deferred[_T]:\n        ...\n\n    @overload\n    def run(\n        self: Self,\
    \ /, f: Callable[_P, _T], *args: _P.args, **kwargs: _P.kwargs\n    ) -> Deferred[_T]:\n\
    \        ...\n\n    def run(\n        self: Self,\n        /,\n        f: Callable[_P,\
    \ Union[Deferred[_T], Coroutine[Deferred[Any], Any, _T], _T]],\n        *args:\
    \ _P.args,\n        **kwargs: _P.kwargs,\n    ) -> Deferred[_T]:\n        \"\"\
    \"\n        Acquire, run, release.\n\n        This method takes a callable as\
    \ its first argument and any\n        number of other positional and keyword arguments.\
    \  When the\n        lock or semaphore is acquired, the callable will be invoked\n\
    \        with those arguments.\n\n        The callable may return a L{Deferred};\
    \ if it does, the lock or\n        semaphore won't be released until that L{Deferred}\
    \ fires.\n\n        @return: L{Deferred} of function result.\n        \"\"\"\n\
    \n        def execute(ignoredResult: object) -> Deferred[_T]:\n            # maybeDeferred\
    \ arg type requires one of the possible union members\n            # and won't\
    \ accept all possible union members\n            return maybeDeferred(f, *args,\
    \ **kwargs).addBoth(\n                self._releaseAndReturn\n            )  #\
    \ type: ignore[return-value]\n\n        return self.acquire().addCallback(execute)\n\
    \n    def __aenter__(self: Self) -> Deferred[Self]:\n        \"\"\"\n        We\
    \ can be used as an asynchronous context manager.\n        \"\"\"\n        return\
    \ self.acquire()\n\n    def __aexit__(\n        self,\n        __exc_type: Optional[Type[BaseException]],\n\
    \        __exc_value: Optional[BaseException],\n        __traceback: Optional[TracebackType],\n\
    \    ) -> Deferred[Literal[False]]:\n        self.release()\n        # We return\
    \ False to indicate that we have not consumed the\n        # exception, if any.\n\
    \        return succeed(False)\n\n    @abstractmethod\n    def acquire(self: Self)\
    \ -> Deferred[Self]:\n        pass\n\n    @abstractmethod\n    def release(self)\
    \ -> None:\n        pass\n\n\nclass DeferredLock(_ConcurrencyPrimitive):\n   \
    \ \"\"\"\n    A lock for event driven systems.\n\n    @ivar locked: C{True} when\
    \ this Lock has been acquired, false at all other\n        times.  Do not change\
    \ this value, but it is useful to examine for the\n        equivalent of a \"\
    non-blocking\" acquisition.\n    \"\"\"\n\n    locked = False\n\n    def _cancelAcquire(self:\
    \ Self, d: Deferred[Self]) -> None:\n        \"\"\"\n        Remove a deferred\
    \ d from our waiting list, as the deferred has been\n        canceled.\n\n   \
    \     Note: We do not need to wrap this in a try/except to catch d not\n     \
    \   being in self.waiting because this canceller will not be called if\n     \
    \   d has fired. release() pops a deferred out of self.waiting and\n        calls\
    \ it, so the canceller will no longer be called.\n\n        @param d: The deferred\
    \ that has been canceled.\n        \"\"\"\n        self.waiting.remove(d)\n\n\
    \    def acquire(self: Self) -> Deferred[Self]:\n        \"\"\"\n        Attempt\
    \ to acquire the lock.  Returns a L{Deferred} that fires on\n        lock acquisition\
    \ with the L{DeferredLock} as the value.  If the lock\n        is locked, then\
    \ the Deferred is placed at the end of a waiting list.\n\n        @return: a L{Deferred}\
    \ which fires on lock acquisition.\n        @rtype: a L{Deferred}\n        \"\"\
    \"\n        d: Deferred[Self] = Deferred(canceller=self._cancelAcquire)\n    \
    \    if self.locked:\n            self.waiting.append(d)\n        else:\n    \
    \        self.locked = True\n            d.callback(self)\n        return d\n\n\
    \    def release(self: Self) -> None:\n        \"\"\"\n        Release the lock.\
    \  If there is a waiting list, then the first\n        L{Deferred} in that waiting\
    \ list will be called back.\n\n        Should be called by whomever did the L{acquire}()\
    \ when the shared\n        resource is free.\n        \"\"\"\n        assert self.locked,\
    \ \"Tried to release an unlocked lock\"\n        self.locked = False\n       \
    \ if self.waiting:\n            # someone is waiting to acquire lock\n       \
    \     self.locked = True\n            d = self.waiting.pop(0)\n            d.callback(self)\n\
    \n\nclass DeferredSemaphore(_ConcurrencyPrimitive):\n    \"\"\"\n    A semaphore\
    \ for event driven systems.\n\n    If you are looking into this as a means of\
    \ limiting parallelism, you might\n    find L{twisted.internet.task.Cooperator}\
    \ more useful.\n\n    @ivar limit: At most this many users may acquire this semaphore\
    \ at\n        once.\n    @ivar tokens: The difference between C{limit} and the\
    \ number of users\n        which have currently acquired this semaphore.\n   \
    \ \"\"\"\n\n    def __init__(self, tokens: int) -> None:\n        \"\"\"\n   \
    \     @param tokens: initial value of L{tokens} and L{limit}\n        @type tokens:\
    \ L{int}\n        \"\"\"\n        _ConcurrencyPrimitive.__init__(self)\n     \
    \   if tokens < 1:\n            raise ValueError(\"DeferredSemaphore requires\
    \ tokens >= 1\")\n        self.tokens = tokens\n        self.limit = tokens\n\n\
    \    def _cancelAcquire(self: Self, d: Deferred[Self]) -> None:\n        \"\"\"\
    \n        Remove a deferred d from our waiting list, as the deferred has been\n\
    \        canceled.\n\n        Note: We do not need to wrap this in a try/except\
    \ to catch d not\n        being in self.waiting because this canceller will not\
    \ be called if\n        d has fired. release() pops a deferred out of self.waiting\
    \ and\n        calls it, so the canceller will no longer be called.\n\n      \
    \  @param d: The deferred that has been canceled.\n        \"\"\"\n        self.waiting.remove(d)\n\
    \n    def acquire(self: Self) -> Deferred[Self]:\n        \"\"\"\n        Attempt\
    \ to acquire the token.\n\n        @return: a L{Deferred} which fires on token\
    \ acquisition.\n        \"\"\"\n        assert (\n            self.tokens >= 0\n\
    \        ), \"Internal inconsistency??  tokens should never be negative\"\n  \
    \      d: Deferred[Self] = Deferred(canceller=self._cancelAcquire)\n        if\
    \ not self.tokens:\n            self.waiting.append(d)\n        else:\n      \
    \      self.tokens = self.tokens - 1\n            d.callback(self)\n        return\
    \ d\n\n    def release(self: Self) -> None:\n        \"\"\"\n        Release the\
    \ token.\n\n        Should be called by whoever did the L{acquire}() when the\
    \ shared\n        resource is free.\n        \"\"\"\n        assert (\n      \
    \      self.tokens < self.limit\n        ), \"Someone released me too many times:\
    \ too many tokens!\"\n        self.tokens = self.tokens + 1\n        if self.waiting:\n\
    \            # someone is waiting to acquire token\n            self.tokens =\
    \ self.tokens - 1\n            d = self.waiting.pop(0)\n            d.callback(self)\n\
    \n\nclass QueueOverflow(Exception):\n    pass\n\n\nclass QueueUnderflow(Exception):\n\
    \    pass\n\n\nclass DeferredQueue(Generic[_T]):\n    \"\"\"\n    An event driven\
    \ queue.\n\n    Objects may be added as usual to this queue.  When an attempt\
    \ is\n    made to retrieve an object when the queue is empty, a L{Deferred} is\n\
    \    returned which will fire when an object becomes available.\n\n    @ivar size:\
    \ The maximum number of objects to allow into the queue\n        at a time.  When\
    \ an attempt to add a new object would exceed this\n        limit, L{QueueOverflow}\
    \ is raised synchronously.  L{None} for no limit.\n    @ivar backlog: The maximum\
    \ number of L{Deferred} gets to allow at\n        one time.  When an attempt is\
    \ made to get an object which would\n        exceed this limit, L{QueueUnderflow}\
    \ is raised synchronously.  L{None}\n        for no limit.\n    \"\"\"\n\n   \
    \ def __init__(\n        self, size: Optional[int] = None, backlog: Optional[int]\
    \ = None\n    ) -> None:\n        self.waiting: List[Deferred[_T]] = []\n    \
    \    self.pending: List[_T] = []\n        self.size = size\n        self.backlog\
    \ = backlog\n\n    def _cancelGet(self, d: Deferred[_T]) -> None:\n        \"\"\
    \"\n        Remove a deferred d from our waiting list, as the deferred has been\n\
    \        canceled.\n\n        Note: We do not need to wrap this in a try/except\
    \ to catch d not\n        being in self.waiting because this canceller will not\
    \ be called if\n        d has fired. put() pops a deferred out of self.waiting\
    \ and calls\n        it, so the canceller will no longer be called.\n\n      \
    \  @param d: The deferred that has been canceled.\n        \"\"\"\n        self.waiting.remove(d)\n\
    \n    def put(self, obj: _T) -> None:\n        \"\"\"\n        Add an object to\
    \ this queue.\n\n        @raise QueueOverflow: Too many objects are in this queue.\n\
    \        \"\"\"\n        if self.waiting:\n            self.waiting.pop(0).callback(obj)\n\
    \        elif self.size is None or len(self.pending) < self.size:\n          \
    \  self.pending.append(obj)\n        else:\n            raise QueueOverflow()\n\
    \n    def get(self) -> Deferred[_T]:\n        \"\"\"\n        Attempt to retrieve\
    \ and remove an object from the queue.\n\n        @return: a L{Deferred} which\
    \ fires with the next object available in\n        the queue.\n\n        @raise\
    \ QueueUnderflow: Too many (more than C{backlog})\n        L{Deferred}s are already\
    \ waiting for an object from this queue.\n        \"\"\"\n        if self.pending:\n\
    \            return succeed(self.pending.pop(0))\n        elif self.backlog is\
    \ None or len(self.waiting) < self.backlog:\n            d: Deferred[_T] = Deferred(canceller=self._cancelGet)\n\
    \            self.waiting.append(d)\n            return d\n        else:\n   \
    \         raise QueueUnderflow()\n\n\nclass AlreadyTryingToLockError(Exception):\n\
    \    \"\"\"\n    Raised when L{DeferredFilesystemLock.deferUntilLocked} is called\
    \ twice on a\n    single L{DeferredFilesystemLock}.\n    \"\"\"\n\n\nclass DeferredFilesystemLock(lockfile.FilesystemLock):\n\
    \    \"\"\"\n    A L{FilesystemLock} that allows for a L{Deferred} to be fired\
    \ when the lock is\n    acquired.\n\n    @ivar _scheduler: The object in charge\
    \ of scheduling retries. In this\n        implementation this is parameterized\
    \ for testing.\n    @ivar _interval: The retry interval for an L{IReactorTime}\
    \ based scheduler.\n    @ivar _tryLockCall: An L{IDelayedCall} based on C{_interval}\
    \ that will manage\n        the next retry for acquiring the lock.\n    @ivar\
    \ _timeoutCall: An L{IDelayedCall} based on C{deferUntilLocked}'s timeout\n  \
    \      argument.  This is in charge of timing out our attempt to acquire the\n\
    \        lock.\n    \"\"\"\n\n    _interval = 1\n    _tryLockCall: Optional[IDelayedCall]\
    \ = None\n    _timeoutCall: Optional[IDelayedCall] = None\n\n    def __init__(self,\
    \ name: str, scheduler: Optional[IReactorTime] = None) -> None:\n        \"\"\"\
    \n        @param name: The name of the lock to acquire\n        @param scheduler:\
    \ An object which provides L{IReactorTime}\n        \"\"\"\n        lockfile.FilesystemLock.__init__(self,\
    \ name)\n\n        if scheduler is None:\n            from twisted.internet import\
    \ reactor\n\n            scheduler = cast(IReactorTime, reactor)\n\n        self._scheduler\
    \ = scheduler\n\n    def deferUntilLocked(self, timeout: Optional[float] = None)\
    \ -> Deferred[None]:\n        \"\"\"\n        Wait until we acquire this lock.\
    \  This method is not safe for\n        concurrent use.\n\n        @param timeout:\
    \ the number of seconds after which to time out if the\n            lock has not\
    \ been acquired.\n\n        @return: a L{Deferred} which will callback when the\
    \ lock is acquired, or\n            errback with a L{TimeoutError} after timing\
    \ out or an\n            L{AlreadyTryingToLockError} if the L{deferUntilLocked}\
    \ has already\n            been called and not successfully locked the file.\n\
    \        \"\"\"\n        if self._tryLockCall is not None:\n            return\
    \ fail(\n                AlreadyTryingToLockError(\n                    \"deferUntilLocked\
    \ isn't safe for concurrent use.\"\n                )\n            )\n\n     \
    \   def _cancelLock(reason: Union[Failure, Exception]) -> None:\n            \"\
    \"\"\n            Cancel a L{DeferredFilesystemLock.deferUntilLocked} call.\n\n\
    \            @type reason: L{Failure}\n            @param reason: The reason why\
    \ the call is cancelled.\n            \"\"\"\n            assert self._tryLockCall\
    \ is not None\n            self._tryLockCall.cancel()\n            self._tryLockCall\
    \ = None\n            if self._timeoutCall is not None and self._timeoutCall.active():\n\
    \                self._timeoutCall.cancel()\n                self._timeoutCall\
    \ = None\n\n            if self.lock():\n                d.callback(None)\n  \
    \          else:\n                d.errback(reason)\n\n        d: Deferred[None]\
    \ = Deferred(lambda deferred: _cancelLock(CancelledError()))\n\n        def _tryLock()\
    \ -> None:\n            if self.lock():\n                if self._timeoutCall\
    \ is not None:\n                    self._timeoutCall.cancel()\n             \
    \       self._timeoutCall = None\n\n                self._tryLockCall = None\n\
    \n                d.callback(None)\n            else:\n                if timeout\
    \ is not None and self._timeoutCall is None:\n                    reason = Failure(\n\
    \                        TimeoutError(\n                            \"Timed out\
    \ acquiring lock: %s after %fs\"\n                            % (self.name, timeout)\n\
    \                        )\n                    )\n                    self._timeoutCall\
    \ = self._scheduler.callLater(\n                        timeout, _cancelLock,\
    \ reason\n                    )\n\n                self._tryLockCall = self._scheduler.callLater(self._interval,\
    \ _tryLock)\n\n        _tryLock()\n\n        return d\n\n\n__all__ = [\n    \"\
    Deferred\",\n    \"DeferredList\",\n    \"succeed\",\n    \"fail\",\n    \"FAILURE\"\
    ,\n    \"SUCCESS\",\n    \"AlreadyCalledError\",\n    \"TimeoutError\",\n    \"\
    gatherResults\",\n    \"maybeDeferred\",\n    \"ensureDeferred\",\n    \"inlineCallbacks\"\
    ,\n    \"returnValue\",\n    \"DeferredLock\",\n    \"DeferredSemaphore\",\n \
    \   \"DeferredQueue\",\n    \"DeferredFilesystemLock\",\n    \"AlreadyTryingToLockError\"\
    ,\n    \"CancelledError\",\n]\n\n\n### Dependency File: policies.py\n# -*- test-case-name:\
    \ twisted.test.test_policies -*-\n# Copyright (c) Twisted Matrix Laboratories.\n\
    # See LICENSE for details.\n\n\"\"\"\nResource limiting policies.\n\n@seealso:\
    \ See also L{twisted.protocols.htb} for rate limiting.\n\"\"\"\n\n\n# system imports\n\
    import sys\nfrom typing import Optional, Type\n\nfrom zope.interface import directlyProvides,\
    \ providedBy\n\nfrom twisted.internet import error, interfaces\nfrom twisted.internet.interfaces\
    \ import ILoggingContext\n\n# twisted imports\nfrom twisted.internet.protocol\
    \ import ClientFactory, Protocol, ServerFactory\nfrom twisted.python import log\n\
    \n\ndef _wrappedLogPrefix(wrapper, wrapped):\n    \"\"\"\n    Compute a log prefix\
    \ for a wrapper and the object it wraps.\n\n    @rtype: C{str}\n    \"\"\"\n \
    \   if ILoggingContext.providedBy(wrapped):\n        logPrefix = wrapped.logPrefix()\n\
    \    else:\n        logPrefix = wrapped.__class__.__name__\n    return f\"{logPrefix}\
    \ ({wrapper.__class__.__name__})\"\n\n\nclass ProtocolWrapper(Protocol):\n   \
    \ \"\"\"\n    Wraps protocol instances and acts as their transport as well.\n\n\
    \    @ivar wrappedProtocol: An L{IProtocol<twisted.internet.interfaces.IProtocol>}\n\
    \        provider to which L{IProtocol<twisted.internet.interfaces.IProtocol>}\n\
    \        method calls onto this L{ProtocolWrapper} will be proxied.\n\n    @ivar\
    \ factory: The L{WrappingFactory} which created this\n        L{ProtocolWrapper}.\n\
    \    \"\"\"\n\n    disconnecting = 0\n\n    def __init__(\n        self, factory:\
    \ \"WrappingFactory\", wrappedProtocol: interfaces.IProtocol\n    ):\n       \
    \ self.wrappedProtocol = wrappedProtocol\n        self.factory = factory\n\n \
    \   def logPrefix(self):\n        \"\"\"\n        Use a customized log prefix\
    \ mentioning both the wrapped protocol and\n        the current one.\n       \
    \ \"\"\"\n        return _wrappedLogPrefix(self, self.wrappedProtocol)\n\n   \
    \ def makeConnection(self, transport):\n        \"\"\"\n        When a connection\
    \ is made, register this wrapper with its factory,\n        save the real transport,\
    \ and connect the wrapped protocol to this\n        L{ProtocolWrapper} to intercept\
    \ any transport calls it makes.\n        \"\"\"\n        directlyProvides(self,\
    \ providedBy(transport))\n        Protocol.makeConnection(self, transport)\n \
    \       self.factory.registerProtocol(self)\n        self.wrappedProtocol.makeConnection(self)\n\
    \n    # Transport relaying\n\n    def write(self, data):\n        self.transport.write(data)\n\
    \n    def writeSequence(self, data):\n        self.transport.writeSequence(data)\n\
    \n    def loseConnection(self):\n        self.disconnecting = 1\n        self.transport.loseConnection()\n\
    \n    def getPeer(self):\n        return self.transport.getPeer()\n\n    def getHost(self):\n\
    \        return self.transport.getHost()\n\n    def registerProducer(self, producer,\
    \ streaming):\n        self.transport.registerProducer(producer, streaming)\n\n\
    \    def unregisterProducer(self):\n        self.transport.unregisterProducer()\n\
    \n    def stopConsuming(self):\n        self.transport.stopConsuming()\n\n   \
    \ def __getattr__(self, name):\n        return getattr(self.transport, name)\n\
    \n    # Protocol relaying\n\n    def dataReceived(self, data):\n        self.wrappedProtocol.dataReceived(data)\n\
    \n    def connectionLost(self, reason):\n        self.factory.unregisterProtocol(self)\n\
    \        self.wrappedProtocol.connectionLost(reason)\n\n        # Breaking reference\
    \ cycle between self and wrappedProtocol.\n        self.wrappedProtocol = None\n\
    \n\nclass WrappingFactory(ClientFactory):\n    \"\"\"\n    Wraps a factory and\
    \ its protocols, and keeps track of them.\n    \"\"\"\n\n    protocol: Type[Protocol]\
    \ = ProtocolWrapper\n\n    def __init__(self, wrappedFactory):\n        self.wrappedFactory\
    \ = wrappedFactory\n        self.protocols = {}\n\n    def logPrefix(self):\n\
    \        \"\"\"\n        Generate a log prefix mentioning both the wrapped factory\
    \ and this one.\n        \"\"\"\n        return _wrappedLogPrefix(self, self.wrappedFactory)\n\
    \n    def doStart(self):\n        self.wrappedFactory.doStart()\n        ClientFactory.doStart(self)\n\
    \n    def doStop(self):\n        self.wrappedFactory.doStop()\n        ClientFactory.doStop(self)\n\
    \n    def startedConnecting(self, connector):\n        self.wrappedFactory.startedConnecting(connector)\n\
    \n    def clientConnectionFailed(self, connector, reason):\n        self.wrappedFactory.clientConnectionFailed(connector,\
    \ reason)\n\n    def clientConnectionLost(self, connector, reason):\n        self.wrappedFactory.clientConnectionLost(connector,\
    \ reason)\n\n    def buildProtocol(self, addr):\n        return self.protocol(self,\
    \ self.wrappedFactory.buildProtocol(addr))\n\n    def registerProtocol(self, p):\n\
    \        \"\"\"\n        Called by protocol to register itself.\n        \"\"\"\
    \n        self.protocols[p] = 1\n\n    def unregisterProtocol(self, p):\n    \
    \    \"\"\"\n        Called by protocols when they go away.\n        \"\"\"\n\
    \        del self.protocols[p]\n\n\nclass ThrottlingProtocol(ProtocolWrapper):\n\
    \    \"\"\"\n    Protocol for L{ThrottlingFactory}.\n    \"\"\"\n\n    # wrap\
    \ API for tracking bandwidth\n\n    def write(self, data):\n        self.factory.registerWritten(len(data))\n\
    \        ProtocolWrapper.write(self, data)\n\n    def writeSequence(self, seq):\n\
    \        self.factory.registerWritten(sum(map(len, seq)))\n        ProtocolWrapper.writeSequence(self,\
    \ seq)\n\n    def dataReceived(self, data):\n        self.factory.registerRead(len(data))\n\
    \        ProtocolWrapper.dataReceived(self, data)\n\n    def registerProducer(self,\
    \ producer, streaming):\n        self.producer = producer\n        ProtocolWrapper.registerProducer(self,\
    \ producer, streaming)\n\n    def unregisterProducer(self):\n        del self.producer\n\
    \        ProtocolWrapper.unregisterProducer(self)\n\n    def throttleReads(self):\n\
    \        self.transport.pauseProducing()\n\n    def unthrottleReads(self):\n \
    \       self.transport.resumeProducing()\n\n    def throttleWrites(self):\n  \
    \      if hasattr(self, \"producer\"):\n            self.producer.pauseProducing()\n\
    \n    def unthrottleWrites(self):\n        if hasattr(self, \"producer\"):\n \
    \           self.producer.resumeProducing()\n\n\nclass ThrottlingFactory(WrappingFactory):\n\
    \    \"\"\"\n    Throttles bandwidth and number of connections.\n\n    Write bandwidth\
    \ will only be throttled if there is a producer\n    registered.\n    \"\"\"\n\
    \n    protocol = ThrottlingProtocol\n\n    def __init__(\n        self,\n    \
    \    wrappedFactory,\n        maxConnectionCount=sys.maxsize,\n        readLimit=None,\n\
    \        writeLimit=None,\n    ):\n        WrappingFactory.__init__(self, wrappedFactory)\n\
    \        self.connectionCount = 0\n        self.maxConnectionCount = maxConnectionCount\n\
    \        self.readLimit = readLimit  # max bytes we should read per second\n \
    \       self.writeLimit = writeLimit  # max bytes we should write per second\n\
    \        self.readThisSecond = 0\n        self.writtenThisSecond = 0\n       \
    \ self.unthrottleReadsID = None\n        self.checkReadBandwidthID = None\n  \
    \      self.unthrottleWritesID = None\n        self.checkWriteBandwidthID = None\n\
    \n    def callLater(self, period, func):\n        \"\"\"\n        Wrapper around\n\
    \        L{reactor.callLater<twisted.internet.interfaces.IReactorTime.callLater>}\n\
    \        for test purpose.\n        \"\"\"\n        from twisted.internet import\
    \ reactor\n\n        return reactor.callLater(period, func)\n\n    def registerWritten(self,\
    \ length):\n        \"\"\"\n        Called by protocol to tell us more bytes were\
    \ written.\n        \"\"\"\n        self.writtenThisSecond += length\n\n    def\
    \ registerRead(self, length):\n        \"\"\"\n        Called by protocol to tell\
    \ us more bytes were read.\n        \"\"\"\n        self.readThisSecond += length\n\
    \n    def checkReadBandwidth(self):\n        \"\"\"\n        Checks if we've passed\
    \ bandwidth limits.\n        \"\"\"\n        if self.readThisSecond > self.readLimit:\n\
    \            self.throttleReads()\n            throttleTime = (float(self.readThisSecond)\
    \ / self.readLimit) - 1.0\n            self.unthrottleReadsID = self.callLater(throttleTime,\
    \ self.unthrottleReads)\n        self.readThisSecond = 0\n        self.checkReadBandwidthID\
    \ = self.callLater(1, self.checkReadBandwidth)\n\n    def checkWriteBandwidth(self):\n\
    \        if self.writtenThisSecond > self.writeLimit:\n            self.throttleWrites()\n\
    \            throttleTime = (float(self.writtenThisSecond) / self.writeLimit)\
    \ - 1.0\n            self.unthrottleWritesID = self.callLater(\n             \
    \   throttleTime, self.unthrottleWrites\n            )\n        # reset for next\
    \ round\n        self.writtenThisSecond = 0\n        self.checkWriteBandwidthID\
    \ = self.callLater(1, self.checkWriteBandwidth)\n\n    def throttleReads(self):\n\
    \        \"\"\"\n        Throttle reads on all protocols.\n        \"\"\"\n  \
    \      log.msg(\"Throttling reads on %s\" % self)\n        for p in self.protocols.keys():\n\
    \            p.throttleReads()\n\n    def unthrottleReads(self):\n        \"\"\
    \"\n        Stop throttling reads on all protocols.\n        \"\"\"\n        self.unthrottleReadsID\
    \ = None\n        log.msg(\"Stopped throttling reads on %s\" % self)\n       \
    \ for p in self.protocols.keys():\n            p.unthrottleReads()\n\n    def\
    \ throttleWrites(self):\n        \"\"\"\n        Throttle writes on all protocols.\n\
    \        \"\"\"\n        log.msg(\"Throttling writes on %s\" % self)\n       \
    \ for p in self.protocols.keys():\n            p.throttleWrites()\n\n    def unthrottleWrites(self):\n\
    \        \"\"\"\n        Stop throttling writes on all protocols.\n        \"\"\
    \"\n        self.unthrottleWritesID = None\n        log.msg(\"Stopped throttling\
    \ writes on %s\" % self)\n        for p in self.protocols.keys():\n          \
    \  p.unthrottleWrites()\n\n    def buildProtocol(self, addr):\n        if self.connectionCount\
    \ == 0:\n            if self.readLimit is not None:\n                self.checkReadBandwidth()\n\
    \            if self.writeLimit is not None:\n                self.checkWriteBandwidth()\n\
    \n        if self.connectionCount < self.maxConnectionCount:\n            self.connectionCount\
    \ += 1\n            return WrappingFactory.buildProtocol(self, addr)\n       \
    \ else:\n            log.msg(\"Max connection count reached!\")\n            return\
    \ None\n\n    def unregisterProtocol(self, p):\n        WrappingFactory.unregisterProtocol(self,\
    \ p)\n        self.connectionCount -= 1\n        if self.connectionCount == 0:\n\
    \            if self.unthrottleReadsID is not None:\n                self.unthrottleReadsID.cancel()\n\
    \            if self.checkReadBandwidthID is not None:\n                self.checkReadBandwidthID.cancel()\n\
    \            if self.unthrottleWritesID is not None:\n                self.unthrottleWritesID.cancel()\n\
    \            if self.checkWriteBandwidthID is not None:\n                self.checkWriteBandwidthID.cancel()\n\
    \n\nclass SpewingProtocol(ProtocolWrapper):\n    def dataReceived(self, data):\n\
    \        log.msg(\"Received: %r\" % data)\n        ProtocolWrapper.dataReceived(self,\
    \ data)\n\n    def write(self, data):\n        log.msg(\"Sending: %r\" % data)\n\
    \        ProtocolWrapper.write(self, data)\n\n\nclass SpewingFactory(WrappingFactory):\n\
    \    protocol = SpewingProtocol\n\n\nclass LimitConnectionsByPeer(WrappingFactory):\n\
    \    maxConnectionsPerPeer = 5\n\n    def startFactory(self):\n        self.peerConnections\
    \ = {}\n\n    def buildProtocol(self, addr):\n        peerHost = addr[0]\n   \
    \     connectionCount = self.peerConnections.get(peerHost, 0)\n        if connectionCount\
    \ >= self.maxConnectionsPerPeer:\n            return None\n        self.peerConnections[peerHost]\
    \ = connectionCount + 1\n        return WrappingFactory.buildProtocol(self, addr)\n\
    \n    def unregisterProtocol(self, p):\n        peerHost = p.getPeer()[1]\n  \
    \      self.peerConnections[peerHost] -= 1\n        if self.peerConnections[peerHost]\
    \ == 0:\n            del self.peerConnections[peerHost]\n\n\nclass LimitTotalConnectionsFactory(ServerFactory):\n\
    \    \"\"\"\n    Factory that limits the number of simultaneous connections.\n\
    \n    @type connectionCount: C{int}\n    @ivar connectionCount: number of current\
    \ connections.\n    @type connectionLimit: C{int} or L{None}\n    @cvar connectionLimit:\
    \ maximum number of connections.\n    @type overflowProtocol: L{Protocol} or L{None}\n\
    \    @cvar overflowProtocol: Protocol to use for new connections when\n      \
    \  connectionLimit is exceeded.  If L{None} (the default value), excess\n    \
    \    connections will be closed immediately.\n    \"\"\"\n\n    connectionCount\
    \ = 0\n    connectionLimit = None\n    overflowProtocol: Optional[Type[Protocol]]\
    \ = None\n\n    def buildProtocol(self, addr):\n        if self.connectionLimit\
    \ is None or self.connectionCount < self.connectionLimit:\n            # Build\
    \ the normal protocol\n            wrappedProtocol = self.protocol()\n       \
    \ elif self.overflowProtocol is None:\n            # Just drop the connection\n\
    \            return None\n        else:\n            # Too many connections, so\
    \ build the overflow protocol\n            wrappedProtocol = self.overflowProtocol()\n\
    \n        wrappedProtocol.factory = self\n        protocol = ProtocolWrapper(self,\
    \ wrappedProtocol)\n        self.connectionCount += 1\n        return protocol\n\
    \n    def registerProtocol(self, p):\n        pass\n\n    def unregisterProtocol(self,\
    \ p):\n        self.connectionCount -= 1\n\n\nclass TimeoutProtocol(ProtocolWrapper):\n\
    \    \"\"\"\n    Protocol that automatically disconnects when the connection is\
    \ idle.\n    \"\"\"\n\n    def __init__(self, factory, wrappedProtocol, timeoutPeriod):\n\
    \        \"\"\"\n        Constructor.\n\n        @param factory: An L{TimeoutFactory}.\n\
    \        @param wrappedProtocol: A L{Protocol} to wrapp.\n        @param timeoutPeriod:\
    \ Number of seconds to wait for activity before\n            timing out.\n   \
    \     \"\"\"\n        ProtocolWrapper.__init__(self, factory, wrappedProtocol)\n\
    \        self.timeoutCall = None\n        self.timeoutPeriod = None\n        self.setTimeout(timeoutPeriod)\n\
    \n    def setTimeout(self, timeoutPeriod=None):\n        \"\"\"\n        Set a\
    \ timeout.\n\n        This will cancel any existing timeouts.\n\n        @param\
    \ timeoutPeriod: If not L{None}, change the timeout period.\n            Otherwise,\
    \ use the existing value.\n        \"\"\"\n        self.cancelTimeout()\n    \
    \    self.timeoutPeriod = timeoutPeriod\n        if timeoutPeriod is not None:\n\
    \            self.timeoutCall = self.factory.callLater(\n                self.timeoutPeriod,\
    \ self.timeoutFunc\n            )\n\n    def cancelTimeout(self):\n        \"\"\
    \"\n        Cancel the timeout.\n\n        If the timeout was already cancelled,\
    \ this does nothing.\n        \"\"\"\n        self.timeoutPeriod = None\n    \
    \    if self.timeoutCall:\n            try:\n                self.timeoutCall.cancel()\n\
    \            except (error.AlreadyCalled, error.AlreadyCancelled):\n         \
    \       pass\n            self.timeoutCall = None\n\n    def resetTimeout(self):\n\
    \        \"\"\"\n        Reset the timeout, usually because some activity just\
    \ happened.\n        \"\"\"\n        if self.timeoutCall:\n            self.timeoutCall.reset(self.timeoutPeriod)\n\
    \n    def write(self, data):\n        self.resetTimeout()\n        ProtocolWrapper.write(self,\
    \ data)\n\n    def writeSequence(self, seq):\n        self.resetTimeout()\n  \
    \      ProtocolWrapper.writeSequence(self, seq)\n\n    def dataReceived(self,\
    \ data):\n        self.resetTimeout()\n        ProtocolWrapper.dataReceived(self,\
    \ data)\n\n    def connectionLost(self, reason):\n        self.cancelTimeout()\n\
    \        ProtocolWrapper.connectionLost(self, reason)\n\n    def timeoutFunc(self):\n\
    \        \"\"\"\n        This method is called when the timeout is triggered.\n\
    \n        By default it calls I{loseConnection}.  Override this if you want\n\
    \        something else to happen.\n        \"\"\"\n        self.loseConnection()\n\
    \n\nclass TimeoutFactory(WrappingFactory):\n    \"\"\"\n    Factory for TimeoutWrapper.\n\
    \    \"\"\"\n\n    protocol = TimeoutProtocol\n\n    def __init__(self, wrappedFactory,\
    \ timeoutPeriod=30 * 60):\n        self.timeoutPeriod = timeoutPeriod\n      \
    \  WrappingFactory.__init__(self, wrappedFactory)\n\n    def buildProtocol(self,\
    \ addr):\n        return self.protocol(\n            self,\n            self.wrappedFactory.buildProtocol(addr),\n\
    \            timeoutPeriod=self.timeoutPeriod,\n        )\n\n    def callLater(self,\
    \ period, func):\n        \"\"\"\n        Wrapper around\n        L{reactor.callLater<twisted.internet.interfaces.IReactorTime.callLater>}\n\
    \        for test purpose.\n        \"\"\"\n        from twisted.internet import\
    \ reactor\n\n        return reactor.callLater(period, func)\n\n\nclass TrafficLoggingProtocol(ProtocolWrapper):\n\
    \    def __init__(self, factory, wrappedProtocol, logfile, lengthLimit=None, number=0):\n\
    \        \"\"\"\n        @param factory: factory which created this protocol.\n\
    \        @type factory: L{protocol.Factory}.\n        @param wrappedProtocol:\
    \ the underlying protocol.\n        @type wrappedProtocol: C{protocol.Protocol}.\n\
    \        @param logfile: file opened for writing used to write log messages.\n\
    \        @type logfile: C{file}\n        @param lengthLimit: maximum size of the\
    \ datareceived logged.\n        @type lengthLimit: C{int}\n        @param number:\
    \ identifier of the connection.\n        @type number: C{int}.\n        \"\"\"\
    \n        ProtocolWrapper.__init__(self, factory, wrappedProtocol)\n        self.logfile\
    \ = logfile\n        self.lengthLimit = lengthLimit\n        self._number = number\n\
    \n    def _log(self, line):\n        self.logfile.write(line + \"\\n\")\n    \
    \    self.logfile.flush()\n\n    def _mungeData(self, data):\n        if self.lengthLimit\
    \ and len(data) > self.lengthLimit:\n            data = data[: self.lengthLimit\
    \ - 12] + \"<... elided>\"\n        return data\n\n    # IProtocol\n    def connectionMade(self):\n\
    \        self._log(\"*\")\n        return ProtocolWrapper.connectionMade(self)\n\
    \n    def dataReceived(self, data):\n        self._log(\"C %d: %r\" % (self._number,\
    \ self._mungeData(data)))\n        return ProtocolWrapper.dataReceived(self, data)\n\
    \n    def connectionLost(self, reason):\n        self._log(\"C %d: %r\" % (self._number,\
    \ reason))\n        return ProtocolWrapper.connectionLost(self, reason)\n\n  \
    \  # ITransport\n    def write(self, data):\n        self._log(\"S %d: %r\" %\
    \ (self._number, self._mungeData(data)))\n        return ProtocolWrapper.write(self,\
    \ data)\n\n    def writeSequence(self, iovec):\n        self._log(\"SV %d: %r\"\
    \ % (self._number, [self._mungeData(d) for d in iovec]))\n        return ProtocolWrapper.writeSequence(self,\
    \ iovec)\n\n    def loseConnection(self):\n        self._log(\"S %d: *\" % (self._number,))\n\
    \        return ProtocolWrapper.loseConnection(self)\n\n\nclass TrafficLoggingFactory(WrappingFactory):\n\
    \    protocol = TrafficLoggingProtocol\n\n    _counter = 0\n\n    def __init__(self,\
    \ wrappedFactory, logfilePrefix, lengthLimit=None):\n        self.logfilePrefix\
    \ = logfilePrefix\n        self.lengthLimit = lengthLimit\n        WrappingFactory.__init__(self,\
    \ wrappedFactory)\n\n    def open(self, name):\n        return open(name, \"w\"\
    )\n\n    def buildProtocol(self, addr):\n        self._counter += 1\n        logfile\
    \ = self.open(self.logfilePrefix + \"-\" + str(self._counter))\n        return\
    \ self.protocol(\n            self,\n            self.wrappedFactory.buildProtocol(addr),\n\
    \            logfile,\n            self.lengthLimit,\n            self._counter,\n\
    \        )\n\n    def resetCounter(self):\n        \"\"\"\n        Reset the value\
    \ of the counter used to identify connections.\n        \"\"\"\n        self._counter\
    \ = 0\n\n\nclass TimeoutMixin:\n    \"\"\"\n    Mixin for protocols which wish\
    \ to timeout connections.\n\n    Protocols that mix this in have a single timeout,\
    \ set using L{setTimeout}.\n    When the timeout is hit, L{timeoutConnection}\
    \ is called, which, by\n    default, closes the connection.\n\n    @cvar timeOut:\
    \ The number of seconds after which to timeout the connection.\n    \"\"\"\n\n\
    \    timeOut: Optional[int] = None\n\n    __timeoutCall = None\n\n    def callLater(self,\
    \ period, func):\n        \"\"\"\n        Wrapper around\n        L{reactor.callLater<twisted.internet.interfaces.IReactorTime.callLater>}\n\
    \        for test purpose.\n        \"\"\"\n        from twisted.internet import\
    \ reactor\n\n        return reactor.callLater(period, func)\n\n    def resetTimeout(self):\n\
    \        \"\"\"\n        Reset the timeout count down.\n\n        If the connection\
    \ has already timed out, then do nothing.  If the\n        timeout has been cancelled\
    \ (probably using C{setTimeout(None)}), also\n        do nothing.\n\n        It's\
    \ often a good idea to call this when the protocol has received\n        some\
    \ meaningful input from the other end of the connection.  \"I've got\n       \
    \ some data, they're still there, reset the timeout\".\n        \"\"\"\n     \
    \   if self.__timeoutCall is not None and self.timeOut is not None:\n        \
    \    self.__timeoutCall.reset(self.timeOut)\n\n    def setTimeout(self, period):\n\
    \        \"\"\"\n        Change the timeout period\n\n        @type period: C{int}\
    \ or L{None}\n        @param period: The period, in seconds, to change the timeout\
    \ to, or\n        L{None} to disable the timeout.\n        \"\"\"\n        prev\
    \ = self.timeOut\n        self.timeOut = period\n\n        if self.__timeoutCall\
    \ is not None:\n            if period is None:\n                try:\n       \
    \             self.__timeoutCall.cancel()\n                except (error.AlreadyCancelled,\
    \ error.AlreadyCalled):\n                    # Do nothing if the call was already\
    \ consumed.\n                    pass\n                self.__timeoutCall = None\n\
    \            else:\n                self.__timeoutCall.reset(period)\n       \
    \ elif period is not None:\n            self.__timeoutCall = self.callLater(period,\
    \ self.__timedOut)\n\n        return prev\n\n    def __timedOut(self):\n     \
    \   self.__timeoutCall = None\n        self.timeoutConnection()\n\n    def timeoutConnection(self):\n\
    \        \"\"\"\n        Called when the connection times out.\n\n        Override\
    \ to define behavior other than dropping the connection.\n        \"\"\"\n   \
    \     self.transport.loseConnection()\n\nOutput the complete test file, code only,\
    \ no explanations.\n### Time\nCurrent time: 2025-03-15 01:35:38\n"
  role: user
