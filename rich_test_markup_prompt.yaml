messages:
- content: You are an AI agent expert in writing unit tests. Your task is to write
    unit tests for the given code files of the repository. Make sure the tests can
    be executed without lint or compile errors.
  role: system
- content: "### Task Information\nBased on the source code, write/rewrite tests to\
    \ cover the source code.\nRepository: rich\nTest File Path: rich\\test_markup\\\
    test_markup.py\nProject Programming Language: Python\nTesting Framework: pytest\n\
    ### Source File Content\n### Source File Content:\nclass ConsoleError(Exception):\n\
    \    \"\"\"An error in console operation.\"\"\"\n\n\nclass StyleError(Exception):\n\
    \    \"\"\"An error in styles.\"\"\"\n\n\nclass StyleSyntaxError(ConsoleError):\n\
    \    \"\"\"Style was badly formatted.\"\"\"\n\n\nclass MissingStyle(StyleError):\n\
    \    \"\"\"No such style.\"\"\"\n\n\nclass StyleStackError(ConsoleError):\n  \
    \  \"\"\"Style stack is invalid.\"\"\"\n\n\nclass NotRenderableError(ConsoleError):\n\
    \    \"\"\"Object is not renderable.\"\"\"\n\n\nclass MarkupError(ConsoleError):\n\
    \    \"\"\"Markup was badly formatted.\"\"\"\n\n\nclass LiveError(ConsoleError):\n\
    \    \"\"\"Error related to Live display.\"\"\"\n\n\nclass NoAltScreen(ConsoleError):\n\
    \    \"\"\"Alt screen mode was required.\"\"\"\n\n\n### Source File Content:\n\
    import re\nfrom ast import literal_eval\nfrom operator import attrgetter\nfrom\
    \ typing import Callable, Iterable, List, Match, NamedTuple, Optional, Tuple,\
    \ Union\n\nfrom ._emoji_replace import _emoji_replace\nfrom .emoji import EmojiVariant\n\
    from .errors import MarkupError\nfrom .style import Style\nfrom .text import Span,\
    \ Text\n\nRE_TAGS = re.compile(\n    r\"\"\"((\\\\*)\\[([a-z#/@][^[]*?)])\"\"\"\
    ,\n    re.VERBOSE,\n)\n\nRE_HANDLER = re.compile(r\"^([\\w.]*?)(\\(.*?\\))?$\"\
    )\n\n\nclass Tag(NamedTuple):\n    \"\"\"A tag in console markup.\"\"\"\n\n  \
    \  name: str\n    \"\"\"The tag name. e.g. 'bold'.\"\"\"\n    parameters: Optional[str]\n\
    \    \"\"\"Any additional parameters after the name.\"\"\"\n\n    def __str__(self)\
    \ -> str:\n        return (\n            self.name if self.parameters is None\
    \ else f\"{self.name} {self.parameters}\"\n        )\n\n    @property\n    def\
    \ markup(self) -> str:\n        \"\"\"Get the string representation of this tag.\"\
    \"\"\n        return (\n            f\"[{self.name}]\"\n            if self.parameters\
    \ is None\n            else f\"[{self.name}={self.parameters}]\"\n        )\n\n\
    \n_ReStringMatch = Match[str]  # regex match object\n_ReSubCallable = Callable[[_ReStringMatch],\
    \ str]  # Callable invoked by re.sub\n_EscapeSubMethod = Callable[[_ReSubCallable,\
    \ str], str]  # Sub method of a compiled re\n\n\ndef escape(\n    markup: str,\n\
    \    _escape: _EscapeSubMethod = re.compile(r\"(\\\\*)(\\[[a-z#/@][^[]*?])\").sub,\n\
    ) -> str:\n    \"\"\"Escapes text so that it won't be interpreted as markup.\n\
    \n    Args:\n        markup (str): Content to be inserted in to markup.\n\n  \
    \  Returns:\n        str: Markup with square brackets escaped.\n    \"\"\"\n\n\
    \    def escape_backslashes(match: Match[str]) -> str:\n        \"\"\"Called by\
    \ re.sub replace matches.\"\"\"\n        backslashes, text = match.groups()\n\
    \        return f\"{backslashes}{backslashes}\\\\{text}\"\n\n    markup = _escape(escape_backslashes,\
    \ markup)\n    if markup.endswith(\"\\\\\") and not markup.endswith(\"\\\\\\\\\
    \"):\n        return markup + \"\\\\\"\n\n    return markup\n\n\ndef _parse(markup:\
    \ str) -> Iterable[Tuple[int, Optional[str], Optional[Tag]]]:\n    \"\"\"Parse\
    \ markup in to an iterable of tuples of (position, text, tag).\n\n    Args:\n\
    \        markup (str): A string containing console markup\n\n    \"\"\"\n    position\
    \ = 0\n    _divmod = divmod\n    _Tag = Tag\n    for match in RE_TAGS.finditer(markup):\n\
    \        full_text, escapes, tag_text = match.groups()\n        start, end = match.span()\n\
    \        if start > position:\n            yield start, markup[position:start],\
    \ None\n        if escapes:\n            backslashes, escaped = _divmod(len(escapes),\
    \ 2)\n            if backslashes:\n                # Literal backslashes\n   \
    \             yield start, \"\\\\\" * backslashes, None\n                start\
    \ += backslashes * 2\n            if escaped:\n                # Escape of tag\n\
    \                yield start, full_text[len(escapes) :], None\n              \
    \  position = end\n                continue\n        text, equals, parameters\
    \ = tag_text.partition(\"=\")\n        yield start, None, _Tag(text, parameters\
    \ if equals else None)\n        position = end\n    if position < len(markup):\n\
    \        yield position, markup[position:], None\n\n\ndef render(\n    markup:\
    \ str,\n    style: Union[str, Style] = \"\",\n    emoji: bool = True,\n    emoji_variant:\
    \ Optional[EmojiVariant] = None,\n) -> Text:\n    \"\"\"Render console markup\
    \ in to a Text instance.\n\n    Args:\n        markup (str): A string containing\
    \ console markup.\n        style: (Union[str, Style]): The style to use.\n   \
    \     emoji (bool, optional): Also render emoji code. Defaults to True.\n    \
    \    emoji_variant (str, optional): Optional emoji variant, either \"text\" or\
    \ \"emoji\". Defaults to None.\n\n\n    Raises:\n        MarkupError: If there\
    \ is a syntax error in the markup.\n\n    Returns:\n        Text: A test instance.\n\
    \    \"\"\"\n    emoji_replace = _emoji_replace\n    if \"[\" not in markup:\n\
    \        return Text(\n            emoji_replace(markup, default_variant=emoji_variant)\
    \ if emoji else markup,\n            style=style,\n        )\n    text = Text(style=style)\n\
    \    append = text.append\n    normalize = Style.normalize\n\n    style_stack:\
    \ List[Tuple[int, Tag]] = []\n    pop = style_stack.pop\n\n    spans: List[Span]\
    \ = []\n    append_span = spans.append\n\n    _Span = Span\n    _Tag = Tag\n\n\
    \    def pop_style(style_name: str) -> Tuple[int, Tag]:\n        \"\"\"Pop tag\
    \ matching given style name.\"\"\"\n        for index, (_, tag) in enumerate(reversed(style_stack),\
    \ 1):\n            if tag.name == style_name:\n                return pop(-index)\n\
    \        raise KeyError(style_name)\n\n    for position, plain_text, tag in _parse(markup):\n\
    \        if plain_text is not None:\n            # Handle open brace escapes,\
    \ where the brace is not part of a tag.\n            plain_text = plain_text.replace(\"\
    \\\\[\", \"[\")\n            append(emoji_replace(plain_text) if emoji else plain_text)\n\
    \        elif tag is not None:\n            if tag.name.startswith(\"/\"):  #\
    \ Closing tag\n                style_name = tag.name[1:].strip()\n\n         \
    \       if style_name:  # explicit close\n                    style_name = normalize(style_name)\n\
    \                    try:\n                        start, open_tag = pop_style(style_name)\n\
    \                    except KeyError:\n                        raise MarkupError(\n\
    \                            f\"closing tag '{tag.markup}' at position {position}\
    \ doesn't match any open tag\"\n                        ) from None\n        \
    \        else:  # implicit close\n                    try:\n                 \
    \       start, open_tag = pop()\n                    except IndexError:\n    \
    \                    raise MarkupError(\n                            f\"closing\
    \ tag '[/]' at position {position} has nothing to close\"\n                  \
    \      ) from None\n\n                if open_tag.name.startswith(\"@\"):\n  \
    \                  if open_tag.parameters:\n                        handler_name\
    \ = \"\"\n                        parameters = open_tag.parameters.strip()\n \
    \                       handler_match = RE_HANDLER.match(parameters)\n       \
    \                 if handler_match is not None:\n                            handler_name,\
    \ match_parameters = handler_match.groups()\n                            parameters\
    \ = (\n                                \"()\" if match_parameters is None else\
    \ match_parameters\n                            )\n\n                        try:\n\
    \                            meta_params = literal_eval(parameters)\n        \
    \                except SyntaxError as error:\n                            raise\
    \ MarkupError(\n                                f\"error parsing {parameters!r}\
    \ in {open_tag.parameters!r}; {error.msg}\"\n                            )\n \
    \                       except Exception as error:\n                         \
    \   raise MarkupError(\n                                f\"error parsing {open_tag.parameters!r};\
    \ {error}\"\n                            ) from None\n\n                     \
    \   if handler_name:\n                            meta_params = (\n          \
    \                      handler_name,\n                                meta_params\n\
    \                                if isinstance(meta_params, tuple)\n         \
    \                       else (meta_params,),\n                            )\n\n\
    \                    else:\n                        meta_params = ()\n\n     \
    \               append_span(\n                        _Span(\n               \
    \             start, len(text), Style(meta={open_tag.name: meta_params})\n   \
    \                     )\n                    )\n                else:\n      \
    \              append_span(_Span(start, len(text), str(open_tag)))\n\n       \
    \     else:  # Opening tag\n                normalized_tag = _Tag(normalize(tag.name),\
    \ tag.parameters)\n                style_stack.append((len(text), normalized_tag))\n\
    \n    text_length = len(text)\n    while style_stack:\n        start, tag = style_stack.pop()\n\
    \        style = str(tag)\n        if style:\n            append_span(_Span(start,\
    \ text_length, style))\n\n    text.spans = sorted(spans[::-1], key=attrgetter(\"\
    start\"))\n    return text\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n\
    \    MARKUP = [\n        \"[red]Hello World[/red]\",\n        \"[magenta]Hello\
    \ [b]World[/b]\",\n        \"[bold]Bold[italic] bold and italic [/bold]italic[/italic]\"\
    ,\n        \"Click [link=https://www.willmcgugan.com]here[/link] to visit my Blog\"\
    ,\n        \":warning-emoji: [bold red blink] DANGER![/]\",\n    ]\n\n    from\
    \ rich import print\n    from rich.table import Table\n\n    grid = Table(\"Markup\"\
    , \"Result\", padding=(0, 1))\n\n    for markup in MARKUP:\n        grid.add_row(Text(markup),\
    \ markup)\n\n    print(grid)\n\n### Source File Dependency Files Content\n###\
    \ Dependency File: emoji.py\nimport sys\nfrom typing import TYPE_CHECKING, Optional,\
    \ Union\n\nfrom .jupyter import JupyterMixin\nfrom .segment import Segment\nfrom\
    \ .style import Style\nfrom ._emoji_codes import EMOJI\nfrom ._emoji_replace import\
    \ _emoji_replace\n\nif sys.version_info >= (3, 8):\n    from typing import Literal\n\
    else:\n    from typing_extensions import Literal  # pragma: no cover\n\n\nif TYPE_CHECKING:\n\
    \    from .console import Console, ConsoleOptions, RenderResult\n\n\nEmojiVariant\
    \ = Literal[\"emoji\", \"text\"]\n\n\nclass NoEmoji(Exception):\n    \"\"\"No\
    \ emoji by that name.\"\"\"\n\n\nclass Emoji(JupyterMixin):\n    __slots__ = [\"\
    name\", \"style\", \"_char\", \"variant\"]\n\n    VARIANTS = {\"text\": \"\\uFE0E\"\
    , \"emoji\": \"\\uFE0F\"}\n\n    def __init__(\n        self,\n        name: str,\n\
    \        style: Union[str, Style] = \"none\",\n        variant: Optional[EmojiVariant]\
    \ = None,\n    ) -> None:\n        \"\"\"A single emoji character.\n\n       \
    \ Args:\n            name (str): Name of emoji.\n            style (Union[str,\
    \ Style], optional): Optional style. Defaults to None.\n\n        Raises:\n  \
    \          NoEmoji: If the emoji doesn't exist.\n        \"\"\"\n        self.name\
    \ = name\n        self.style = style\n        self.variant = variant\n       \
    \ try:\n            self._char = EMOJI[name]\n        except KeyError:\n     \
    \       raise NoEmoji(f\"No emoji called {name!r}\")\n        if variant is not\
    \ None:\n            self._char += self.VARIANTS.get(variant, \"\")\n\n    @classmethod\n\
    \    def replace(cls, text: str) -> str:\n        \"\"\"Replace emoji markup with\
    \ corresponding unicode characters.\n\n        Args:\n            text (str):\
    \ A string with emojis codes, e.g. \"Hello :smiley:!\"\n\n        Returns:\n \
    \           str: A string with emoji codes replaces with actual emoji.\n     \
    \   \"\"\"\n        return _emoji_replace(text)\n\n    def __repr__(self) -> str:\n\
    \        return f\"<emoji {self.name!r}>\"\n\n    def __str__(self) -> str:\n\
    \        return self._char\n\n    def __rich_console__(\n        self, console:\
    \ \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n     \
    \   yield Segment(self._char, console.get_style(self.style))\n\n\nif __name__\
    \ == \"__main__\":  # pragma: no cover\n    import sys\n\n    from rich.columns\
    \ import Columns\n    from rich.console import Console\n\n    console = Console(record=True)\n\
    \n    columns = Columns(\n        (f\":{name}: {name}\" for name in sorted(EMOJI.keys())\
    \ if \"\\u200D\" not in name),\n        column_first=True,\n    )\n\n    console.print(columns)\n\
    \    if len(sys.argv) > 1:\n        console.save_html(sys.argv[1])\n\n\n### Dependency\
    \ File: style.py\nimport sys\nfrom functools import lru_cache\nfrom marshal import\
    \ dumps, loads\nfrom random import randint\nfrom typing import Any, Dict, Iterable,\
    \ List, Optional, Type, Union, cast\n\nfrom . import errors\nfrom .color import\
    \ Color, ColorParseError, ColorSystem, blend_rgb\nfrom .repr import Result, rich_repr\n\
    from .terminal_theme import DEFAULT_TERMINAL_THEME, TerminalTheme\n\n# Style instances\
    \ and style definitions are often interchangeable\nStyleType = Union[str, \"Style\"\
    ]\n\n\nclass _Bit:\n    \"\"\"A descriptor to get/set a style attribute bit.\"\
    \"\"\n\n    __slots__ = [\"bit\"]\n\n    def __init__(self, bit_no: int) -> None:\n\
    \        self.bit = 1 << bit_no\n\n    def __get__(self, obj: \"Style\", objtype:\
    \ Type[\"Style\"]) -> Optional[bool]:\n        if obj._set_attributes & self.bit:\n\
    \            return obj._attributes & self.bit != 0\n        return None\n\n\n\
    @rich_repr\nclass Style:\n    \"\"\"A terminal style.\n\n    A terminal style\
    \ consists of a color (`color`), a background color (`bgcolor`), and a number\
    \ of attributes, such\n    as bold, italic etc. The attributes have 3 states:\
    \ they can either be on\n    (``True``), off (``False``), or not set (``None``).\n\
    \n    Args:\n        color (Union[Color, str], optional): Color of terminal text.\
    \ Defaults to None.\n        bgcolor (Union[Color, str], optional): Color of terminal\
    \ background. Defaults to None.\n        bold (bool, optional): Enable bold text.\
    \ Defaults to None.\n        dim (bool, optional): Enable dim text. Defaults to\
    \ None.\n        italic (bool, optional): Enable italic text. Defaults to None.\n\
    \        underline (bool, optional): Enable underlined text. Defaults to None.\n\
    \        blink (bool, optional): Enabled blinking text. Defaults to None.\n  \
    \      blink2 (bool, optional): Enable fast blinking text. Defaults to None.\n\
    \        reverse (bool, optional): Enabled reverse text. Defaults to None.\n \
    \       conceal (bool, optional): Enable concealed text. Defaults to None.\n \
    \       strike (bool, optional): Enable strikethrough text. Defaults to None.\n\
    \        underline2 (bool, optional): Enable doubly underlined text. Defaults\
    \ to None.\n        frame (bool, optional): Enable framed text. Defaults to None.\n\
    \        encircle (bool, optional): Enable encircled text. Defaults to None.\n\
    \        overline (bool, optional): Enable overlined text. Defaults to None.\n\
    \        link (str, link): Link URL. Defaults to None.\n\n    \"\"\"\n\n    _color:\
    \ Optional[Color]\n    _bgcolor: Optional[Color]\n    _attributes: int\n    _set_attributes:\
    \ int\n    _hash: Optional[int]\n    _null: bool\n    _meta: Optional[bytes]\n\
    \n    __slots__ = [\n        \"_color\",\n        \"_bgcolor\",\n        \"_attributes\"\
    ,\n        \"_set_attributes\",\n        \"_link\",\n        \"_link_id\",\n \
    \       \"_ansi\",\n        \"_style_definition\",\n        \"_hash\",\n     \
    \   \"_null\",\n        \"_meta\",\n    ]\n\n    # maps bits on to SGR parameter\n\
    \    _style_map = {\n        0: \"1\",\n        1: \"2\",\n        2: \"3\",\n\
    \        3: \"4\",\n        4: \"5\",\n        5: \"6\",\n        6: \"7\",\n\
    \        7: \"8\",\n        8: \"9\",\n        9: \"21\",\n        10: \"51\"\
    ,\n        11: \"52\",\n        12: \"53\",\n    }\n\n    STYLE_ATTRIBUTES = {\n\
    \        \"dim\": \"dim\",\n        \"d\": \"dim\",\n        \"bold\": \"bold\"\
    ,\n        \"b\": \"bold\",\n        \"italic\": \"italic\",\n        \"i\": \"\
    italic\",\n        \"underline\": \"underline\",\n        \"u\": \"underline\"\
    ,\n        \"blink\": \"blink\",\n        \"blink2\": \"blink2\",\n        \"\
    reverse\": \"reverse\",\n        \"r\": \"reverse\",\n        \"conceal\": \"\
    conceal\",\n        \"c\": \"conceal\",\n        \"strike\": \"strike\",\n   \
    \     \"s\": \"strike\",\n        \"underline2\": \"underline2\",\n        \"\
    uu\": \"underline2\",\n        \"frame\": \"frame\",\n        \"encircle\": \"\
    encircle\",\n        \"overline\": \"overline\",\n        \"o\": \"overline\"\
    ,\n    }\n\n    def __init__(\n        self,\n        *,\n        color: Optional[Union[Color,\
    \ str]] = None,\n        bgcolor: Optional[Union[Color, str]] = None,\n      \
    \  bold: Optional[bool] = None,\n        dim: Optional[bool] = None,\n       \
    \ italic: Optional[bool] = None,\n        underline: Optional[bool] = None,\n\
    \        blink: Optional[bool] = None,\n        blink2: Optional[bool] = None,\n\
    \        reverse: Optional[bool] = None,\n        conceal: Optional[bool] = None,\n\
    \        strike: Optional[bool] = None,\n        underline2: Optional[bool] =\
    \ None,\n        frame: Optional[bool] = None,\n        encircle: Optional[bool]\
    \ = None,\n        overline: Optional[bool] = None,\n        link: Optional[str]\
    \ = None,\n        meta: Optional[Dict[str, Any]] = None,\n    ):\n        self._ansi:\
    \ Optional[str] = None\n        self._style_definition: Optional[str] = None\n\
    \n        def _make_color(color: Union[Color, str]) -> Color:\n            return\
    \ color if isinstance(color, Color) else Color.parse(color)\n\n        self._color\
    \ = None if color is None else _make_color(color)\n        self._bgcolor = None\
    \ if bgcolor is None else _make_color(bgcolor)\n        self._set_attributes =\
    \ sum(\n            (\n                bold is not None,\n                dim\
    \ is not None and 2,\n                italic is not None and 4,\n            \
    \    underline is not None and 8,\n                blink is not None and 16,\n\
    \                blink2 is not None and 32,\n                reverse is not None\
    \ and 64,\n                conceal is not None and 128,\n                strike\
    \ is not None and 256,\n                underline2 is not None and 512,\n    \
    \            frame is not None and 1024,\n                encircle is not None\
    \ and 2048,\n                overline is not None and 4096,\n            )\n \
    \       )\n        self._attributes = (\n            sum(\n                (\n\
    \                    bold and 1 or 0,\n                    dim and 2 or 0,\n \
    \                   italic and 4 or 0,\n                    underline and 8 or\
    \ 0,\n                    blink and 16 or 0,\n                    blink2 and 32\
    \ or 0,\n                    reverse and 64 or 0,\n                    conceal\
    \ and 128 or 0,\n                    strike and 256 or 0,\n                  \
    \  underline2 and 512 or 0,\n                    frame and 1024 or 0,\n      \
    \              encircle and 2048 or 0,\n                    overline and 4096\
    \ or 0,\n                )\n            )\n            if self._set_attributes\n\
    \            else 0\n        )\n\n        self._link = link\n        self._meta\
    \ = None if meta is None else dumps(meta)\n        self._link_id = (\n       \
    \     f\"{randint(0, 999999)}{hash(self._meta)}\" if (link or meta) else \"\"\n\
    \        )\n        self._hash: Optional[int] = None\n        self._null = not\
    \ (self._set_attributes or color or bgcolor or link or meta)\n\n    @classmethod\n\
    \    def null(cls) -> \"Style\":\n        \"\"\"Create an 'null' style, equivalent\
    \ to Style(), but more performant.\"\"\"\n        return NULL_STYLE\n\n    @classmethod\n\
    \    def from_color(\n        cls, color: Optional[Color] = None, bgcolor: Optional[Color]\
    \ = None\n    ) -> \"Style\":\n        \"\"\"Create a new style with colors and\
    \ no attributes.\n\n        Returns:\n            color (Optional[Color]): A (foreground)\
    \ color, or None for no color. Defaults to None.\n            bgcolor (Optional[Color]):\
    \ A (background) color, or None for no color. Defaults to None.\n        \"\"\"\
    \n        style: Style = cls.__new__(Style)\n        style._ansi = None\n    \
    \    style._style_definition = None\n        style._color = color\n        style._bgcolor\
    \ = bgcolor\n        style._set_attributes = 0\n        style._attributes = 0\n\
    \        style._link = None\n        style._link_id = \"\"\n        style._meta\
    \ = None\n        style._null = not (color or bgcolor)\n        style._hash =\
    \ None\n        return style\n\n    @classmethod\n    def from_meta(cls, meta:\
    \ Optional[Dict[str, Any]]) -> \"Style\":\n        \"\"\"Create a new style with\
    \ meta data.\n\n        Returns:\n            meta (Optional[Dict[str, Any]]):\
    \ A dictionary of meta data. Defaults to None.\n        \"\"\"\n        style:\
    \ Style = cls.__new__(Style)\n        style._ansi = None\n        style._style_definition\
    \ = None\n        style._color = None\n        style._bgcolor = None\n       \
    \ style._set_attributes = 0\n        style._attributes = 0\n        style._link\
    \ = None\n        style._meta = dumps(meta)\n        style._link_id = f\"{randint(0,\
    \ 999999)}{hash(style._meta)}\"\n        style._hash = None\n        style._null\
    \ = not (meta)\n        return style\n\n    @classmethod\n    def on(cls, meta:\
    \ Optional[Dict[str, Any]] = None, **handlers: Any) -> \"Style\":\n        \"\"\
    \"Create a blank style with meta information.\n\n        Example:\n          \
    \  style = Style.on(click=self.on_click)\n\n        Args:\n            meta (Optional[Dict[str,\
    \ Any]], optional): An optional dict of meta information.\n            **handlers\
    \ (Any): Keyword arguments are translated in to handlers.\n\n        Returns:\n\
    \            Style: A Style with meta information attached.\n        \"\"\"\n\
    \        meta = {} if meta is None else meta\n        meta.update({f\"@{key}\"\
    : value for key, value in handlers.items()})\n        return cls.from_meta(meta)\n\
    \n    bold = _Bit(0)\n    dim = _Bit(1)\n    italic = _Bit(2)\n    underline =\
    \ _Bit(3)\n    blink = _Bit(4)\n    blink2 = _Bit(5)\n    reverse = _Bit(6)\n\
    \    conceal = _Bit(7)\n    strike = _Bit(8)\n    underline2 = _Bit(9)\n    frame\
    \ = _Bit(10)\n    encircle = _Bit(11)\n    overline = _Bit(12)\n\n    @property\n\
    \    def link_id(self) -> str:\n        \"\"\"Get a link id, used in ansi code\
    \ for links.\"\"\"\n        return self._link_id\n\n    def __str__(self) -> str:\n\
    \        \"\"\"Re-generate style definition from attributes.\"\"\"\n        if\
    \ self._style_definition is None:\n            attributes: List[str] = []\n  \
    \          append = attributes.append\n            bits = self._set_attributes\n\
    \            if bits & 0b0000000001111:\n                if bits & 1:\n      \
    \              append(\"bold\" if self.bold else \"not bold\")\n             \
    \   if bits & (1 << 1):\n                    append(\"dim\" if self.dim else \"\
    not dim\")\n                if bits & (1 << 2):\n                    append(\"\
    italic\" if self.italic else \"not italic\")\n                if bits & (1 <<\
    \ 3):\n                    append(\"underline\" if self.underline else \"not underline\"\
    )\n            if bits & 0b0000111110000:\n                if bits & (1 << 4):\n\
    \                    append(\"blink\" if self.blink else \"not blink\")\n    \
    \            if bits & (1 << 5):\n                    append(\"blink2\" if self.blink2\
    \ else \"not blink2\")\n                if bits & (1 << 6):\n                \
    \    append(\"reverse\" if self.reverse else \"not reverse\")\n              \
    \  if bits & (1 << 7):\n                    append(\"conceal\" if self.conceal\
    \ else \"not conceal\")\n                if bits & (1 << 8):\n               \
    \     append(\"strike\" if self.strike else \"not strike\")\n            if bits\
    \ & 0b1111000000000:\n                if bits & (1 << 9):\n                  \
    \  append(\"underline2\" if self.underline2 else \"not underline2\")\n       \
    \         if bits & (1 << 10):\n                    append(\"frame\" if self.frame\
    \ else \"not frame\")\n                if bits & (1 << 11):\n                \
    \    append(\"encircle\" if self.encircle else \"not encircle\")\n           \
    \     if bits & (1 << 12):\n                    append(\"overline\" if self.overline\
    \ else \"not overline\")\n            if self._color is not None:\n          \
    \      append(self._color.name)\n            if self._bgcolor is not None:\n \
    \               append(\"on\")\n                append(self._bgcolor.name)\n \
    \           if self._link:\n                append(\"link\")\n               \
    \ append(self._link)\n            self._style_definition = \" \".join(attributes)\
    \ or \"none\"\n        return self._style_definition\n\n    def __bool__(self)\
    \ -> bool:\n        \"\"\"A Style is false if it has no attributes, colors, or\
    \ links.\"\"\"\n        return not self._null\n\n    def _make_ansi_codes(self,\
    \ color_system: ColorSystem) -> str:\n        \"\"\"Generate ANSI codes for this\
    \ style.\n\n        Args:\n            color_system (ColorSystem): Color system.\n\
    \n        Returns:\n            str: String containing codes.\n        \"\"\"\n\
    \n        if self._ansi is None:\n            sgr: List[str] = []\n          \
    \  append = sgr.append\n            _style_map = self._style_map\n           \
    \ attributes = self._attributes & self._set_attributes\n            if attributes:\n\
    \                if attributes & 1:\n                    append(_style_map[0])\n\
    \                if attributes & 2:\n                    append(_style_map[1])\n\
    \                if attributes & 4:\n                    append(_style_map[2])\n\
    \                if attributes & 8:\n                    append(_style_map[3])\n\
    \                if attributes & 0b0000111110000:\n                    for bit\
    \ in range(4, 9):\n                        if attributes & (1 << bit):\n     \
    \                       append(_style_map[bit])\n                if attributes\
    \ & 0b1111000000000:\n                    for bit in range(9, 13):\n         \
    \               if attributes & (1 << bit):\n                            append(_style_map[bit])\n\
    \            if self._color is not None:\n                sgr.extend(self._color.downgrade(color_system).get_ansi_codes())\n\
    \            if self._bgcolor is not None:\n                sgr.extend(\n    \
    \                self._bgcolor.downgrade(color_system).get_ansi_codes(\n     \
    \                   foreground=False\n                    )\n                )\n\
    \            self._ansi = \";\".join(sgr)\n        return self._ansi\n\n    @classmethod\n\
    \    @lru_cache(maxsize=1024)\n    def normalize(cls, style: str) -> str:\n  \
    \      \"\"\"Normalize a style definition so that styles with the same effect\
    \ have the same string\n        representation.\n\n        Args:\n           \
    \ style (str): A style definition.\n\n        Returns:\n            str: Normal\
    \ form of style definition.\n        \"\"\"\n        try:\n            return\
    \ str(cls.parse(style))\n        except errors.StyleSyntaxError:\n           \
    \ return style.strip().lower()\n\n    @classmethod\n    def pick_first(cls, *values:\
    \ Optional[StyleType]) -> StyleType:\n        \"\"\"Pick first non-None style.\"\
    \"\"\n        for value in values:\n            if value is not None:\n      \
    \          return value\n        raise ValueError(\"expected at least one non-None\
    \ style\")\n\n    def __rich_repr__(self) -> Result:\n        yield \"color\"\
    , self.color, None\n        yield \"bgcolor\", self.bgcolor, None\n        yield\
    \ \"bold\", self.bold, None,\n        yield \"dim\", self.dim, None,\n       \
    \ yield \"italic\", self.italic, None\n        yield \"underline\", self.underline,\
    \ None,\n        yield \"blink\", self.blink, None\n        yield \"blink2\",\
    \ self.blink2, None\n        yield \"reverse\", self.reverse, None\n        yield\
    \ \"conceal\", self.conceal, None\n        yield \"strike\", self.strike, None\n\
    \        yield \"underline2\", self.underline2, None\n        yield \"frame\"\
    , self.frame, None\n        yield \"encircle\", self.encircle, None\n        yield\
    \ \"link\", self.link, None\n        if self._meta:\n            yield \"meta\"\
    , self.meta\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other,\
    \ Style):\n            return NotImplemented\n        return self.__hash__() ==\
    \ other.__hash__()\n\n    def __ne__(self, other: Any) -> bool:\n        if not\
    \ isinstance(other, Style):\n            return NotImplemented\n        return\
    \ self.__hash__() != other.__hash__()\n\n    def __hash__(self) -> int:\n    \
    \    if self._hash is not None:\n            return self._hash\n        self._hash\
    \ = hash(\n            (\n                self._color,\n                self._bgcolor,\n\
    \                self._attributes,\n                self._set_attributes,\n  \
    \              self._link,\n                self._meta,\n            )\n     \
    \   )\n        return self._hash\n\n    @property\n    def color(self) -> Optional[Color]:\n\
    \        \"\"\"The foreground color or None if it is not set.\"\"\"\n        return\
    \ self._color\n\n    @property\n    def bgcolor(self) -> Optional[Color]:\n  \
    \      \"\"\"The background color or None if it is not set.\"\"\"\n        return\
    \ self._bgcolor\n\n    @property\n    def link(self) -> Optional[str]:\n     \
    \   \"\"\"Link text, if set.\"\"\"\n        return self._link\n\n    @property\n\
    \    def transparent_background(self) -> bool:\n        \"\"\"Check if the style\
    \ specified a transparent background.\"\"\"\n        return self.bgcolor is None\
    \ or self.bgcolor.is_default\n\n    @property\n    def background_style(self)\
    \ -> \"Style\":\n        \"\"\"A Style with background only.\"\"\"\n        return\
    \ Style(bgcolor=self.bgcolor)\n\n    @property\n    def meta(self) -> Dict[str,\
    \ Any]:\n        \"\"\"Get meta information (can not be changed after construction).\"\
    \"\"\n        return {} if self._meta is None else cast(Dict[str, Any], loads(self._meta))\n\
    \n    @property\n    def without_color(self) -> \"Style\":\n        \"\"\"Get\
    \ a copy of the style with color removed.\"\"\"\n        if self._null:\n    \
    \        return NULL_STYLE\n        style: Style = self.__new__(Style)\n     \
    \   style._ansi = None\n        style._style_definition = None\n        style._color\
    \ = None\n        style._bgcolor = None\n        style._attributes = self._attributes\n\
    \        style._set_attributes = self._set_attributes\n        style._link = self._link\n\
    \        style._link_id = f\"{randint(0, 999999)}\" if self._link else \"\"\n\
    \        style._null = False\n        style._meta = None\n        style._hash\
    \ = None\n        return style\n\n    @classmethod\n    @lru_cache(maxsize=4096)\n\
    \    def parse(cls, style_definition: str) -> \"Style\":\n        \"\"\"Parse\
    \ a style definition.\n\n        Args:\n            style_definition (str): A\
    \ string containing a style.\n\n        Raises:\n            errors.StyleSyntaxError:\
    \ If the style definition syntax is invalid.\n\n        Returns:\n           \
    \ `Style`: A Style instance.\n        \"\"\"\n        if style_definition.strip()\
    \ == \"none\" or not style_definition:\n            return cls.null()\n\n    \
    \    STYLE_ATTRIBUTES = cls.STYLE_ATTRIBUTES\n        color: Optional[str] = None\n\
    \        bgcolor: Optional[str] = None\n        attributes: Dict[str, Optional[Any]]\
    \ = {}\n        link: Optional[str] = None\n\n        words = iter(style_definition.split())\n\
    \        for original_word in words:\n            word = original_word.lower()\n\
    \            if word == \"on\":\n                word = next(words, \"\")\n  \
    \              if not word:\n                    raise errors.StyleSyntaxError(\"\
    color expected after 'on'\")\n                try:\n                    Color.parse(word)\
    \ is None\n                except ColorParseError as error:\n                \
    \    raise errors.StyleSyntaxError(\n                        f\"unable to parse\
    \ {word!r} as background color; {error}\"\n                    ) from None\n \
    \               bgcolor = word\n\n            elif word == \"not\":\n        \
    \        word = next(words, \"\")\n                attribute = STYLE_ATTRIBUTES.get(word)\n\
    \                if attribute is None:\n                    raise errors.StyleSyntaxError(\n\
    \                        f\"expected style attribute after 'not', found {word!r}\"\
    \n                    )\n                attributes[attribute] = False\n\n   \
    \         elif word == \"link\":\n                word = next(words, \"\")\n \
    \               if not word:\n                    raise errors.StyleSyntaxError(\"\
    URL expected after 'link'\")\n                link = word\n\n            elif\
    \ word in STYLE_ATTRIBUTES:\n                attributes[STYLE_ATTRIBUTES[word]]\
    \ = True\n\n            else:\n                try:\n                    Color.parse(word)\n\
    \                except ColorParseError as error:\n                    raise errors.StyleSyntaxError(\n\
    \                        f\"unable to parse {word!r} as color; {error}\"\n   \
    \                 ) from None\n                color = word\n        style = Style(color=color,\
    \ bgcolor=bgcolor, link=link, **attributes)\n        return style\n\n    @lru_cache(maxsize=1024)\n\
    \    def get_html_style(self, theme: Optional[TerminalTheme] = None) -> str:\n\
    \        \"\"\"Get a CSS style rule.\"\"\"\n        theme = theme or DEFAULT_TERMINAL_THEME\n\
    \        css: List[str] = []\n        append = css.append\n\n        color = self.color\n\
    \        bgcolor = self.bgcolor\n        if self.reverse:\n            color,\
    \ bgcolor = bgcolor, color\n        if self.dim:\n            foreground_color\
    \ = (\n                theme.foreground_color if color is None else color.get_truecolor(theme)\n\
    \            )\n            color = Color.from_triplet(\n                blend_rgb(foreground_color,\
    \ theme.background_color, 0.5)\n            )\n        if color is not None:\n\
    \            theme_color = color.get_truecolor(theme)\n            append(f\"\
    color: {theme_color.hex}\")\n            append(f\"text-decoration-color: {theme_color.hex}\"\
    )\n        if bgcolor is not None:\n            theme_color = bgcolor.get_truecolor(theme,\
    \ foreground=False)\n            append(f\"background-color: {theme_color.hex}\"\
    )\n        if self.bold:\n            append(\"font-weight: bold\")\n        if\
    \ self.italic:\n            append(\"font-style: italic\")\n        if self.underline:\n\
    \            append(\"text-decoration: underline\")\n        if self.strike:\n\
    \            append(\"text-decoration: line-through\")\n        if self.overline:\n\
    \            append(\"text-decoration: overline\")\n        return \"; \".join(css)\n\
    \n    @classmethod\n    def combine(cls, styles: Iterable[\"Style\"]) -> \"Style\"\
    :\n        \"\"\"Combine styles and get result.\n\n        Args:\n           \
    \ styles (Iterable[Style]): Styles to combine.\n\n        Returns:\n         \
    \   Style: A new style instance.\n        \"\"\"\n        iter_styles = iter(styles)\n\
    \        return sum(iter_styles, next(iter_styles))\n\n    @classmethod\n    def\
    \ chain(cls, *styles: \"Style\") -> \"Style\":\n        \"\"\"Combine styles from\
    \ positional argument in to a single style.\n\n        Args:\n            *styles\
    \ (Iterable[Style]): Styles to combine.\n\n        Returns:\n            Style:\
    \ A new style instance.\n        \"\"\"\n        iter_styles = iter(styles)\n\
    \        return sum(iter_styles, next(iter_styles))\n\n    def copy(self) -> \"\
    Style\":\n        \"\"\"Get a copy of this style.\n\n        Returns:\n      \
    \      Style: A new Style instance with identical attributes.\n        \"\"\"\n\
    \        if self._null:\n            return NULL_STYLE\n        style: Style =\
    \ self.__new__(Style)\n        style._ansi = self._ansi\n        style._style_definition\
    \ = self._style_definition\n        style._color = self._color\n        style._bgcolor\
    \ = self._bgcolor\n        style._attributes = self._attributes\n        style._set_attributes\
    \ = self._set_attributes\n        style._link = self._link\n        style._link_id\
    \ = f\"{randint(0, 999999)}\" if self._link else \"\"\n        style._hash = self._hash\n\
    \        style._null = False\n        style._meta = self._meta\n        return\
    \ style\n\n    @lru_cache(maxsize=128)\n    def clear_meta_and_links(self) ->\
    \ \"Style\":\n        \"\"\"Get a copy of this style with link and meta information\
    \ removed.\n\n        Returns:\n            Style: New style object.\n       \
    \ \"\"\"\n        if self._null:\n            return NULL_STYLE\n        style:\
    \ Style = self.__new__(Style)\n        style._ansi = self._ansi\n        style._style_definition\
    \ = self._style_definition\n        style._color = self._color\n        style._bgcolor\
    \ = self._bgcolor\n        style._attributes = self._attributes\n        style._set_attributes\
    \ = self._set_attributes\n        style._link = None\n        style._link_id =\
    \ \"\"\n        style._hash = None\n        style._null = False\n        style._meta\
    \ = None\n        return style\n\n    def update_link(self, link: Optional[str]\
    \ = None) -> \"Style\":\n        \"\"\"Get a copy with a different value for link.\n\
    \n        Args:\n            link (str, optional): New value for link. Defaults\
    \ to None.\n\n        Returns:\n            Style: A new Style instance.\n   \
    \     \"\"\"\n        style: Style = self.__new__(Style)\n        style._ansi\
    \ = self._ansi\n        style._style_definition = self._style_definition\n   \
    \     style._color = self._color\n        style._bgcolor = self._bgcolor\n   \
    \     style._attributes = self._attributes\n        style._set_attributes = self._set_attributes\n\
    \        style._link = link\n        style._link_id = f\"{randint(0, 999999)}\"\
    \ if link else \"\"\n        style._hash = None\n        style._null = False\n\
    \        style._meta = self._meta\n        return style\n\n    def render(\n \
    \       self,\n        text: str = \"\",\n        *,\n        color_system: Optional[ColorSystem]\
    \ = ColorSystem.TRUECOLOR,\n        legacy_windows: bool = False,\n    ) -> str:\n\
    \        \"\"\"Render the ANSI codes for the style.\n\n        Args:\n       \
    \     text (str, optional): A string to style. Defaults to \"\".\n           \
    \ color_system (Optional[ColorSystem], optional): Color system to render to. Defaults\
    \ to ColorSystem.TRUECOLOR.\n\n        Returns:\n            str: A string containing\
    \ ANSI style codes.\n        \"\"\"\n        if not text or color_system is None:\n\
    \            return text\n        attrs = self._ansi or self._make_ansi_codes(color_system)\n\
    \        rendered = f\"\\x1b[{attrs}m{text}\\x1b[0m\" if attrs else text\n   \
    \     if self._link and not legacy_windows:\n            rendered = (\n      \
    \          f\"\\x1b]8;id={self._link_id};{self._link}\\x1b\\\\{rendered}\\x1b]8;;\\\
    x1b\\\\\"\n            )\n        return rendered\n\n    def test(self, text:\
    \ Optional[str] = None) -> None:\n        \"\"\"Write text with style directly\
    \ to terminal.\n\n        This method is for testing purposes only.\n\n      \
    \  Args:\n            text (Optional[str], optional): Text to style or None for\
    \ style name.\n\n        \"\"\"\n        text = text or str(self)\n        sys.stdout.write(f\"\
    {self.render(text)}\\n\")\n\n    @lru_cache(maxsize=1024)\n    def _add(self,\
    \ style: Optional[\"Style\"]) -> \"Style\":\n        if style is None or style._null:\n\
    \            return self\n        if self._null:\n            return style\n \
    \       new_style: Style = self.__new__(Style)\n        new_style._ansi = None\n\
    \        new_style._style_definition = None\n        new_style._color = style._color\
    \ or self._color\n        new_style._bgcolor = style._bgcolor or self._bgcolor\n\
    \        new_style._attributes = (self._attributes & ~style._set_attributes) |\
    \ (\n            style._attributes & style._set_attributes\n        )\n      \
    \  new_style._set_attributes = self._set_attributes | style._set_attributes\n\
    \        new_style._link = style._link or self._link\n        new_style._link_id\
    \ = style._link_id or self._link_id\n        new_style._null = style._null\n \
    \       if self._meta and style._meta:\n            new_style._meta = dumps({**self.meta,\
    \ **style.meta})\n        else:\n            new_style._meta = self._meta or style._meta\n\
    \        new_style._hash = None\n        return new_style\n\n    def __add__(self,\
    \ style: Optional[\"Style\"]) -> \"Style\":\n        combined_style = self._add(style)\n\
    \        return combined_style.copy() if combined_style.link else combined_style\n\
    \n\nNULL_STYLE = Style()\n\n\nclass StyleStack:\n    \"\"\"A stack of styles.\"\
    \"\"\n\n    __slots__ = [\"_stack\"]\n\n    def __init__(self, default_style:\
    \ \"Style\") -> None:\n        self._stack: List[Style] = [default_style]\n\n\
    \    def __repr__(self) -> str:\n        return f\"<stylestack {self._stack!r}>\"\
    \n\n    @property\n    def current(self) -> Style:\n        \"\"\"Get the Style\
    \ at the top of the stack.\"\"\"\n        return self._stack[-1]\n\n    def push(self,\
    \ style: Style) -> None:\n        \"\"\"Push a new style on to the stack.\n\n\
    \        Args:\n            style (Style): New style to combine with current style.\n\
    \        \"\"\"\n        self._stack.append(self._stack[-1] + style)\n\n    def\
    \ pop(self) -> Style:\n        \"\"\"Pop last style and discard.\n\n        Returns:\n\
    \            Style: New current style (also available as stack.current)\n    \
    \    \"\"\"\n        self._stack.pop()\n        return self._stack[-1]\n\n\n###\
    \ Dependency File: text.py\nimport re\nfrom functools import partial, reduce\n\
    from math import gcd\nfrom operator import itemgetter\nfrom typing import (\n\
    \    TYPE_CHECKING,\n    Any,\n    Callable,\n    Dict,\n    Iterable,\n    List,\n\
    \    NamedTuple,\n    Optional,\n    Pattern,\n    Tuple,\n    Union,\n)\n\nfrom\
    \ ._loop import loop_last\nfrom ._pick import pick_bool\nfrom ._wrap import divide_line\n\
    from .align import AlignMethod\nfrom .cells import cell_len, set_cell_size\nfrom\
    \ .containers import Lines\nfrom .control import strip_control_codes\nfrom .emoji\
    \ import EmojiVariant\nfrom .jupyter import JupyterMixin\nfrom .measure import\
    \ Measurement\nfrom .segment import Segment\nfrom .style import Style, StyleType\n\
    \nif TYPE_CHECKING:  # pragma: no cover\n    from .console import Console, ConsoleOptions,\
    \ JustifyMethod, OverflowMethod\n\nDEFAULT_JUSTIFY: \"JustifyMethod\" = \"default\"\
    \nDEFAULT_OVERFLOW: \"OverflowMethod\" = \"fold\"\n\n\n_re_whitespace = re.compile(r\"\
    \\s+$\")\n\nTextType = Union[str, \"Text\"]\n\"\"\"A plain string or a :class:`Text`\
    \ instance.\"\"\"\n\nGetStyleCallable = Callable[[str], Optional[StyleType]]\n\
    \n\nclass Span(NamedTuple):\n    \"\"\"A marked up region in some text.\"\"\"\n\
    \n    start: int\n    \"\"\"Span start index.\"\"\"\n    end: int\n    \"\"\"\
    Span end index.\"\"\"\n    style: Union[str, Style]\n    \"\"\"Style associated\
    \ with the span.\"\"\"\n\n    def __repr__(self) -> str:\n        return f\"Span({self.start},\
    \ {self.end}, {self.style!r})\"\n\n    def __bool__(self) -> bool:\n        return\
    \ self.end > self.start\n\n    def split(self, offset: int) -> Tuple[\"Span\"\
    , Optional[\"Span\"]]:\n        \"\"\"Split a span in to 2 from a given offset.\"\
    \"\"\n\n        if offset < self.start:\n            return self, None\n     \
    \   if offset >= self.end:\n            return self, None\n\n        start, end,\
    \ style = self\n        span1 = Span(start, min(end, offset), style)\n       \
    \ span2 = Span(span1.end, end, style)\n        return span1, span2\n\n    def\
    \ move(self, offset: int) -> \"Span\":\n        \"\"\"Move start and end by a\
    \ given offset.\n\n        Args:\n            offset (int): Number of characters\
    \ to add to start and end.\n\n        Returns:\n            TextSpan: A new TextSpan\
    \ with adjusted position.\n        \"\"\"\n        start, end, style = self\n\
    \        return Span(start + offset, end + offset, style)\n\n    def right_crop(self,\
    \ offset: int) -> \"Span\":\n        \"\"\"Crop the span at the given offset.\n\
    \n        Args:\n            offset (int): A value between start and end.\n\n\
    \        Returns:\n            Span: A new (possibly smaller) span.\n        \"\
    \"\"\n        start, end, style = self\n        if offset >= end:\n          \
    \  return self\n        return Span(start, min(offset, end), style)\n\n    def\
    \ extend(self, cells: int) -> \"Span\":\n        \"\"\"Extend the span by the\
    \ given number of cells.\n\n        Args:\n            cells (int): Additional\
    \ space to add to end of span.\n\n        Returns:\n            Span: A span.\n\
    \        \"\"\"\n        if cells:\n            start, end, style = self\n   \
    \         return Span(start, end + cells, style)\n        else:\n            return\
    \ self\n\n\nclass Text(JupyterMixin):\n    \"\"\"Text with color / style.\n\n\
    \    Args:\n        text (str, optional): Default unstyled text. Defaults to \"\
    \".\n        style (Union[str, Style], optional): Base style for text. Defaults\
    \ to \"\".\n        justify (str, optional): Justify method: \"left\", \"center\"\
    , \"full\", \"right\". Defaults to None.\n        overflow (str, optional): Overflow\
    \ method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.\n        no_wrap\
    \ (bool, optional): Disable text wrapping, or None for default. Defaults to None.\n\
    \        end (str, optional): Character to end text with. Defaults to \"\\\\\\\
    \\n\".\n        tab_size (int): Number of spaces per tab, or ``None`` to use ``console.tab_size``.\
    \ Defaults to None.\n        spans (List[Span], optional). A list of predefined\
    \ style spans. Defaults to None.\n    \"\"\"\n\n    __slots__ = [\n        \"\
    _text\",\n        \"style\",\n        \"justify\",\n        \"overflow\",\n  \
    \      \"no_wrap\",\n        \"end\",\n        \"tab_size\",\n        \"_spans\"\
    ,\n        \"_length\",\n    ]\n\n    def __init__(\n        self,\n        text:\
    \ str = \"\",\n        style: Union[str, Style] = \"\",\n        *,\n        justify:\
    \ Optional[\"JustifyMethod\"] = None,\n        overflow: Optional[\"OverflowMethod\"\
    ] = None,\n        no_wrap: Optional[bool] = None,\n        end: str = \"\\n\"\
    ,\n        tab_size: Optional[int] = None,\n        spans: Optional[List[Span]]\
    \ = None,\n    ) -> None:\n        sanitized_text = strip_control_codes(text)\n\
    \        self._text = [sanitized_text]\n        self.style = style\n        self.justify:\
    \ Optional[\"JustifyMethod\"] = justify\n        self.overflow: Optional[\"OverflowMethod\"\
    ] = overflow\n        self.no_wrap = no_wrap\n        self.end = end\n       \
    \ self.tab_size = tab_size\n        self._spans: List[Span] = spans or []\n  \
    \      self._length: int = len(sanitized_text)\n\n    def __len__(self) -> int:\n\
    \        return self._length\n\n    def __bool__(self) -> bool:\n        return\
    \ bool(self._length)\n\n    def __str__(self) -> str:\n        return self.plain\n\
    \n    def __repr__(self) -> str:\n        return f\"<text {self.plain!r} {self._spans!r}\
    \ {self.style!r}>\"\n\n    def __add__(self, other: Any) -> \"Text\":\n      \
    \  if isinstance(other, (str, Text)):\n            result = self.copy()\n    \
    \        result.append(other)\n            return result\n        return NotImplemented\n\
    \n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other,\
    \ Text):\n            return NotImplemented\n        return self.plain == other.plain\
    \ and self._spans == other._spans\n\n    def __contains__(self, other: object)\
    \ -> bool:\n        if isinstance(other, str):\n            return other in self.plain\n\
    \        elif isinstance(other, Text):\n            return other.plain in self.plain\n\
    \        return False\n\n    def __getitem__(self, slice: Union[int, slice]) ->\
    \ \"Text\":\n        def get_text_at(offset: int) -> \"Text\":\n            _Span\
    \ = Span\n            text = Text(\n                self.plain[offset],\n    \
    \            spans=[\n                    _Span(0, 1, style)\n               \
    \     for start, end, style in self._spans\n                    if end > offset\
    \ >= start\n                ],\n                end=\"\",\n            )\n   \
    \         return text\n\n        if isinstance(slice, int):\n            return\
    \ get_text_at(slice)\n        else:\n            start, stop, step = slice.indices(len(self.plain))\n\
    \            if step == 1:\n                lines = self.divide([start, stop])\n\
    \                return lines[1]\n            else:\n                # This would\
    \ be a bit of work to implement efficiently\n                # For now, its not\
    \ required\n                raise TypeError(\"slices with step!=1 are not supported\"\
    )\n\n    @property\n    def cell_len(self) -> int:\n        \"\"\"Get the number\
    \ of cells required to render this text.\"\"\"\n        return cell_len(self.plain)\n\
    \n    @property\n    def markup(self) -> str:\n        \"\"\"Get console markup\
    \ to render this Text.\n\n        Returns:\n            str: A string potentially\
    \ creating markup tags.\n        \"\"\"\n        from .markup import escape\n\n\
    \        output: List[str] = []\n\n        plain = self.plain\n        markup_spans\
    \ = [\n            (0, False, self.style),\n            *((span.start, False,\
    \ span.style) for span in self._spans),\n            *((span.end, True, span.style)\
    \ for span in self._spans),\n            (len(plain), True, self.style),\n   \
    \     ]\n        markup_spans.sort(key=itemgetter(0, 1))\n        position = 0\n\
    \        append = output.append\n        for offset, closing, style in markup_spans:\n\
    \            if offset > position:\n                append(escape(plain[position:offset]))\n\
    \                position = offset\n            if style:\n                append(f\"\
    [/{style}]\" if closing else f\"[{style}]\")\n        markup = \"\".join(output)\n\
    \        return markup\n\n    @classmethod\n    def from_markup(\n        cls,\n\
    \        text: str,\n        *,\n        style: Union[str, Style] = \"\",\n  \
    \      emoji: bool = True,\n        emoji_variant: Optional[EmojiVariant] = None,\n\
    \        justify: Optional[\"JustifyMethod\"] = None,\n        overflow: Optional[\"\
    OverflowMethod\"] = None,\n        end: str = \"\\n\",\n    ) -> \"Text\":\n \
    \       \"\"\"Create Text instance from markup.\n\n        Args:\n           \
    \ text (str): A string containing console markup.\n            style (Union[str,\
    \ Style], optional): Base style for text. Defaults to \"\".\n            emoji\
    \ (bool, optional): Also render emoji code. Defaults to True.\n            emoji_variant\
    \ (str, optional): Optional emoji variant, either \"text\" or \"emoji\". Defaults\
    \ to None.\n            justify (str, optional): Justify method: \"left\", \"\
    center\", \"full\", \"right\". Defaults to None.\n            overflow (str, optional):\
    \ Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.\n     \
    \       end (str, optional): Character to end text with. Defaults to \"\\\\\\\\\
    n\".\n\n        Returns:\n            Text: A Text instance with markup rendered.\n\
    \        \"\"\"\n        from .markup import render\n\n        rendered_text =\
    \ render(text, style, emoji=emoji, emoji_variant=emoji_variant)\n        rendered_text.justify\
    \ = justify\n        rendered_text.overflow = overflow\n        rendered_text.end\
    \ = end\n        return rendered_text\n\n    @classmethod\n    def from_ansi(\n\
    \        cls,\n        text: str,\n        *,\n        style: Union[str, Style]\
    \ = \"\",\n        justify: Optional[\"JustifyMethod\"] = None,\n        overflow:\
    \ Optional[\"OverflowMethod\"] = None,\n        no_wrap: Optional[bool] = None,\n\
    \        end: str = \"\\n\",\n        tab_size: Optional[int] = 8,\n    ) -> \"\
    Text\":\n        \"\"\"Create a Text object from a string containing ANSI escape\
    \ codes.\n\n        Args:\n            text (str): A string containing escape\
    \ codes.\n            style (Union[str, Style], optional): Base style for text.\
    \ Defaults to \"\".\n            justify (str, optional): Justify method: \"left\"\
    , \"center\", \"full\", \"right\". Defaults to None.\n            overflow (str,\
    \ optional): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.\n\
    \            no_wrap (bool, optional): Disable text wrapping, or None for default.\
    \ Defaults to None.\n            end (str, optional): Character to end text with.\
    \ Defaults to \"\\\\\\\\n\".\n            tab_size (int): Number of spaces per\
    \ tab, or ``None`` to use ``console.tab_size``. Defaults to None.\n        \"\"\
    \"\n        from .ansi import AnsiDecoder\n\n        joiner = Text(\n        \
    \    \"\\n\",\n            justify=justify,\n            overflow=overflow,\n\
    \            no_wrap=no_wrap,\n            end=end,\n            tab_size=tab_size,\n\
    \            style=style,\n        )\n        decoder = AnsiDecoder()\n      \
    \  result = joiner.join(line for line in decoder.decode(text))\n        return\
    \ result\n\n    @classmethod\n    def styled(\n        cls,\n        text: str,\n\
    \        style: StyleType = \"\",\n        *,\n        justify: Optional[\"JustifyMethod\"\
    ] = None,\n        overflow: Optional[\"OverflowMethod\"] = None,\n    ) -> \"\
    Text\":\n        \"\"\"Construct a Text instance with a pre-applied styled. A\
    \ style applied in this way won't be used\n        to pad the text when it is\
    \ justified.\n\n        Args:\n            text (str): A string containing console\
    \ markup.\n            style (Union[str, Style]): Style to apply to the text.\
    \ Defaults to \"\".\n            justify (str, optional): Justify method: \"left\"\
    , \"center\", \"full\", \"right\". Defaults to None.\n            overflow (str,\
    \ optional): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.\n\
    \n        Returns:\n            Text: A text instance with a style applied to\
    \ the entire string.\n        \"\"\"\n        styled_text = cls(text, justify=justify,\
    \ overflow=overflow)\n        styled_text.stylize(style)\n        return styled_text\n\
    \n    @classmethod\n    def assemble(\n        cls,\n        *parts: Union[str,\
    \ \"Text\", Tuple[str, StyleType]],\n        style: Union[str, Style] = \"\",\n\
    \        justify: Optional[\"JustifyMethod\"] = None,\n        overflow: Optional[\"\
    OverflowMethod\"] = None,\n        no_wrap: Optional[bool] = None,\n        end:\
    \ str = \"\\n\",\n        tab_size: int = 8,\n        meta: Optional[Dict[str,\
    \ Any]] = None,\n    ) -> \"Text\":\n        \"\"\"Construct a text instance by\
    \ combining a sequence of strings with optional styles.\n        The positional\
    \ arguments should be either strings, or a tuple of string + style.\n\n      \
    \  Args:\n            style (Union[str, Style], optional): Base style for text.\
    \ Defaults to \"\".\n            justify (str, optional): Justify method: \"left\"\
    , \"center\", \"full\", \"right\". Defaults to None.\n            overflow (str,\
    \ optional): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to None.\n\
    \            no_wrap (bool, optional): Disable text wrapping, or None for default.\
    \ Defaults to None.\n            end (str, optional): Character to end text with.\
    \ Defaults to \"\\\\\\\\n\".\n            tab_size (int): Number of spaces per\
    \ tab, or ``None`` to use ``console.tab_size``. Defaults to None.\n          \
    \  meta (Dict[str, Any], optional). Meta data to apply to text, or None for no\
    \ meta data. Default to None\n\n        Returns:\n            Text: A new text\
    \ instance.\n        \"\"\"\n        text = cls(\n            style=style,\n \
    \           justify=justify,\n            overflow=overflow,\n            no_wrap=no_wrap,\n\
    \            end=end,\n            tab_size=tab_size,\n        )\n        append\
    \ = text.append\n        _Text = Text\n        for part in parts:\n          \
    \  if isinstance(part, (_Text, str)):\n                append(part)\n        \
    \    else:\n                append(*part)\n        if meta:\n            text.apply_meta(meta)\n\
    \        return text\n\n    @property\n    def plain(self) -> str:\n        \"\
    \"\"Get the text as a single string.\"\"\"\n        if len(self._text) != 1:\n\
    \            self._text[:] = [\"\".join(self._text)]\n        return self._text[0]\n\
    \n    @plain.setter\n    def plain(self, new_text: str) -> None:\n        \"\"\
    \"Set the text to a new value.\"\"\"\n        if new_text != self.plain:\n   \
    \         sanitized_text = strip_control_codes(new_text)\n            self._text[:]\
    \ = [sanitized_text]\n            old_length = self._length\n            self._length\
    \ = len(sanitized_text)\n            if old_length > self._length:\n         \
    \       self._trim_spans()\n\n    @property\n    def spans(self) -> List[Span]:\n\
    \        \"\"\"Get a reference to the internal list of spans.\"\"\"\n        return\
    \ self._spans\n\n    @spans.setter\n    def spans(self, spans: List[Span]) ->\
    \ None:\n        \"\"\"Set spans.\"\"\"\n        self._spans = spans[:]\n\n  \
    \  def blank_copy(self, plain: str = \"\") -> \"Text\":\n        \"\"\"Return\
    \ a new Text instance with copied metadata (but not the string or spans).\"\"\"\
    \n        copy_self = Text(\n            plain,\n            style=self.style,\n\
    \            justify=self.justify,\n            overflow=self.overflow,\n    \
    \        no_wrap=self.no_wrap,\n            end=self.end,\n            tab_size=self.tab_size,\n\
    \        )\n        return copy_self\n\n    def copy(self) -> \"Text\":\n    \
    \    \"\"\"Return a copy of this instance.\"\"\"\n        copy_self = Text(\n\
    \            self.plain,\n            style=self.style,\n            justify=self.justify,\n\
    \            overflow=self.overflow,\n            no_wrap=self.no_wrap,\n    \
    \        end=self.end,\n            tab_size=self.tab_size,\n        )\n     \
    \   copy_self._spans[:] = self._spans\n        return copy_self\n\n    def stylize(\n\
    \        self,\n        style: Union[str, Style],\n        start: int = 0,\n \
    \       end: Optional[int] = None,\n    ) -> None:\n        \"\"\"Apply a style\
    \ to the text, or a portion of the text.\n\n        Args:\n            style (Union[str,\
    \ Style]): Style instance or style definition to apply.\n            start (int):\
    \ Start offset (negative indexing is supported). Defaults to 0.\n            end\
    \ (Optional[int], optional): End offset (negative indexing is supported), or None\
    \ for end of text. Defaults to None.\n        \"\"\"\n        if style:\n    \
    \        length = len(self)\n            if start < 0:\n                start\
    \ = length + start\n            if end is None:\n                end = length\n\
    \            if end < 0:\n                end = length + end\n            if start\
    \ >= length or end <= start:\n                # Span not in text or not valid\n\
    \                return\n            self._spans.append(Span(start, min(length,\
    \ end), style))\n\n    def stylize_before(\n        self,\n        style: Union[str,\
    \ Style],\n        start: int = 0,\n        end: Optional[int] = None,\n    )\
    \ -> None:\n        \"\"\"Apply a style to the text, or a portion of the text.\
    \ Styles will be applied before other styles already present.\n\n        Args:\n\
    \            style (Union[str, Style]): Style instance or style definition to\
    \ apply.\n            start (int): Start offset (negative indexing is supported).\
    \ Defaults to 0.\n            end (Optional[int], optional): End offset (negative\
    \ indexing is supported), or None for end of text. Defaults to None.\n       \
    \ \"\"\"\n        if style:\n            length = len(self)\n            if start\
    \ < 0:\n                start = length + start\n            if end is None:\n\
    \                end = length\n            if end < 0:\n                end =\
    \ length + end\n            if start >= length or end <= start:\n            \
    \    # Span not in text or not valid\n                return\n            self._spans.insert(0,\
    \ Span(start, min(length, end), style))\n\n    def apply_meta(\n        self,\
    \ meta: Dict[str, Any], start: int = 0, end: Optional[int] = None\n    ) -> None:\n\
    \        \"\"\"Apply metadata to the text, or a portion of the text.\n\n     \
    \   Args:\n            meta (Dict[str, Any]): A dict of meta information.\n  \
    \          start (int): Start offset (negative indexing is supported). Defaults\
    \ to 0.\n            end (Optional[int], optional): End offset (negative indexing\
    \ is supported), or None for end of text. Defaults to None.\n\n        \"\"\"\n\
    \        style = Style.from_meta(meta)\n        self.stylize(style, start=start,\
    \ end=end)\n\n    def on(self, meta: Optional[Dict[str, Any]] = None, **handlers:\
    \ Any) -> \"Text\":\n        \"\"\"Apply event handlers (used by Textual project).\n\
    \n        Example:\n            >>> from rich.text import Text\n            >>>\
    \ text = Text(\"hello world\")\n            >>> text.on(click=\"view.toggle('world')\"\
    )\n\n        Args:\n            meta (Dict[str, Any]): Mapping of meta information.\n\
    \            **handlers: Keyword args are prefixed with \"@\" to defined handlers.\n\
    \n        Returns:\n            Text: Self is returned to method may be chained.\n\
    \        \"\"\"\n        meta = {} if meta is None else meta\n        meta.update({f\"\
    @{key}\": value for key, value in handlers.items()})\n        self.stylize(Style.from_meta(meta))\n\
    \        return self\n\n    def remove_suffix(self, suffix: str) -> None:\n  \
    \      \"\"\"Remove a suffix if it exists.\n\n        Args:\n            suffix\
    \ (str): Suffix to remove.\n        \"\"\"\n        if self.plain.endswith(suffix):\n\
    \            self.right_crop(len(suffix))\n\n    def get_style_at_offset(self,\
    \ console: \"Console\", offset: int) -> Style:\n        \"\"\"Get the style of\
    \ a character at give offset.\n\n        Args:\n            console (~Console):\
    \ Console where text will be rendered.\n            offset (int): Offset in to\
    \ text (negative indexing supported)\n\n        Returns:\n            Style: A\
    \ Style instance.\n        \"\"\"\n        # TODO: This is a little inefficient,\
    \ it is only used by full justify\n        if offset < 0:\n            offset\
    \ = len(self) + offset\n        get_style = console.get_style\n        style =\
    \ get_style(self.style).copy()\n        for start, end, span_style in self._spans:\n\
    \            if end > offset >= start:\n                style += get_style(span_style,\
    \ default=\"\")\n        return style\n\n    def extend_style(self, spaces: int)\
    \ -> None:\n        \"\"\"Extend the Text given number of spaces where the spaces\
    \ have the same style as the last character.\n\n        Args:\n            spaces\
    \ (int): Number of spaces to add to the Text.\n        \"\"\"\n        if spaces\
    \ <= 0:\n            return\n        spans = self.spans\n        new_spaces =\
    \ \" \" * spaces\n        if spans:\n            end_offset = len(self)\n    \
    \        self._spans[:] = [\n                span.extend(spaces) if span.end >=\
    \ end_offset else span\n                for span in spans\n            ]\n   \
    \         self._text.append(new_spaces)\n            self._length += spaces\n\
    \        else:\n            self.plain += new_spaces\n\n    def highlight_regex(\n\
    \        self,\n        re_highlight: Union[Pattern[str], str],\n        style:\
    \ Optional[Union[GetStyleCallable, StyleType]] = None,\n        *,\n        style_prefix:\
    \ str = \"\",\n    ) -> int:\n        \"\"\"Highlight text with a regular expression,\
    \ where group names are\n        translated to styles.\n\n        Args:\n    \
    \        re_highlight (Union[re.Pattern, str]): A regular expression object or\
    \ string.\n            style (Union[GetStyleCallable, StyleType]): Optional style\
    \ to apply to whole match, or a callable\n                which accepts the matched\
    \ text and returns a style. Defaults to None.\n            style_prefix (str,\
    \ optional): Optional prefix to add to style group names.\n\n        Returns:\n\
    \            int: Number of regex matches\n        \"\"\"\n        count = 0\n\
    \        append_span = self._spans.append\n        _Span = Span\n        plain\
    \ = self.plain\n        if isinstance(re_highlight, str):\n            re_highlight\
    \ = re.compile(re_highlight)\n        for match in re_highlight.finditer(plain):\n\
    \            get_span = match.span\n            if style:\n                start,\
    \ end = get_span()\n                match_style = style(plain[start:end]) if callable(style)\
    \ else style\n                if match_style is not None and end > start:\n  \
    \                  append_span(_Span(start, end, match_style))\n\n           \
    \ count += 1\n            for name in match.groupdict().keys():\n            \
    \    start, end = get_span(name)\n                if start != -1 and end > start:\n\
    \                    append_span(_Span(start, end, f\"{style_prefix}{name}\"))\n\
    \        return count\n\n    def highlight_words(\n        self,\n        words:\
    \ Iterable[str],\n        style: Union[str, Style],\n        *,\n        case_sensitive:\
    \ bool = True,\n    ) -> int:\n        \"\"\"Highlight words with a style.\n\n\
    \        Args:\n            words (Iterable[str]): Words to highlight.\n     \
    \       style (Union[str, Style]): Style to apply.\n            case_sensitive\
    \ (bool, optional): Enable case sensitive matching. Defaults to True.\n\n    \
    \    Returns:\n            int: Number of words highlighted.\n        \"\"\"\n\
    \        re_words = \"|\".join(re.escape(word) for word in words)\n        add_span\
    \ = self._spans.append\n        count = 0\n        _Span = Span\n        for match\
    \ in re.finditer(\n            re_words, self.plain, flags=0 if case_sensitive\
    \ else re.IGNORECASE\n        ):\n            start, end = match.span(0)\n   \
    \         add_span(_Span(start, end, style))\n            count += 1\n       \
    \ return count\n\n    def rstrip(self) -> None:\n        \"\"\"Strip whitespace\
    \ from end of text.\"\"\"\n        self.plain = self.plain.rstrip()\n\n    def\
    \ rstrip_end(self, size: int) -> None:\n        \"\"\"Remove whitespace beyond\
    \ a certain width at the end of the text.\n\n        Args:\n            size (int):\
    \ The desired size of the text.\n        \"\"\"\n        text_length = len(self)\n\
    \        if text_length > size:\n            excess = text_length - size\n   \
    \         whitespace_match = _re_whitespace.search(self.plain)\n            if\
    \ whitespace_match is not None:\n                whitespace_count = len(whitespace_match.group(0))\n\
    \                self.right_crop(min(whitespace_count, excess))\n\n    def set_length(self,\
    \ new_length: int) -> None:\n        \"\"\"Set new length of the text, clipping\
    \ or padding is required.\"\"\"\n        length = len(self)\n        if length\
    \ != new_length:\n            if length < new_length:\n                self.pad_right(new_length\
    \ - length)\n            else:\n                self.right_crop(length - new_length)\n\
    \n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\
    \n    ) -> Iterable[Segment]:\n        tab_size: int = console.tab_size if self.tab_size\
    \ is None else self.tab_size\n        justify = self.justify or options.justify\
    \ or DEFAULT_JUSTIFY\n\n        overflow = self.overflow or options.overflow or\
    \ DEFAULT_OVERFLOW\n\n        lines = self.wrap(\n            console,\n     \
    \       options.max_width,\n            justify=justify,\n            overflow=overflow,\n\
    \            tab_size=tab_size or 8,\n            no_wrap=pick_bool(self.no_wrap,\
    \ options.no_wrap, False),\n        )\n        all_lines = Text(\"\\n\").join(lines)\n\
    \        yield from all_lines.render(console, end=self.end)\n\n    def __rich_measure__(\n\
    \        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Measurement:\n\
    \        text = self.plain\n        lines = text.splitlines()\n        max_text_width\
    \ = max(cell_len(line) for line in lines) if lines else 0\n        words = text.split()\n\
    \        min_text_width = (\n            max(cell_len(word) for word in words)\
    \ if words else max_text_width\n        )\n        return Measurement(min_text_width,\
    \ max_text_width)\n\n    def render(self, console: \"Console\", end: str = \"\"\
    ) -> Iterable[\"Segment\"]:\n        \"\"\"Render the text as Segments.\n\n  \
    \      Args:\n            console (Console): Console instance.\n            end\
    \ (Optional[str], optional): Optional end character.\n\n        Returns:\n   \
    \         Iterable[Segment]: Result of render that may be written to the console.\n\
    \        \"\"\"\n        _Segment = Segment\n        text = self.plain\n     \
    \   if not self._spans:\n            yield Segment(text)\n            if end:\n\
    \                yield _Segment(end)\n            return\n        get_style =\
    \ partial(console.get_style, default=Style.null())\n\n        enumerated_spans\
    \ = list(enumerate(self._spans, 1))\n        style_map = {index: get_style(span.style)\
    \ for index, span in enumerated_spans}\n        style_map[0] = get_style(self.style)\n\
    \n        spans = [\n            (0, False, 0),\n            *((span.start, False,\
    \ index) for index, span in enumerated_spans),\n            *((span.end, True,\
    \ index) for index, span in enumerated_spans),\n            (len(text), True,\
    \ 0),\n        ]\n        spans.sort(key=itemgetter(0, 1))\n\n        stack: List[int]\
    \ = []\n        stack_append = stack.append\n        stack_pop = stack.remove\n\
    \n        style_cache: Dict[Tuple[Style, ...], Style] = {}\n        style_cache_get\
    \ = style_cache.get\n        combine = Style.combine\n\n        def get_current_style()\
    \ -> Style:\n            \"\"\"Construct current style from stack.\"\"\"\n   \
    \         styles = tuple(style_map[_style_id] for _style_id in sorted(stack))\n\
    \            cached_style = style_cache_get(styles)\n            if cached_style\
    \ is not None:\n                return cached_style\n            current_style\
    \ = combine(styles)\n            style_cache[styles] = current_style\n       \
    \     return current_style\n\n        for (offset, leaving, style_id), (next_offset,\
    \ _, _) in zip(spans, spans[1:]):\n            if leaving:\n                stack_pop(style_id)\n\
    \            else:\n                stack_append(style_id)\n            if next_offset\
    \ > offset:\n                yield _Segment(text[offset:next_offset], get_current_style())\n\
    \        if end:\n            yield _Segment(end)\n\n    def join(self, lines:\
    \ Iterable[\"Text\"]) -> \"Text\":\n        \"\"\"Join text together with this\
    \ instance as the separator.\n\n        Args:\n            lines (Iterable[Text]):\
    \ An iterable of Text instances to join.\n\n        Returns:\n            Text:\
    \ A new text instance containing join text.\n        \"\"\"\n\n        new_text\
    \ = self.blank_copy()\n\n        def iter_text() -> Iterable[\"Text\"]:\n    \
    \        if self.plain:\n                for last, line in loop_last(lines):\n\
    \                    yield line\n                    if not last:\n          \
    \              yield self\n            else:\n                yield from lines\n\
    \n        extend_text = new_text._text.extend\n        append_span = new_text._spans.append\n\
    \        extend_spans = new_text._spans.extend\n        offset = 0\n        _Span\
    \ = Span\n\n        for text in iter_text():\n            extend_text(text._text)\n\
    \            if text.style:\n                append_span(_Span(offset, offset\
    \ + len(text), text.style))\n            extend_spans(\n                _Span(offset\
    \ + start, offset + end, style)\n                for start, end, style in text._spans\n\
    \            )\n            offset += len(text)\n        new_text._length = offset\n\
    \        return new_text\n\n    def expand_tabs(self, tab_size: Optional[int]\
    \ = None) -> None:\n        \"\"\"Converts tabs to spaces.\n\n        Args:\n\
    \            tab_size (int, optional): Size of tabs. Defaults to 8.\n\n      \
    \  \"\"\"\n        if \"\\t\" not in self.plain:\n            return\n       \
    \ if tab_size is None:\n            tab_size = self.tab_size\n        if tab_size\
    \ is None:\n            tab_size = 8\n\n        new_text: List[Text] = []\n  \
    \      append = new_text.append\n\n        for line in self.split(\"\\n\", include_separator=True):\n\
    \            if \"\\t\" not in line.plain:\n                append(line)\n   \
    \         else:\n                cell_position = 0\n                parts = line.split(\"\
    \\t\", include_separator=True)\n                for part in parts:\n         \
    \           if part.plain.endswith(\"\\t\"):\n                        part._text[-1]\
    \ = part._text[-1][:-1] + \" \"\n                        cell_position += part.cell_len\n\
    \                        tab_remainder = cell_position % tab_size\n          \
    \              if tab_remainder:\n                            spaces = tab_size\
    \ - tab_remainder\n                            part.extend_style(spaces)\n   \
    \                         cell_position += spaces\n                    else:\n\
    \                        cell_position += part.cell_len\n                    append(part)\n\
    \n        result = Text(\"\").join(new_text)\n\n        self._text = [result.plain]\n\
    \        self._length = len(self.plain)\n        self._spans[:] = result._spans\n\
    \n    def truncate(\n        self,\n        max_width: int,\n        *,\n    \
    \    overflow: Optional[\"OverflowMethod\"] = None,\n        pad: bool = False,\n\
    \    ) -> None:\n        \"\"\"Truncate text if it is longer that a given width.\n\
    \n        Args:\n            max_width (int): Maximum number of characters in\
    \ text.\n            overflow (str, optional): Overflow method: \"crop\", \"fold\"\
    , or \"ellipsis\". Defaults to None, to use self.overflow.\n            pad (bool,\
    \ optional): Pad with spaces if the length is less than max_width. Defaults to\
    \ False.\n        \"\"\"\n        _overflow = overflow or self.overflow or DEFAULT_OVERFLOW\n\
    \        if _overflow != \"ignore\":\n            length = cell_len(self.plain)\n\
    \            if length > max_width:\n                if _overflow == \"ellipsis\"\
    :\n                    self.plain = set_cell_size(self.plain, max_width - 1) +\
    \ \"\"\n                else:\n                    self.plain = set_cell_size(self.plain,\
    \ max_width)\n            if pad and length < max_width:\n                spaces\
    \ = max_width - length\n                self._text = [f\"{self.plain}{' ' * spaces}\"\
    ]\n                self._length = len(self.plain)\n\n    def _trim_spans(self)\
    \ -> None:\n        \"\"\"Remove or modify any spans that are over the end of\
    \ the text.\"\"\"\n        max_offset = len(self.plain)\n        _Span = Span\n\
    \        self._spans[:] = [\n            (\n                span\n           \
    \     if span.end < max_offset\n                else _Span(span.start, min(max_offset,\
    \ span.end), span.style)\n            )\n            for span in self._spans\n\
    \            if span.start < max_offset\n        ]\n\n    def pad(self, count:\
    \ int, character: str = \" \") -> None:\n        \"\"\"Pad left and right with\
    \ a given number of characters.\n\n        Args:\n            count (int): Width\
    \ of padding.\n            character (str): The character to pad with. Must be\
    \ a string of length 1.\n        \"\"\"\n        assert len(character) == 1, \"\
    Character must be a string of length 1\"\n        if count:\n            pad_characters\
    \ = character * count\n            self.plain = f\"{pad_characters}{self.plain}{pad_characters}\"\
    \n            _Span = Span\n            self._spans[:] = [\n                _Span(start\
    \ + count, end + count, style)\n                for start, end, style in self._spans\n\
    \            ]\n\n    def pad_left(self, count: int, character: str = \" \") ->\
    \ None:\n        \"\"\"Pad the left with a given character.\n\n        Args:\n\
    \            count (int): Number of characters to pad.\n            character\
    \ (str, optional): Character to pad with. Defaults to \" \".\n        \"\"\"\n\
    \        assert len(character) == 1, \"Character must be a string of length 1\"\
    \n        if count:\n            self.plain = f\"{character * count}{self.plain}\"\
    \n            _Span = Span\n            self._spans[:] = [\n                _Span(start\
    \ + count, end + count, style)\n                for start, end, style in self._spans\n\
    \            ]\n\n    def pad_right(self, count: int, character: str = \" \")\
    \ -> None:\n        \"\"\"Pad the right with a given character.\n\n        Args:\n\
    \            count (int): Number of characters to pad.\n            character\
    \ (str, optional): Character to pad with. Defaults to \" \".\n        \"\"\"\n\
    \        assert len(character) == 1, \"Character must be a string of length 1\"\
    \n        if count:\n            self.plain = f\"{self.plain}{character * count}\"\
    \n\n    def align(self, align: AlignMethod, width: int, character: str = \" \"\
    ) -> None:\n        \"\"\"Align text to a given width.\n\n        Args:\n    \
    \        align (AlignMethod): One of \"left\", \"center\", or \"right\".\n   \
    \         width (int): Desired width.\n            character (str, optional):\
    \ Character to pad with. Defaults to \" \".\n        \"\"\"\n        self.truncate(width)\n\
    \        excess_space = width - cell_len(self.plain)\n        if excess_space:\n\
    \            if align == \"left\":\n                self.pad_right(excess_space,\
    \ character)\n            elif align == \"center\":\n                left = excess_space\
    \ // 2\n                self.pad_left(left, character)\n                self.pad_right(excess_space\
    \ - left, character)\n            else:\n                self.pad_left(excess_space,\
    \ character)\n\n    def append(\n        self, text: Union[\"Text\", str], style:\
    \ Optional[Union[str, \"Style\"]] = None\n    ) -> \"Text\":\n        \"\"\"Add\
    \ text with an optional style.\n\n        Args:\n            text (Union[Text,\
    \ str]): A str or Text to append.\n            style (str, optional): A style\
    \ name. Defaults to None.\n\n        Returns:\n            Text: Returns self\
    \ for chaining.\n        \"\"\"\n\n        if not isinstance(text, (str, Text)):\n\
    \            raise TypeError(\"Only str or Text can be appended to Text\")\n\n\
    \        if len(text):\n            if isinstance(text, str):\n              \
    \  sanitized_text = strip_control_codes(text)\n                self._text.append(sanitized_text)\n\
    \                offset = len(self)\n                text_length = len(sanitized_text)\n\
    \                if style:\n                    self._spans.append(Span(offset,\
    \ offset + text_length, style))\n                self._length += text_length\n\
    \            elif isinstance(text, Text):\n                _Span = Span\n    \
    \            if style is not None:\n                    raise ValueError(\n  \
    \                      \"style must not be set when appending Text instance\"\n\
    \                    )\n                text_length = self._length\n         \
    \       if text.style:\n                    self._spans.append(\n            \
    \            _Span(text_length, text_length + len(text), text.style)\n       \
    \             )\n                self._text.append(text.plain)\n             \
    \   self._spans.extend(\n                    _Span(start + text_length, end +\
    \ text_length, style)\n                    for start, end, style in text._spans.copy()\n\
    \                )\n                self._length += len(text)\n        return\
    \ self\n\n    def append_text(self, text: \"Text\") -> \"Text\":\n        \"\"\
    \"Append another Text instance. This method is more performant that Text.append,\
    \ but\n        only works for Text.\n\n        Args:\n            text (Text):\
    \ The Text instance to append to this instance.\n\n        Returns:\n        \
    \    Text: Returns self for chaining.\n        \"\"\"\n        _Span = Span\n\
    \        text_length = self._length\n        if text.style:\n            self._spans.append(_Span(text_length,\
    \ text_length + len(text), text.style))\n        self._text.append(text.plain)\n\
    \        self._spans.extend(\n            _Span(start + text_length, end + text_length,\
    \ style)\n            for start, end, style in text._spans.copy()\n        )\n\
    \        self._length += len(text)\n        return self\n\n    def append_tokens(\n\
    \        self, tokens: Iterable[Tuple[str, Optional[StyleType]]]\n    ) -> \"\
    Text\":\n        \"\"\"Append iterable of str and style. Style may be a Style\
    \ instance or a str style definition.\n\n        Args:\n            tokens (Iterable[Tuple[str,\
    \ Optional[StyleType]]]): An iterable of tuples containing str content and style.\n\
    \n        Returns:\n            Text: Returns self for chaining.\n        \"\"\
    \"\n        append_text = self._text.append\n        append_span = self._spans.append\n\
    \        _Span = Span\n        offset = len(self)\n        for content, style\
    \ in tokens:\n            content = strip_control_codes(content)\n           \
    \ append_text(content)\n            if style:\n                append_span(_Span(offset,\
    \ offset + len(content), style))\n            offset += len(content)\n       \
    \ self._length = offset\n        return self\n\n    def copy_styles(self, text:\
    \ \"Text\") -> None:\n        \"\"\"Copy styles from another Text instance.\n\n\
    \        Args:\n            text (Text): A Text instance to copy styles from,\
    \ must be the same length.\n        \"\"\"\n        self._spans.extend(text._spans)\n\
    \n    def split(\n        self,\n        separator: str = \"\\n\",\n        *,\n\
    \        include_separator: bool = False,\n        allow_blank: bool = False,\n\
    \    ) -> Lines:\n        \"\"\"Split rich text in to lines, preserving styles.\n\
    \n        Args:\n            separator (str, optional): String to split on. Defaults\
    \ to \"\\\\\\\\n\".\n            include_separator (bool, optional): Include the\
    \ separator in the lines. Defaults to False.\n            allow_blank (bool, optional):\
    \ Return a blank line if the text ends with a separator. Defaults to False.\n\n\
    \        Returns:\n            List[RichText]: A list of rich text, one per line\
    \ of the original.\n        \"\"\"\n        assert separator, \"separator must\
    \ not be empty\"\n\n        text = self.plain\n        if separator not in text:\n\
    \            return Lines([self.copy()])\n\n        if include_separator:\n  \
    \          lines = self.divide(\n                match.end() for match in re.finditer(re.escape(separator),\
    \ text)\n            )\n        else:\n\n            def flatten_spans() -> Iterable[int]:\n\
    \                for match in re.finditer(re.escape(separator), text):\n     \
    \               start, end = match.span()\n                    yield start\n \
    \                   yield end\n\n            lines = Lines(\n                line\
    \ for line in self.divide(flatten_spans()) if line.plain != separator\n      \
    \      )\n\n        if not allow_blank and text.endswith(separator):\n       \
    \     lines.pop()\n\n        return lines\n\n    def divide(self, offsets: Iterable[int])\
    \ -> Lines:\n        \"\"\"Divide text in to a number of lines at given offsets.\n\
    \n        Args:\n            offsets (Iterable[int]): Offsets used to divide text.\n\
    \n        Returns:\n            Lines: New RichText instances between offsets.\n\
    \        \"\"\"\n        _offsets = list(offsets)\n\n        if not _offsets:\n\
    \            return Lines([self.copy()])\n\n        text = self.plain\n      \
    \  text_length = len(text)\n        divide_offsets = [0, *_offsets, text_length]\n\
    \        line_ranges = list(zip(divide_offsets, divide_offsets[1:]))\n\n     \
    \   style = self.style\n        justify = self.justify\n        overflow = self.overflow\n\
    \        _Text = Text\n        new_lines = Lines(\n            _Text(\n      \
    \          text[start:end],\n                style=style,\n                justify=justify,\n\
    \                overflow=overflow,\n            )\n            for start, end\
    \ in line_ranges\n        )\n        if not self._spans:\n            return new_lines\n\
    \n        _line_appends = [line._spans.append for line in new_lines._lines]\n\
    \        line_count = len(line_ranges)\n        _Span = Span\n\n        for span_start,\
    \ span_end, style in self._spans:\n            lower_bound = 0\n            upper_bound\
    \ = line_count\n            start_line_no = (lower_bound + upper_bound) // 2\n\
    \n            while True:\n                line_start, line_end = line_ranges[start_line_no]\n\
    \                if span_start < line_start:\n                    upper_bound\
    \ = start_line_no - 1\n                elif span_start > line_end:\n         \
    \           lower_bound = start_line_no + 1\n                else:\n         \
    \           break\n                start_line_no = (lower_bound + upper_bound)\
    \ // 2\n\n            if span_end < line_end:\n                end_line_no = start_line_no\n\
    \            else:\n                end_line_no = lower_bound = start_line_no\n\
    \                upper_bound = line_count\n\n                while True:\n   \
    \                 line_start, line_end = line_ranges[end_line_no]\n          \
    \          if span_end < line_start:\n                        upper_bound = end_line_no\
    \ - 1\n                    elif span_end > line_end:\n                       \
    \ lower_bound = end_line_no + 1\n                    else:\n                 \
    \       break\n                    end_line_no = (lower_bound + upper_bound) //\
    \ 2\n\n            for line_no in range(start_line_no, end_line_no + 1):\n   \
    \             line_start, line_end = line_ranges[line_no]\n                new_start\
    \ = max(0, span_start - line_start)\n                new_end = min(span_end -\
    \ line_start, line_end - line_start)\n                if new_end > new_start:\n\
    \                    _line_appends[line_no](_Span(new_start, new_end, style))\n\
    \n        return new_lines\n\n    def right_crop(self, amount: int = 1) -> None:\n\
    \        \"\"\"Remove a number of characters from the end of the text.\"\"\"\n\
    \        max_offset = len(self.plain) - amount\n        _Span = Span\n       \
    \ self._spans[:] = [\n            (\n                span\n                if\
    \ span.end < max_offset\n                else _Span(span.start, min(max_offset,\
    \ span.end), span.style)\n            )\n            for span in self._spans\n\
    \            if span.start < max_offset\n        ]\n        self._text = [self.plain[:-amount]]\n\
    \        self._length -= amount\n\n    def wrap(\n        self,\n        console:\
    \ \"Console\",\n        width: int,\n        *,\n        justify: Optional[\"\
    JustifyMethod\"] = None,\n        overflow: Optional[\"OverflowMethod\"] = None,\n\
    \        tab_size: int = 8,\n        no_wrap: Optional[bool] = None,\n    ) ->\
    \ Lines:\n        \"\"\"Word wrap the text.\n\n        Args:\n            console\
    \ (Console): Console instance.\n            width (int): Number of cells available\
    \ per line.\n            justify (str, optional): Justify method: \"default\"\
    , \"left\", \"center\", \"full\", \"right\". Defaults to \"default\".\n      \
    \      overflow (str, optional): Overflow method: \"crop\", \"fold\", or \"ellipsis\"\
    . Defaults to None.\n            tab_size (int, optional): Default tab size. Defaults\
    \ to 8.\n            no_wrap (bool, optional): Disable wrapping, Defaults to False.\n\
    \n        Returns:\n            Lines: Number of lines.\n        \"\"\"\n    \
    \    wrap_justify = justify or self.justify or DEFAULT_JUSTIFY\n        wrap_overflow\
    \ = overflow or self.overflow or DEFAULT_OVERFLOW\n\n        no_wrap = pick_bool(no_wrap,\
    \ self.no_wrap, False) or overflow == \"ignore\"\n\n        lines = Lines()\n\
    \        for line in self.split(allow_blank=True):\n            if \"\\t\" in\
    \ line:\n                line.expand_tabs(tab_size)\n            if no_wrap:\n\
    \                new_lines = Lines([line])\n            else:\n              \
    \  offsets = divide_line(str(line), width, fold=wrap_overflow == \"fold\")\n \
    \               new_lines = line.divide(offsets)\n            for line in new_lines:\n\
    \                line.rstrip_end(width)\n            if wrap_justify:\n      \
    \          new_lines.justify(\n                    console, width, justify=wrap_justify,\
    \ overflow=wrap_overflow\n                )\n            for line in new_lines:\n\
    \                line.truncate(width, overflow=wrap_overflow)\n            lines.extend(new_lines)\n\
    \        return lines\n\n    def fit(self, width: int) -> Lines:\n        \"\"\
    \"Fit the text in to given width by chopping in to lines.\n\n        Args:\n \
    \           width (int): Maximum characters in a line.\n\n        Returns:\n \
    \           Lines: Lines container.\n        \"\"\"\n        lines: Lines = Lines()\n\
    \        append = lines.append\n        for line in self.split():\n          \
    \  line.set_length(width)\n            append(line)\n        return lines\n\n\
    \    def detect_indentation(self) -> int:\n        \"\"\"Auto-detect indentation\
    \ of code.\n\n        Returns:\n            int: Number of spaces used to indent\
    \ code.\n        \"\"\"\n\n        _indentations = {\n            len(match.group(1))\n\
    \            for match in re.finditer(r\"^( *)(.*)$\", self.plain, flags=re.MULTILINE)\n\
    \        }\n\n        try:\n            indentation = (\n                reduce(gcd,\
    \ [indent for indent in _indentations if not indent % 2]) or 1\n            )\n\
    \        except TypeError:\n            indentation = 1\n\n        return indentation\n\
    \n    def with_indent_guides(\n        self,\n        indent_size: Optional[int]\
    \ = None,\n        *,\n        character: str = \"\",\n        style: StyleType\
    \ = \"dim green\",\n    ) -> \"Text\":\n        \"\"\"Adds indent guide lines\
    \ to text.\n\n        Args:\n            indent_size (Optional[int]): Size of\
    \ indentation, or None to auto detect. Defaults to None.\n            character\
    \ (str, optional): Character to use for indentation. Defaults to \"\".\n    \
    \        style (Union[Style, str], optional): Style of indent guides.\n\n    \
    \    Returns:\n            Text: New text with indentation guides.\n        \"\
    \"\"\n\n        _indent_size = self.detect_indentation() if indent_size is None\
    \ else indent_size\n\n        text = self.copy()\n        text.expand_tabs()\n\
    \        indent_line = f\"{character}{' ' * (_indent_size - 1)}\"\n\n        re_indent\
    \ = re.compile(r\"^( *)(.*)$\")\n        new_lines: List[Text] = []\n        add_line\
    \ = new_lines.append\n        blank_lines = 0\n        for line in text.split(allow_blank=True):\n\
    \            match = re_indent.match(line.plain)\n            if not match or\
    \ not match.group(2):\n                blank_lines += 1\n                continue\n\
    \            indent = match.group(1)\n            full_indents, remaining_space\
    \ = divmod(len(indent), _indent_size)\n            new_indent = f\"{indent_line\
    \ * full_indents}{' ' * remaining_space}\"\n            line.plain = new_indent\
    \ + line.plain[len(new_indent) :]\n            line.stylize(style, 0, len(new_indent))\n\
    \            if blank_lines:\n                new_lines.extend([Text(new_indent,\
    \ style=style)] * blank_lines)\n                blank_lines = 0\n            add_line(line)\n\
    \        if blank_lines:\n            new_lines.extend([Text(\"\", style=style)]\
    \ * blank_lines)\n\n        new_text = text.blank_copy(\"\\n\").join(new_lines)\n\
    \        return new_text\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n\
    \    from rich.console import Console\n\n    text = Text(\n        \"\"\"\\nLorem\
    \ ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt\
    \ ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation\
    \ ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor\
    \ in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.\
    \ Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\
    \ mollit anim id est laborum.\\n\"\"\"\n    )\n    text.highlight_words([\"Lorem\"\
    ], \"bold\")\n    text.highlight_words([\"ipsum\"], \"italic\")\n\n    console\
    \ = Console()\n\n    console.rule(\"justify='left'\")\n    console.print(text,\
    \ style=\"red\")\n    console.print()\n\n    console.rule(\"justify='center'\"\
    )\n    console.print(text, style=\"green\", justify=\"center\")\n    console.print()\n\
    \n    console.rule(\"justify='right'\")\n    console.print(text, style=\"blue\"\
    , justify=\"right\")\n    console.print()\n\n    console.rule(\"justify='full'\"\
    )\n    console.print(text, style=\"magenta\", justify=\"full\")\n    console.print()\n\
    \n\n### Dependency File: _emoji_replace.py\nfrom typing import Callable, Match,\
    \ Optional\nimport re\n\nfrom ._emoji_codes import EMOJI\n\n\n_ReStringMatch =\
    \ Match[str]  # regex match object\n_ReSubCallable = Callable[[_ReStringMatch],\
    \ str]  # Callable invoked by re.sub\n_EmojiSubMethod = Callable[[_ReSubCallable,\
    \ str], str]  # Sub method of a compiled re\n\n\ndef _emoji_replace(\n    text:\
    \ str,\n    default_variant: Optional[str] = None,\n    _emoji_sub: _EmojiSubMethod\
    \ = re.compile(r\"(:(\\S*?)(?:(?:\\-)(emoji|text))?:)\").sub,\n) -> str:\n   \
    \ \"\"\"Replace emoji code in text.\"\"\"\n    get_emoji = EMOJI.__getitem__\n\
    \    variants = {\"text\": \"\\uFE0E\", \"emoji\": \"\\uFE0F\"}\n    get_variant\
    \ = variants.get\n    default_variant_code = variants.get(default_variant, \"\"\
    ) if default_variant else \"\"\n\n    def do_replace(match: Match[str]) -> str:\n\
    \        emoji_code, emoji_name, variant = match.groups()\n        try:\n    \
    \        return get_emoji(emoji_name.lower()) + get_variant(\n               \
    \ variant, default_variant_code\n            )\n        except KeyError:\n   \
    \         return emoji_code\n\n    return _emoji_sub(do_replace, text)\n\nOutput\
    \ the complete test file, code only, no explanations.\n### Time\nCurrent time:\
    \ 2025-03-17 01:50:32\n"
  role: user
