messages:
- content: You are an AI agent expert in writing unit tests. Your task is to write
    unit tests for the given code files of the repository. Make sure the tests can
    be executed without lint or compile errors.
  role: system
- content: "### Task Information\nBased on the source code, write/rewrite tests to\
    \ cover the source code.\nRepository: rich\nTest File Path: rich\\test_style\\\
    test_style.py\nProject Programming Language: Python\nTesting Framework: pytest\n\
    ### Source File Content\n### Source File Content:\nimport sys\nfrom functools\
    \ import lru_cache\nfrom marshal import dumps, loads\nfrom random import randint\n\
    from typing import Any, Dict, Iterable, List, Optional, Type, Union, cast\n\n\
    from . import errors\nfrom .color import Color, ColorParseError, ColorSystem,\
    \ blend_rgb\nfrom .repr import Result, rich_repr\nfrom .terminal_theme import\
    \ DEFAULT_TERMINAL_THEME, TerminalTheme\n\n# Style instances and style definitions\
    \ are often interchangeable\nStyleType = Union[str, \"Style\"]\n\n\nclass _Bit:\n\
    \    \"\"\"A descriptor to get/set a style attribute bit.\"\"\"\n\n    __slots__\
    \ = [\"bit\"]\n\n    def __init__(self, bit_no: int) -> None:\n        self.bit\
    \ = 1 << bit_no\n\n    def __get__(self, obj: \"Style\", objtype: Type[\"Style\"\
    ]) -> Optional[bool]:\n        if obj._set_attributes & self.bit:\n          \
    \  return obj._attributes & self.bit != 0\n        return None\n\n\n@rich_repr\n\
    class Style:\n    \"\"\"A terminal style.\n\n    A terminal style consists of\
    \ a color (`color`), a background color (`bgcolor`), and a number of attributes,\
    \ such\n    as bold, italic etc. The attributes have 3 states: they can either\
    \ be on\n    (``True``), off (``False``), or not set (``None``).\n\n    Args:\n\
    \        color (Union[Color, str], optional): Color of terminal text. Defaults\
    \ to None.\n        bgcolor (Union[Color, str], optional): Color of terminal background.\
    \ Defaults to None.\n        bold (bool, optional): Enable bold text. Defaults\
    \ to None.\n        dim (bool, optional): Enable dim text. Defaults to None.\n\
    \        italic (bool, optional): Enable italic text. Defaults to None.\n    \
    \    underline (bool, optional): Enable underlined text. Defaults to None.\n \
    \       blink (bool, optional): Enabled blinking text. Defaults to None.\n   \
    \     blink2 (bool, optional): Enable fast blinking text. Defaults to None.\n\
    \        reverse (bool, optional): Enabled reverse text. Defaults to None.\n \
    \       conceal (bool, optional): Enable concealed text. Defaults to None.\n \
    \       strike (bool, optional): Enable strikethrough text. Defaults to None.\n\
    \        underline2 (bool, optional): Enable doubly underlined text. Defaults\
    \ to None.\n        frame (bool, optional): Enable framed text. Defaults to None.\n\
    \        encircle (bool, optional): Enable encircled text. Defaults to None.\n\
    \        overline (bool, optional): Enable overlined text. Defaults to None.\n\
    \        link (str, link): Link URL. Defaults to None.\n\n    \"\"\"\n\n    _color:\
    \ Optional[Color]\n    _bgcolor: Optional[Color]\n    _attributes: int\n    _set_attributes:\
    \ int\n    _hash: Optional[int]\n    _null: bool\n    _meta: Optional[bytes]\n\
    \n    __slots__ = [\n        \"_color\",\n        \"_bgcolor\",\n        \"_attributes\"\
    ,\n        \"_set_attributes\",\n        \"_link\",\n        \"_link_id\",\n \
    \       \"_ansi\",\n        \"_style_definition\",\n        \"_hash\",\n     \
    \   \"_null\",\n        \"_meta\",\n    ]\n\n    # maps bits on to SGR parameter\n\
    \    _style_map = {\n        0: \"1\",\n        1: \"2\",\n        2: \"3\",\n\
    \        3: \"4\",\n        4: \"5\",\n        5: \"6\",\n        6: \"7\",\n\
    \        7: \"8\",\n        8: \"9\",\n        9: \"21\",\n        10: \"51\"\
    ,\n        11: \"52\",\n        12: \"53\",\n    }\n\n    STYLE_ATTRIBUTES = {\n\
    \        \"dim\": \"dim\",\n        \"d\": \"dim\",\n        \"bold\": \"bold\"\
    ,\n        \"b\": \"bold\",\n        \"italic\": \"italic\",\n        \"i\": \"\
    italic\",\n        \"underline\": \"underline\",\n        \"u\": \"underline\"\
    ,\n        \"blink\": \"blink\",\n        \"blink2\": \"blink2\",\n        \"\
    reverse\": \"reverse\",\n        \"r\": \"reverse\",\n        \"conceal\": \"\
    conceal\",\n        \"c\": \"conceal\",\n        \"strike\": \"strike\",\n   \
    \     \"s\": \"strike\",\n        \"underline2\": \"underline2\",\n        \"\
    uu\": \"underline2\",\n        \"frame\": \"frame\",\n        \"encircle\": \"\
    encircle\",\n        \"overline\": \"overline\",\n        \"o\": \"overline\"\
    ,\n    }\n\n    def __init__(\n        self,\n        *,\n        color: Optional[Union[Color,\
    \ str]] = None,\n        bgcolor: Optional[Union[Color, str]] = None,\n      \
    \  bold: Optional[bool] = None,\n        dim: Optional[bool] = None,\n       \
    \ italic: Optional[bool] = None,\n        underline: Optional[bool] = None,\n\
    \        blink: Optional[bool] = None,\n        blink2: Optional[bool] = None,\n\
    \        reverse: Optional[bool] = None,\n        conceal: Optional[bool] = None,\n\
    \        strike: Optional[bool] = None,\n        underline2: Optional[bool] =\
    \ None,\n        frame: Optional[bool] = None,\n        encircle: Optional[bool]\
    \ = None,\n        overline: Optional[bool] = None,\n        link: Optional[str]\
    \ = None,\n        meta: Optional[Dict[str, Any]] = None,\n    ):\n        self._ansi:\
    \ Optional[str] = None\n        self._style_definition: Optional[str] = None\n\
    \n        def _make_color(color: Union[Color, str]) -> Color:\n            return\
    \ color if isinstance(color, Color) else Color.parse(color)\n\n        self._color\
    \ = None if color is None else _make_color(color)\n        self._bgcolor = None\
    \ if bgcolor is None else _make_color(bgcolor)\n        self._set_attributes =\
    \ sum(\n            (\n                bold is not None,\n                dim\
    \ is not None and 2,\n                italic is not None and 4,\n            \
    \    underline is not None and 8,\n                blink is not None and 16,\n\
    \                blink2 is not None and 32,\n                reverse is not None\
    \ and 64,\n                conceal is not None and 128,\n                strike\
    \ is not None and 256,\n                underline2 is not None and 512,\n    \
    \            frame is not None and 1024,\n                encircle is not None\
    \ and 2048,\n                overline is not None and 4096,\n            )\n \
    \       )\n        self._attributes = (\n            sum(\n                (\n\
    \                    bold and 1 or 0,\n                    dim and 2 or 0,\n \
    \                   italic and 4 or 0,\n                    underline and 8 or\
    \ 0,\n                    blink and 16 or 0,\n                    blink2 and 32\
    \ or 0,\n                    reverse and 64 or 0,\n                    conceal\
    \ and 128 or 0,\n                    strike and 256 or 0,\n                  \
    \  underline2 and 512 or 0,\n                    frame and 1024 or 0,\n      \
    \              encircle and 2048 or 0,\n                    overline and 4096\
    \ or 0,\n                )\n            )\n            if self._set_attributes\n\
    \            else 0\n        )\n\n        self._link = link\n        self._meta\
    \ = None if meta is None else dumps(meta)\n        self._link_id = (\n       \
    \     f\"{randint(0, 999999)}{hash(self._meta)}\" if (link or meta) else \"\"\n\
    \        )\n        self._hash: Optional[int] = None\n        self._null = not\
    \ (self._set_attributes or color or bgcolor or link or meta)\n\n    @classmethod\n\
    \    def null(cls) -> \"Style\":\n        \"\"\"Create an 'null' style, equivalent\
    \ to Style(), but more performant.\"\"\"\n        return NULL_STYLE\n\n    @classmethod\n\
    \    def from_color(\n        cls, color: Optional[Color] = None, bgcolor: Optional[Color]\
    \ = None\n    ) -> \"Style\":\n        \"\"\"Create a new style with colors and\
    \ no attributes.\n\n        Returns:\n            color (Optional[Color]): A (foreground)\
    \ color, or None for no color. Defaults to None.\n            bgcolor (Optional[Color]):\
    \ A (background) color, or None for no color. Defaults to None.\n        \"\"\"\
    \n        style: Style = cls.__new__(Style)\n        style._ansi = None\n    \
    \    style._style_definition = None\n        style._color = color\n        style._bgcolor\
    \ = bgcolor\n        style._set_attributes = 0\n        style._attributes = 0\n\
    \        style._link = None\n        style._link_id = \"\"\n        style._meta\
    \ = None\n        style._null = not (color or bgcolor)\n        style._hash =\
    \ None\n        return style\n\n    @classmethod\n    def from_meta(cls, meta:\
    \ Optional[Dict[str, Any]]) -> \"Style\":\n        \"\"\"Create a new style with\
    \ meta data.\n\n        Returns:\n            meta (Optional[Dict[str, Any]]):\
    \ A dictionary of meta data. Defaults to None.\n        \"\"\"\n        style:\
    \ Style = cls.__new__(Style)\n        style._ansi = None\n        style._style_definition\
    \ = None\n        style._color = None\n        style._bgcolor = None\n       \
    \ style._set_attributes = 0\n        style._attributes = 0\n        style._link\
    \ = None\n        style._meta = dumps(meta)\n        style._link_id = f\"{randint(0,\
    \ 999999)}{hash(style._meta)}\"\n        style._hash = None\n        style._null\
    \ = not (meta)\n        return style\n\n    @classmethod\n    def on(cls, meta:\
    \ Optional[Dict[str, Any]] = None, **handlers: Any) -> \"Style\":\n        \"\"\
    \"Create a blank style with meta information.\n\n        Example:\n          \
    \  style = Style.on(click=self.on_click)\n\n        Args:\n            meta (Optional[Dict[str,\
    \ Any]], optional): An optional dict of meta information.\n            **handlers\
    \ (Any): Keyword arguments are translated in to handlers.\n\n        Returns:\n\
    \            Style: A Style with meta information attached.\n        \"\"\"\n\
    \        meta = {} if meta is None else meta\n        meta.update({f\"@{key}\"\
    : value for key, value in handlers.items()})\n        return cls.from_meta(meta)\n\
    \n    bold = _Bit(0)\n    dim = _Bit(1)\n    italic = _Bit(2)\n    underline =\
    \ _Bit(3)\n    blink = _Bit(4)\n    blink2 = _Bit(5)\n    reverse = _Bit(6)\n\
    \    conceal = _Bit(7)\n    strike = _Bit(8)\n    underline2 = _Bit(9)\n    frame\
    \ = _Bit(10)\n    encircle = _Bit(11)\n    overline = _Bit(12)\n\n    @property\n\
    \    def link_id(self) -> str:\n        \"\"\"Get a link id, used in ansi code\
    \ for links.\"\"\"\n        return self._link_id\n\n    def __str__(self) -> str:\n\
    \        \"\"\"Re-generate style definition from attributes.\"\"\"\n        if\
    \ self._style_definition is None:\n            attributes: List[str] = []\n  \
    \          append = attributes.append\n            bits = self._set_attributes\n\
    \            if bits & 0b0000000001111:\n                if bits & 1:\n      \
    \              append(\"bold\" if self.bold else \"not bold\")\n             \
    \   if bits & (1 << 1):\n                    append(\"dim\" if self.dim else \"\
    not dim\")\n                if bits & (1 << 2):\n                    append(\"\
    italic\" if self.italic else \"not italic\")\n                if bits & (1 <<\
    \ 3):\n                    append(\"underline\" if self.underline else \"not underline\"\
    )\n            if bits & 0b0000111110000:\n                if bits & (1 << 4):\n\
    \                    append(\"blink\" if self.blink else \"not blink\")\n    \
    \            if bits & (1 << 5):\n                    append(\"blink2\" if self.blink2\
    \ else \"not blink2\")\n                if bits & (1 << 6):\n                \
    \    append(\"reverse\" if self.reverse else \"not reverse\")\n              \
    \  if bits & (1 << 7):\n                    append(\"conceal\" if self.conceal\
    \ else \"not conceal\")\n                if bits & (1 << 8):\n               \
    \     append(\"strike\" if self.strike else \"not strike\")\n            if bits\
    \ & 0b1111000000000:\n                if bits & (1 << 9):\n                  \
    \  append(\"underline2\" if self.underline2 else \"not underline2\")\n       \
    \         if bits & (1 << 10):\n                    append(\"frame\" if self.frame\
    \ else \"not frame\")\n                if bits & (1 << 11):\n                \
    \    append(\"encircle\" if self.encircle else \"not encircle\")\n           \
    \     if bits & (1 << 12):\n                    append(\"overline\" if self.overline\
    \ else \"not overline\")\n            if self._color is not None:\n          \
    \      append(self._color.name)\n            if self._bgcolor is not None:\n \
    \               append(\"on\")\n                append(self._bgcolor.name)\n \
    \           if self._link:\n                append(\"link\")\n               \
    \ append(self._link)\n            self._style_definition = \" \".join(attributes)\
    \ or \"none\"\n        return self._style_definition\n\n    def __bool__(self)\
    \ -> bool:\n        \"\"\"A Style is false if it has no attributes, colors, or\
    \ links.\"\"\"\n        return not self._null\n\n    def _make_ansi_codes(self,\
    \ color_system: ColorSystem) -> str:\n        \"\"\"Generate ANSI codes for this\
    \ style.\n\n        Args:\n            color_system (ColorSystem): Color system.\n\
    \n        Returns:\n            str: String containing codes.\n        \"\"\"\n\
    \n        if self._ansi is None:\n            sgr: List[str] = []\n          \
    \  append = sgr.append\n            _style_map = self._style_map\n           \
    \ attributes = self._attributes & self._set_attributes\n            if attributes:\n\
    \                if attributes & 1:\n                    append(_style_map[0])\n\
    \                if attributes & 2:\n                    append(_style_map[1])\n\
    \                if attributes & 4:\n                    append(_style_map[2])\n\
    \                if attributes & 8:\n                    append(_style_map[3])\n\
    \                if attributes & 0b0000111110000:\n                    for bit\
    \ in range(4, 9):\n                        if attributes & (1 << bit):\n     \
    \                       append(_style_map[bit])\n                if attributes\
    \ & 0b1111000000000:\n                    for bit in range(9, 13):\n         \
    \               if attributes & (1 << bit):\n                            append(_style_map[bit])\n\
    \            if self._color is not None:\n                sgr.extend(self._color.downgrade(color_system).get_ansi_codes())\n\
    \            if self._bgcolor is not None:\n                sgr.extend(\n    \
    \                self._bgcolor.downgrade(color_system).get_ansi_codes(\n     \
    \                   foreground=False\n                    )\n                )\n\
    \            self._ansi = \";\".join(sgr)\n        return self._ansi\n\n    @classmethod\n\
    \    @lru_cache(maxsize=1024)\n    def normalize(cls, style: str) -> str:\n  \
    \      \"\"\"Normalize a style definition so that styles with the same effect\
    \ have the same string\n        representation.\n\n        Args:\n           \
    \ style (str): A style definition.\n\n        Returns:\n            str: Normal\
    \ form of style definition.\n        \"\"\"\n        try:\n            return\
    \ str(cls.parse(style))\n        except errors.StyleSyntaxError:\n           \
    \ return style.strip().lower()\n\n    @classmethod\n    def pick_first(cls, *values:\
    \ Optional[StyleType]) -> StyleType:\n        \"\"\"Pick first non-None style.\"\
    \"\"\n        for value in values:\n            if value is not None:\n      \
    \          return value\n        raise ValueError(\"expected at least one non-None\
    \ style\")\n\n    def __rich_repr__(self) -> Result:\n        yield \"color\"\
    , self.color, None\n        yield \"bgcolor\", self.bgcolor, None\n        yield\
    \ \"bold\", self.bold, None,\n        yield \"dim\", self.dim, None,\n       \
    \ yield \"italic\", self.italic, None\n        yield \"underline\", self.underline,\
    \ None,\n        yield \"blink\", self.blink, None\n        yield \"blink2\",\
    \ self.blink2, None\n        yield \"reverse\", self.reverse, None\n        yield\
    \ \"conceal\", self.conceal, None\n        yield \"strike\", self.strike, None\n\
    \        yield \"underline2\", self.underline2, None\n        yield \"frame\"\
    , self.frame, None\n        yield \"encircle\", self.encircle, None\n        yield\
    \ \"link\", self.link, None\n        if self._meta:\n            yield \"meta\"\
    , self.meta\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other,\
    \ Style):\n            return NotImplemented\n        return self.__hash__() ==\
    \ other.__hash__()\n\n    def __ne__(self, other: Any) -> bool:\n        if not\
    \ isinstance(other, Style):\n            return NotImplemented\n        return\
    \ self.__hash__() != other.__hash__()\n\n    def __hash__(self) -> int:\n    \
    \    if self._hash is not None:\n            return self._hash\n        self._hash\
    \ = hash(\n            (\n                self._color,\n                self._bgcolor,\n\
    \                self._attributes,\n                self._set_attributes,\n  \
    \              self._link,\n                self._meta,\n            )\n     \
    \   )\n        return self._hash\n\n    @property\n    def color(self) -> Optional[Color]:\n\
    \        \"\"\"The foreground color or None if it is not set.\"\"\"\n        return\
    \ self._color\n\n    @property\n    def bgcolor(self) -> Optional[Color]:\n  \
    \      \"\"\"The background color or None if it is not set.\"\"\"\n        return\
    \ self._bgcolor\n\n    @property\n    def link(self) -> Optional[str]:\n     \
    \   \"\"\"Link text, if set.\"\"\"\n        return self._link\n\n    @property\n\
    \    def transparent_background(self) -> bool:\n        \"\"\"Check if the style\
    \ specified a transparent background.\"\"\"\n        return self.bgcolor is None\
    \ or self.bgcolor.is_default\n\n    @property\n    def background_style(self)\
    \ -> \"Style\":\n        \"\"\"A Style with background only.\"\"\"\n        return\
    \ Style(bgcolor=self.bgcolor)\n\n    @property\n    def meta(self) -> Dict[str,\
    \ Any]:\n        \"\"\"Get meta information (can not be changed after construction).\"\
    \"\"\n        return {} if self._meta is None else cast(Dict[str, Any], loads(self._meta))\n\
    \n    @property\n    def without_color(self) -> \"Style\":\n        \"\"\"Get\
    \ a copy of the style with color removed.\"\"\"\n        if self._null:\n    \
    \        return NULL_STYLE\n        style: Style = self.__new__(Style)\n     \
    \   style._ansi = None\n        style._style_definition = None\n        style._color\
    \ = None\n        style._bgcolor = None\n        style._attributes = self._attributes\n\
    \        style._set_attributes = self._set_attributes\n        style._link = self._link\n\
    \        style._link_id = f\"{randint(0, 999999)}\" if self._link else \"\"\n\
    \        style._null = False\n        style._meta = None\n        style._hash\
    \ = None\n        return style\n\n    @classmethod\n    @lru_cache(maxsize=4096)\n\
    \    def parse(cls, style_definition: str) -> \"Style\":\n        \"\"\"Parse\
    \ a style definition.\n\n        Args:\n            style_definition (str): A\
    \ string containing a style.\n\n        Raises:\n            errors.StyleSyntaxError:\
    \ If the style definition syntax is invalid.\n\n        Returns:\n           \
    \ `Style`: A Style instance.\n        \"\"\"\n        if style_definition.strip()\
    \ == \"none\" or not style_definition:\n            return cls.null()\n\n    \
    \    STYLE_ATTRIBUTES = cls.STYLE_ATTRIBUTES\n        color: Optional[str] = None\n\
    \        bgcolor: Optional[str] = None\n        attributes: Dict[str, Optional[Any]]\
    \ = {}\n        link: Optional[str] = None\n\n        words = iter(style_definition.split())\n\
    \        for original_word in words:\n            word = original_word.lower()\n\
    \            if word == \"on\":\n                word = next(words, \"\")\n  \
    \              if not word:\n                    raise errors.StyleSyntaxError(\"\
    color expected after 'on'\")\n                try:\n                    Color.parse(word)\
    \ is None\n                except ColorParseError as error:\n                \
    \    raise errors.StyleSyntaxError(\n                        f\"unable to parse\
    \ {word!r} as background color; {error}\"\n                    ) from None\n \
    \               bgcolor = word\n\n            elif word == \"not\":\n        \
    \        word = next(words, \"\")\n                attribute = STYLE_ATTRIBUTES.get(word)\n\
    \                if attribute is None:\n                    raise errors.StyleSyntaxError(\n\
    \                        f\"expected style attribute after 'not', found {word!r}\"\
    \n                    )\n                attributes[attribute] = False\n\n   \
    \         elif word == \"link\":\n                word = next(words, \"\")\n \
    \               if not word:\n                    raise errors.StyleSyntaxError(\"\
    URL expected after 'link'\")\n                link = word\n\n            elif\
    \ word in STYLE_ATTRIBUTES:\n                attributes[STYLE_ATTRIBUTES[word]]\
    \ = True\n\n            else:\n                try:\n                    Color.parse(word)\n\
    \                except ColorParseError as error:\n                    raise errors.StyleSyntaxError(\n\
    \                        f\"unable to parse {word!r} as color; {error}\"\n   \
    \                 ) from None\n                color = word\n        style = Style(color=color,\
    \ bgcolor=bgcolor, link=link, **attributes)\n        return style\n\n    @lru_cache(maxsize=1024)\n\
    \    def get_html_style(self, theme: Optional[TerminalTheme] = None) -> str:\n\
    \        \"\"\"Get a CSS style rule.\"\"\"\n        theme = theme or DEFAULT_TERMINAL_THEME\n\
    \        css: List[str] = []\n        append = css.append\n\n        color = self.color\n\
    \        bgcolor = self.bgcolor\n        if self.reverse:\n            color,\
    \ bgcolor = bgcolor, color\n        if self.dim:\n            foreground_color\
    \ = (\n                theme.foreground_color if color is None else color.get_truecolor(theme)\n\
    \            )\n            color = Color.from_triplet(\n                blend_rgb(foreground_color,\
    \ theme.background_color, 0.5)\n            )\n        if color is not None:\n\
    \            theme_color = color.get_truecolor(theme)\n            append(f\"\
    color: {theme_color.hex}\")\n            append(f\"text-decoration-color: {theme_color.hex}\"\
    )\n        if bgcolor is not None:\n            theme_color = bgcolor.get_truecolor(theme,\
    \ foreground=False)\n            append(f\"background-color: {theme_color.hex}\"\
    )\n        if self.bold:\n            append(\"font-weight: bold\")\n        if\
    \ self.italic:\n            append(\"font-style: italic\")\n        if self.underline:\n\
    \            append(\"text-decoration: underline\")\n        if self.strike:\n\
    \            append(\"text-decoration: line-through\")\n        if self.overline:\n\
    \            append(\"text-decoration: overline\")\n        return \"; \".join(css)\n\
    \n    @classmethod\n    def combine(cls, styles: Iterable[\"Style\"]) -> \"Style\"\
    :\n        \"\"\"Combine styles and get result.\n\n        Args:\n           \
    \ styles (Iterable[Style]): Styles to combine.\n\n        Returns:\n         \
    \   Style: A new style instance.\n        \"\"\"\n        iter_styles = iter(styles)\n\
    \        return sum(iter_styles, next(iter_styles))\n\n    @classmethod\n    def\
    \ chain(cls, *styles: \"Style\") -> \"Style\":\n        \"\"\"Combine styles from\
    \ positional argument in to a single style.\n\n        Args:\n            *styles\
    \ (Iterable[Style]): Styles to combine.\n\n        Returns:\n            Style:\
    \ A new style instance.\n        \"\"\"\n        iter_styles = iter(styles)\n\
    \        return sum(iter_styles, next(iter_styles))\n\n    def copy(self) -> \"\
    Style\":\n        \"\"\"Get a copy of this style.\n\n        Returns:\n      \
    \      Style: A new Style instance with identical attributes.\n        \"\"\"\n\
    \        if self._null:\n            return NULL_STYLE\n        style: Style =\
    \ self.__new__(Style)\n        style._ansi = self._ansi\n        style._style_definition\
    \ = self._style_definition\n        style._color = self._color\n        style._bgcolor\
    \ = self._bgcolor\n        style._attributes = self._attributes\n        style._set_attributes\
    \ = self._set_attributes\n        style._link = self._link\n        style._link_id\
    \ = f\"{randint(0, 999999)}\" if self._link else \"\"\n        style._hash = self._hash\n\
    \        style._null = False\n        style._meta = self._meta\n        return\
    \ style\n\n    @lru_cache(maxsize=128)\n    def clear_meta_and_links(self) ->\
    \ \"Style\":\n        \"\"\"Get a copy of this style with link and meta information\
    \ removed.\n\n        Returns:\n            Style: New style object.\n       \
    \ \"\"\"\n        if self._null:\n            return NULL_STYLE\n        style:\
    \ Style = self.__new__(Style)\n        style._ansi = self._ansi\n        style._style_definition\
    \ = self._style_definition\n        style._color = self._color\n        style._bgcolor\
    \ = self._bgcolor\n        style._attributes = self._attributes\n        style._set_attributes\
    \ = self._set_attributes\n        style._link = None\n        style._link_id =\
    \ \"\"\n        style._hash = None\n        style._null = False\n        style._meta\
    \ = None\n        return style\n\n    def update_link(self, link: Optional[str]\
    \ = None) -> \"Style\":\n        \"\"\"Get a copy with a different value for link.\n\
    \n        Args:\n            link (str, optional): New value for link. Defaults\
    \ to None.\n\n        Returns:\n            Style: A new Style instance.\n   \
    \     \"\"\"\n        style: Style = self.__new__(Style)\n        style._ansi\
    \ = self._ansi\n        style._style_definition = self._style_definition\n   \
    \     style._color = self._color\n        style._bgcolor = self._bgcolor\n   \
    \     style._attributes = self._attributes\n        style._set_attributes = self._set_attributes\n\
    \        style._link = link\n        style._link_id = f\"{randint(0, 999999)}\"\
    \ if link else \"\"\n        style._hash = None\n        style._null = False\n\
    \        style._meta = self._meta\n        return style\n\n    def render(\n \
    \       self,\n        text: str = \"\",\n        *,\n        color_system: Optional[ColorSystem]\
    \ = ColorSystem.TRUECOLOR,\n        legacy_windows: bool = False,\n    ) -> str:\n\
    \        \"\"\"Render the ANSI codes for the style.\n\n        Args:\n       \
    \     text (str, optional): A string to style. Defaults to \"\".\n           \
    \ color_system (Optional[ColorSystem], optional): Color system to render to. Defaults\
    \ to ColorSystem.TRUECOLOR.\n\n        Returns:\n            str: A string containing\
    \ ANSI style codes.\n        \"\"\"\n        if not text or color_system is None:\n\
    \            return text\n        attrs = self._ansi or self._make_ansi_codes(color_system)\n\
    \        rendered = f\"\\x1b[{attrs}m{text}\\x1b[0m\" if attrs else text\n   \
    \     if self._link and not legacy_windows:\n            rendered = (\n      \
    \          f\"\\x1b]8;id={self._link_id};{self._link}\\x1b\\\\{rendered}\\x1b]8;;\\\
    x1b\\\\\"\n            )\n        return rendered\n\n    def test(self, text:\
    \ Optional[str] = None) -> None:\n        \"\"\"Write text with style directly\
    \ to terminal.\n\n        This method is for testing purposes only.\n\n      \
    \  Args:\n            text (Optional[str], optional): Text to style or None for\
    \ style name.\n\n        \"\"\"\n        text = text or str(self)\n        sys.stdout.write(f\"\
    {self.render(text)}\\n\")\n\n    @lru_cache(maxsize=1024)\n    def _add(self,\
    \ style: Optional[\"Style\"]) -> \"Style\":\n        if style is None or style._null:\n\
    \            return self\n        if self._null:\n            return style\n \
    \       new_style: Style = self.__new__(Style)\n        new_style._ansi = None\n\
    \        new_style._style_definition = None\n        new_style._color = style._color\
    \ or self._color\n        new_style._bgcolor = style._bgcolor or self._bgcolor\n\
    \        new_style._attributes = (self._attributes & ~style._set_attributes) |\
    \ (\n            style._attributes & style._set_attributes\n        )\n      \
    \  new_style._set_attributes = self._set_attributes | style._set_attributes\n\
    \        new_style._link = style._link or self._link\n        new_style._link_id\
    \ = style._link_id or self._link_id\n        new_style._null = style._null\n \
    \       if self._meta and style._meta:\n            new_style._meta = dumps({**self.meta,\
    \ **style.meta})\n        else:\n            new_style._meta = self._meta or style._meta\n\
    \        new_style._hash = None\n        return new_style\n\n    def __add__(self,\
    \ style: Optional[\"Style\"]) -> \"Style\":\n        combined_style = self._add(style)\n\
    \        return combined_style.copy() if combined_style.link else combined_style\n\
    \n\nNULL_STYLE = Style()\n\n\nclass StyleStack:\n    \"\"\"A stack of styles.\"\
    \"\"\n\n    __slots__ = [\"_stack\"]\n\n    def __init__(self, default_style:\
    \ \"Style\") -> None:\n        self._stack: List[Style] = [default_style]\n\n\
    \    def __repr__(self) -> str:\n        return f\"<stylestack {self._stack!r}>\"\
    \n\n    @property\n    def current(self) -> Style:\n        \"\"\"Get the Style\
    \ at the top of the stack.\"\"\"\n        return self._stack[-1]\n\n    def push(self,\
    \ style: Style) -> None:\n        \"\"\"Push a new style on to the stack.\n\n\
    \        Args:\n            style (Style): New style to combine with current style.\n\
    \        \"\"\"\n        self._stack.append(self._stack[-1] + style)\n\n    def\
    \ pop(self) -> Style:\n        \"\"\"Pop last style and discard.\n\n        Returns:\n\
    \            Style: New current style (also available as stack.current)\n    \
    \    \"\"\"\n        self._stack.pop()\n        return self._stack[-1]\n\n###\
    \ Source File Dependency Files Content\n### Dependency File: color.py\nimport\
    \ re\nimport sys\nfrom colorsys import rgb_to_hls\nfrom enum import IntEnum\n\
    from functools import lru_cache\nfrom typing import TYPE_CHECKING, NamedTuple,\
    \ Optional, Tuple\n\nfrom ._palettes import EIGHT_BIT_PALETTE, STANDARD_PALETTE,\
    \ WINDOWS_PALETTE\nfrom .color_triplet import ColorTriplet\nfrom .repr import\
    \ Result, rich_repr\nfrom .terminal_theme import DEFAULT_TERMINAL_THEME\n\nif\
    \ TYPE_CHECKING:  # pragma: no cover\n    from .terminal_theme import TerminalTheme\n\
    \    from .text import Text\n\n\nWINDOWS = sys.platform == \"win32\"\n\n\nclass\
    \ ColorSystem(IntEnum):\n    \"\"\"One of the 3 color system supported by terminals.\"\
    \"\"\n\n    STANDARD = 1\n    EIGHT_BIT = 2\n    TRUECOLOR = 3\n    WINDOWS =\
    \ 4\n\n    def __repr__(self) -> str:\n        return f\"ColorSystem.{self.name}\"\
    \n\n    def __str__(self) -> str:\n        return repr(self)\n\n\nclass ColorType(IntEnum):\n\
    \    \"\"\"Type of color stored in Color class.\"\"\"\n\n    DEFAULT = 0\n   \
    \ STANDARD = 1\n    EIGHT_BIT = 2\n    TRUECOLOR = 3\n    WINDOWS = 4\n\n    def\
    \ __repr__(self) -> str:\n        return f\"ColorType.{self.name}\"\n\n\nANSI_COLOR_NAMES\
    \ = {\n    \"black\": 0,\n    \"red\": 1,\n    \"green\": 2,\n    \"yellow\":\
    \ 3,\n    \"blue\": 4,\n    \"magenta\": 5,\n    \"cyan\": 6,\n    \"white\":\
    \ 7,\n    \"bright_black\": 8,\n    \"bright_red\": 9,\n    \"bright_green\":\
    \ 10,\n    \"bright_yellow\": 11,\n    \"bright_blue\": 12,\n    \"bright_magenta\"\
    : 13,\n    \"bright_cyan\": 14,\n    \"bright_white\": 15,\n    \"grey0\": 16,\n\
    \    \"gray0\": 16,\n    \"navy_blue\": 17,\n    \"dark_blue\": 18,\n    \"blue3\"\
    : 20,\n    \"blue1\": 21,\n    \"dark_green\": 22,\n    \"deep_sky_blue4\": 25,\n\
    \    \"dodger_blue3\": 26,\n    \"dodger_blue2\": 27,\n    \"green4\": 28,\n \
    \   \"spring_green4\": 29,\n    \"turquoise4\": 30,\n    \"deep_sky_blue3\": 32,\n\
    \    \"dodger_blue1\": 33,\n    \"green3\": 40,\n    \"spring_green3\": 41,\n\
    \    \"dark_cyan\": 36,\n    \"light_sea_green\": 37,\n    \"deep_sky_blue2\"\
    : 38,\n    \"deep_sky_blue1\": 39,\n    \"spring_green2\": 47,\n    \"cyan3\"\
    : 43,\n    \"dark_turquoise\": 44,\n    \"turquoise2\": 45,\n    \"green1\": 46,\n\
    \    \"spring_green1\": 48,\n    \"medium_spring_green\": 49,\n    \"cyan2\":\
    \ 50,\n    \"cyan1\": 51,\n    \"dark_red\": 88,\n    \"deep_pink4\": 125,\n \
    \   \"purple4\": 55,\n    \"purple3\": 56,\n    \"blue_violet\": 57,\n    \"orange4\"\
    : 94,\n    \"grey37\": 59,\n    \"gray37\": 59,\n    \"medium_purple4\": 60,\n\
    \    \"slate_blue3\": 62,\n    \"royal_blue1\": 63,\n    \"chartreuse4\": 64,\n\
    \    \"dark_sea_green4\": 71,\n    \"pale_turquoise4\": 66,\n    \"steel_blue\"\
    : 67,\n    \"steel_blue3\": 68,\n    \"cornflower_blue\": 69,\n    \"chartreuse3\"\
    : 76,\n    \"cadet_blue\": 73,\n    \"sky_blue3\": 74,\n    \"steel_blue1\": 81,\n\
    \    \"pale_green3\": 114,\n    \"sea_green3\": 78,\n    \"aquamarine3\": 79,\n\
    \    \"medium_turquoise\": 80,\n    \"chartreuse2\": 112,\n    \"sea_green2\"\
    : 83,\n    \"sea_green1\": 85,\n    \"aquamarine1\": 122,\n    \"dark_slate_gray2\"\
    : 87,\n    \"dark_magenta\": 91,\n    \"dark_violet\": 128,\n    \"purple\": 129,\n\
    \    \"light_pink4\": 95,\n    \"plum4\": 96,\n    \"medium_purple3\": 98,\n \
    \   \"slate_blue1\": 99,\n    \"yellow4\": 106,\n    \"wheat4\": 101,\n    \"\
    grey53\": 102,\n    \"gray53\": 102,\n    \"light_slate_grey\": 103,\n    \"light_slate_gray\"\
    : 103,\n    \"medium_purple\": 104,\n    \"light_slate_blue\": 105,\n    \"dark_olive_green3\"\
    : 149,\n    \"dark_sea_green\": 108,\n    \"light_sky_blue3\": 110,\n    \"sky_blue2\"\
    : 111,\n    \"dark_sea_green3\": 150,\n    \"dark_slate_gray3\": 116,\n    \"\
    sky_blue1\": 117,\n    \"chartreuse1\": 118,\n    \"light_green\": 120,\n    \"\
    pale_green1\": 156,\n    \"dark_slate_gray1\": 123,\n    \"red3\": 160,\n    \"\
    medium_violet_red\": 126,\n    \"magenta3\": 164,\n    \"dark_orange3\": 166,\n\
    \    \"indian_red\": 167,\n    \"hot_pink3\": 168,\n    \"medium_orchid3\": 133,\n\
    \    \"medium_orchid\": 134,\n    \"medium_purple2\": 140,\n    \"dark_goldenrod\"\
    : 136,\n    \"light_salmon3\": 173,\n    \"rosy_brown\": 138,\n    \"grey63\"\
    : 139,\n    \"gray63\": 139,\n    \"medium_purple1\": 141,\n    \"gold3\": 178,\n\
    \    \"dark_khaki\": 143,\n    \"navajo_white3\": 144,\n    \"grey69\": 145,\n\
    \    \"gray69\": 145,\n    \"light_steel_blue3\": 146,\n    \"light_steel_blue\"\
    : 147,\n    \"yellow3\": 184,\n    \"dark_sea_green2\": 157,\n    \"light_cyan3\"\
    : 152,\n    \"light_sky_blue1\": 153,\n    \"green_yellow\": 154,\n    \"dark_olive_green2\"\
    : 155,\n    \"dark_sea_green1\": 193,\n    \"pale_turquoise1\": 159,\n    \"deep_pink3\"\
    : 162,\n    \"magenta2\": 200,\n    \"hot_pink2\": 169,\n    \"orchid\": 170,\n\
    \    \"medium_orchid1\": 207,\n    \"orange3\": 172,\n    \"light_pink3\": 174,\n\
    \    \"pink3\": 175,\n    \"plum3\": 176,\n    \"violet\": 177,\n    \"light_goldenrod3\"\
    : 179,\n    \"tan\": 180,\n    \"misty_rose3\": 181,\n    \"thistle3\": 182,\n\
    \    \"plum2\": 183,\n    \"khaki3\": 185,\n    \"light_goldenrod2\": 222,\n \
    \   \"light_yellow3\": 187,\n    \"grey84\": 188,\n    \"gray84\": 188,\n    \"\
    light_steel_blue1\": 189,\n    \"yellow2\": 190,\n    \"dark_olive_green1\": 192,\n\
    \    \"honeydew2\": 194,\n    \"light_cyan1\": 195,\n    \"red1\": 196,\n    \"\
    deep_pink2\": 197,\n    \"deep_pink1\": 199,\n    \"magenta1\": 201,\n    \"orange_red1\"\
    : 202,\n    \"indian_red1\": 204,\n    \"hot_pink\": 206,\n    \"dark_orange\"\
    : 208,\n    \"salmon1\": 209,\n    \"light_coral\": 210,\n    \"pale_violet_red1\"\
    : 211,\n    \"orchid2\": 212,\n    \"orchid1\": 213,\n    \"orange1\": 214,\n\
    \    \"sandy_brown\": 215,\n    \"light_salmon1\": 216,\n    \"light_pink1\":\
    \ 217,\n    \"pink1\": 218,\n    \"plum1\": 219,\n    \"gold1\": 220,\n    \"\
    navajo_white1\": 223,\n    \"misty_rose1\": 224,\n    \"thistle1\": 225,\n   \
    \ \"yellow1\": 226,\n    \"light_goldenrod1\": 227,\n    \"khaki1\": 228,\n  \
    \  \"wheat1\": 229,\n    \"cornsilk1\": 230,\n    \"grey100\": 231,\n    \"gray100\"\
    : 231,\n    \"grey3\": 232,\n    \"gray3\": 232,\n    \"grey7\": 233,\n    \"\
    gray7\": 233,\n    \"grey11\": 234,\n    \"gray11\": 234,\n    \"grey15\": 235,\n\
    \    \"gray15\": 235,\n    \"grey19\": 236,\n    \"gray19\": 236,\n    \"grey23\"\
    : 237,\n    \"gray23\": 237,\n    \"grey27\": 238,\n    \"gray27\": 238,\n   \
    \ \"grey30\": 239,\n    \"gray30\": 239,\n    \"grey35\": 240,\n    \"gray35\"\
    : 240,\n    \"grey39\": 241,\n    \"gray39\": 241,\n    \"grey42\": 242,\n   \
    \ \"gray42\": 242,\n    \"grey46\": 243,\n    \"gray46\": 243,\n    \"grey50\"\
    : 244,\n    \"gray50\": 244,\n    \"grey54\": 245,\n    \"gray54\": 245,\n   \
    \ \"grey58\": 246,\n    \"gray58\": 246,\n    \"grey62\": 247,\n    \"gray62\"\
    : 247,\n    \"grey66\": 248,\n    \"gray66\": 248,\n    \"grey70\": 249,\n   \
    \ \"gray70\": 249,\n    \"grey74\": 250,\n    \"gray74\": 250,\n    \"grey78\"\
    : 251,\n    \"gray78\": 251,\n    \"grey82\": 252,\n    \"gray82\": 252,\n   \
    \ \"grey85\": 253,\n    \"gray85\": 253,\n    \"grey89\": 254,\n    \"gray89\"\
    : 254,\n    \"grey93\": 255,\n    \"gray93\": 255,\n}\n\n\nclass ColorParseError(Exception):\n\
    \    \"\"\"The color could not be parsed.\"\"\"\n\n\nRE_COLOR = re.compile(\n\
    \    r\"\"\"^\n\\#([0-9a-f]{6})$|\ncolor\\(([0-9]{1,3})\\)$|\nrgb\\(([\\d\\s,]+)\\\
    )$\n\"\"\",\n    re.VERBOSE,\n)\n\n\n@rich_repr\nclass Color(NamedTuple):\n  \
    \  \"\"\"Terminal color definition.\"\"\"\n\n    name: str\n    \"\"\"The name\
    \ of the color (typically the input to Color.parse).\"\"\"\n    type: ColorType\n\
    \    \"\"\"The type of the color.\"\"\"\n    number: Optional[int] = None\n  \
    \  \"\"\"The color number, if a standard color, or None.\"\"\"\n    triplet: Optional[ColorTriplet]\
    \ = None\n    \"\"\"A triplet of color components, if an RGB color.\"\"\"\n\n\
    \    def __rich__(self) -> \"Text\":\n        \"\"\"Displays the actual color\
    \ if Rich printed.\"\"\"\n        from .style import Style\n        from .text\
    \ import Text\n\n        return Text.assemble(\n            f\"<color {self.name!r}\
    \ ({self.type.name.lower()})\",\n            (\"⬤\", Style(color=self)),\n   \
    \         \" >\",\n        )\n\n    def __rich_repr__(self) -> Result:\n     \
    \   yield self.name\n        yield self.type\n        yield \"number\", self.number,\
    \ None\n        yield \"triplet\", self.triplet, None\n\n    @property\n    def\
    \ system(self) -> ColorSystem:\n        \"\"\"Get the native color system for\
    \ this color.\"\"\"\n        if self.type == ColorType.DEFAULT:\n            return\
    \ ColorSystem.STANDARD\n        return ColorSystem(int(self.type))\n\n    @property\n\
    \    def is_system_defined(self) -> bool:\n        \"\"\"Check if the color is\
    \ ultimately defined by the system.\"\"\"\n        return self.system not in (ColorSystem.EIGHT_BIT,\
    \ ColorSystem.TRUECOLOR)\n\n    @property\n    def is_default(self) -> bool:\n\
    \        \"\"\"Check if the color is a default color.\"\"\"\n        return self.type\
    \ == ColorType.DEFAULT\n\n    def get_truecolor(\n        self, theme: Optional[\"\
    TerminalTheme\"] = None, foreground: bool = True\n    ) -> ColorTriplet:\n   \
    \     \"\"\"Get an equivalent color triplet for this color.\n\n        Args:\n\
    \            theme (TerminalTheme, optional): Optional terminal theme, or None\
    \ to use default. Defaults to None.\n            foreground (bool, optional):\
    \ True for a foreground color, or False for background. Defaults to True.\n\n\
    \        Returns:\n            ColorTriplet: A color triplet containing RGB components.\n\
    \        \"\"\"\n\n        if theme is None:\n            theme = DEFAULT_TERMINAL_THEME\n\
    \        if self.type == ColorType.TRUECOLOR:\n            assert self.triplet\
    \ is not None\n            return self.triplet\n        elif self.type == ColorType.EIGHT_BIT:\n\
    \            assert self.number is not None\n            return EIGHT_BIT_PALETTE[self.number]\n\
    \        elif self.type == ColorType.STANDARD:\n            assert self.number\
    \ is not None\n            return theme.ansi_colors[self.number]\n        elif\
    \ self.type == ColorType.WINDOWS:\n            assert self.number is not None\n\
    \            return WINDOWS_PALETTE[self.number]\n        else:  # self.type ==\
    \ ColorType.DEFAULT:\n            assert self.number is None\n            return\
    \ theme.foreground_color if foreground else theme.background_color\n\n    @classmethod\n\
    \    def from_ansi(cls, number: int) -> \"Color\":\n        \"\"\"Create a Color\
    \ number from it's 8-bit ansi number.\n\n        Args:\n            number (int):\
    \ A number between 0-255 inclusive.\n\n        Returns:\n            Color: A\
    \ new Color instance.\n        \"\"\"\n        return cls(\n            name=f\"\
    color({number})\",\n            type=(ColorType.STANDARD if number < 16 else ColorType.EIGHT_BIT),\n\
    \            number=number,\n        )\n\n    @classmethod\n    def from_triplet(cls,\
    \ triplet: \"ColorTriplet\") -> \"Color\":\n        \"\"\"Create a truecolor RGB\
    \ color from a triplet of values.\n\n        Args:\n            triplet (ColorTriplet):\
    \ A color triplet containing red, green and blue components.\n\n        Returns:\n\
    \            Color: A new color object.\n        \"\"\"\n        return cls(name=triplet.hex,\
    \ type=ColorType.TRUECOLOR, triplet=triplet)\n\n    @classmethod\n    def from_rgb(cls,\
    \ red: float, green: float, blue: float) -> \"Color\":\n        \"\"\"Create a\
    \ truecolor from three color components in the range(0->255).\n\n        Args:\n\
    \            red (float): Red component in range 0-255.\n            green (float):\
    \ Green component in range 0-255.\n            blue (float): Blue component in\
    \ range 0-255.\n\n        Returns:\n            Color: A new color object.\n \
    \       \"\"\"\n        return cls.from_triplet(ColorTriplet(int(red), int(green),\
    \ int(blue)))\n\n    @classmethod\n    def default(cls) -> \"Color\":\n      \
    \  \"\"\"Get a Color instance representing the default color.\n\n        Returns:\n\
    \            Color: Default color.\n        \"\"\"\n        return cls(name=\"\
    default\", type=ColorType.DEFAULT)\n\n    @classmethod\n    @lru_cache(maxsize=1024)\n\
    \    def parse(cls, color: str) -> \"Color\":\n        \"\"\"Parse a color definition.\"\
    \"\"\n        original_color = color\n        color = color.lower().strip()\n\n\
    \        if color == \"default\":\n            return cls(color, type=ColorType.DEFAULT)\n\
    \n        color_number = ANSI_COLOR_NAMES.get(color)\n        if color_number\
    \ is not None:\n            return cls(\n                color,\n            \
    \    type=(ColorType.STANDARD if color_number < 16 else ColorType.EIGHT_BIT),\n\
    \                number=color_number,\n            )\n\n        color_match =\
    \ RE_COLOR.match(color)\n        if color_match is None:\n            raise ColorParseError(f\"\
    {original_color!r} is not a valid color\")\n\n        color_24, color_8, color_rgb\
    \ = color_match.groups()\n        if color_24:\n            triplet = ColorTriplet(\n\
    \                int(color_24[0:2], 16), int(color_24[2:4], 16), int(color_24[4:6],\
    \ 16)\n            )\n            return cls(color, ColorType.TRUECOLOR, triplet=triplet)\n\
    \n        elif color_8:\n            number = int(color_8)\n            if number\
    \ > 255:\n                raise ColorParseError(f\"color number must be <= 255\
    \ in {color!r}\")\n            return cls(\n                color,\n         \
    \       type=(ColorType.STANDARD if number < 16 else ColorType.EIGHT_BIT),\n \
    \               number=number,\n            )\n\n        else:  #  color_rgb:\n\
    \            components = color_rgb.split(\",\")\n            if len(components)\
    \ != 3:\n                raise ColorParseError(\n                    f\"expected\
    \ three components in {original_color!r}\"\n                )\n            red,\
    \ green, blue = components\n            triplet = ColorTriplet(int(red), int(green),\
    \ int(blue))\n            if not all(component <= 255 for component in triplet):\n\
    \                raise ColorParseError(\n                    f\"color components\
    \ must be <= 255 in {original_color!r}\"\n                )\n            return\
    \ cls(color, ColorType.TRUECOLOR, triplet=triplet)\n\n    @lru_cache(maxsize=1024)\n\
    \    def get_ansi_codes(self, foreground: bool = True) -> Tuple[str, ...]:\n \
    \       \"\"\"Get the ANSI escape codes for this color.\"\"\"\n        _type =\
    \ self.type\n        if _type == ColorType.DEFAULT:\n            return (\"39\"\
    \ if foreground else \"49\",)\n\n        elif _type == ColorType.WINDOWS:\n  \
    \          number = self.number\n            assert number is not None\n     \
    \       fore, back = (30, 40) if number < 8 else (82, 92)\n            return\
    \ (str(fore + number if foreground else back + number),)\n\n        elif _type\
    \ == ColorType.STANDARD:\n            number = self.number\n            assert\
    \ number is not None\n            fore, back = (30, 40) if number < 8 else (82,\
    \ 92)\n            return (str(fore + number if foreground else back + number),)\n\
    \n        elif _type == ColorType.EIGHT_BIT:\n            assert self.number is\
    \ not None\n            return (\"38\" if foreground else \"48\", \"5\", str(self.number))\n\
    \n        else:  # self.standard == ColorStandard.TRUECOLOR:\n            assert\
    \ self.triplet is not None\n            red, green, blue = self.triplet\n    \
    \        return (\"38\" if foreground else \"48\", \"2\", str(red), str(green),\
    \ str(blue))\n\n    @lru_cache(maxsize=1024)\n    def downgrade(self, system:\
    \ ColorSystem) -> \"Color\":\n        \"\"\"Downgrade a color system to a system\
    \ with fewer colors.\"\"\"\n\n        if self.type in (ColorType.DEFAULT, system):\n\
    \            return self\n        # Convert to 8-bit color from truecolor color\n\
    \        if system == ColorSystem.EIGHT_BIT and self.system == ColorSystem.TRUECOLOR:\n\
    \            assert self.triplet is not None\n            _h, l, s = rgb_to_hls(*self.triplet.normalized)\n\
    \            # If saturation is under 15% assume it is grayscale\n           \
    \ if s < 0.15:\n                gray = round(l * 25.0)\n                if gray\
    \ == 0:\n                    color_number = 16\n                elif gray == 25:\n\
    \                    color_number = 231\n                else:\n             \
    \       color_number = 231 + gray\n                return Color(self.name, ColorType.EIGHT_BIT,\
    \ number=color_number)\n\n            red, green, blue = self.triplet\n      \
    \      six_red = red / 95 if red < 95 else 1 + (red - 95) / 40\n            six_green\
    \ = green / 95 if green < 95 else 1 + (green - 95) / 40\n            six_blue\
    \ = blue / 95 if blue < 95 else 1 + (blue - 95) / 40\n\n            color_number\
    \ = (\n                16 + 36 * round(six_red) + 6 * round(six_green) + round(six_blue)\n\
    \            )\n            return Color(self.name, ColorType.EIGHT_BIT, number=color_number)\n\
    \n        # Convert to standard from truecolor or 8-bit\n        elif system ==\
    \ ColorSystem.STANDARD:\n            if self.system == ColorSystem.TRUECOLOR:\n\
    \                assert self.triplet is not None\n                triplet = self.triplet\n\
    \            else:  # self.system == ColorSystem.EIGHT_BIT\n                assert\
    \ self.number is not None\n                triplet = ColorTriplet(*EIGHT_BIT_PALETTE[self.number])\n\
    \n            color_number = STANDARD_PALETTE.match(triplet)\n            return\
    \ Color(self.name, ColorType.STANDARD, number=color_number)\n\n        elif system\
    \ == ColorSystem.WINDOWS:\n            if self.system == ColorSystem.TRUECOLOR:\n\
    \                assert self.triplet is not None\n                triplet = self.triplet\n\
    \            else:  # self.system == ColorSystem.EIGHT_BIT\n                assert\
    \ self.number is not None\n                if self.number < 16:\n            \
    \        return Color(self.name, ColorType.WINDOWS, number=self.number)\n    \
    \            triplet = ColorTriplet(*EIGHT_BIT_PALETTE[self.number])\n\n     \
    \       color_number = WINDOWS_PALETTE.match(triplet)\n            return Color(self.name,\
    \ ColorType.WINDOWS, number=color_number)\n\n        return self\n\n\ndef parse_rgb_hex(hex_color:\
    \ str) -> ColorTriplet:\n    \"\"\"Parse six hex characters in to RGB triplet.\"\
    \"\"\n    assert len(hex_color) == 6, \"must be 6 characters\"\n    color = ColorTriplet(\n\
    \        int(hex_color[0:2], 16), int(hex_color[2:4], 16), int(hex_color[4:6],\
    \ 16)\n    )\n    return color\n\n\ndef blend_rgb(\n    color1: ColorTriplet,\
    \ color2: ColorTriplet, cross_fade: float = 0.5\n) -> ColorTriplet:\n    \"\"\"\
    Blend one RGB color in to another.\"\"\"\n    r1, g1, b1 = color1\n    r2, g2,\
    \ b2 = color2\n    new_color = ColorTriplet(\n        int(r1 + (r2 - r1) * cross_fade),\n\
    \        int(g1 + (g2 - g1) * cross_fade),\n        int(b1 + (b2 - b1) * cross_fade),\n\
    \    )\n    return new_color\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n\
    \    from .console import Console\n    from .table import Table\n    from .text\
    \ import Text\n\n    console = Console()\n\n    table = Table(show_footer=False,\
    \ show_edge=True)\n    table.add_column(\"Color\", width=10, overflow=\"ellipsis\"\
    )\n    table.add_column(\"Number\", justify=\"right\", style=\"yellow\")\n   \
    \ table.add_column(\"Name\", style=\"green\")\n    table.add_column(\"Hex\", style=\"\
    blue\")\n    table.add_column(\"RGB\", style=\"magenta\")\n\n    colors = sorted((v,\
    \ k) for k, v in ANSI_COLOR_NAMES.items())\n    for color_number, name in colors:\n\
    \        if \"grey\" in name:\n            continue\n        color_cell = Text(\"\
    \ \" * 10, style=f\"on {name}\")\n        if color_number < 16:\n            table.add_row(color_cell,\
    \ f\"{color_number}\", Text(f'\"{name}\"'))\n        else:\n            color\
    \ = EIGHT_BIT_PALETTE[color_number]  # type: ignore[has-type]\n            table.add_row(\n\
    \                color_cell, str(color_number), Text(f'\"{name}\"'), color.hex,\
    \ color.rgb\n            )\n\n    console.print(table)\n\n\n### Dependency File:\
    \ errors.py\nclass ConsoleError(Exception):\n    \"\"\"An error in console operation.\"\
    \"\"\n\n\nclass StyleError(Exception):\n    \"\"\"An error in styles.\"\"\"\n\n\
    \nclass StyleSyntaxError(ConsoleError):\n    \"\"\"Style was badly formatted.\"\
    \"\"\n\n\nclass MissingStyle(StyleError):\n    \"\"\"No such style.\"\"\"\n\n\n\
    class StyleStackError(ConsoleError):\n    \"\"\"Style stack is invalid.\"\"\"\n\
    \n\nclass NotRenderableError(ConsoleError):\n    \"\"\"Object is not renderable.\"\
    \"\"\n\n\nclass MarkupError(ConsoleError):\n    \"\"\"Markup was badly formatted.\"\
    \"\"\n\n\nclass LiveError(ConsoleError):\n    \"\"\"Error related to Live display.\"\
    \"\"\n\n\nclass NoAltScreen(ConsoleError):\n    \"\"\"Alt screen mode was required.\"\
    \"\"\n\n\n### Dependency File: repr.py\nimport inspect\nfrom functools import\
    \ partial\nfrom typing import (\n    Any,\n    Callable,\n    Iterable,\n    List,\n\
    \    Optional,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    overload,\n\
    )\n\nT = TypeVar(\"T\")\n\n\nResult = Iterable[Union[Any, Tuple[Any], Tuple[str,\
    \ Any], Tuple[str, Any, Any]]]\nRichReprResult = Result\n\n\nclass ReprError(Exception):\n\
    \    \"\"\"An error occurred when attempting to build a repr.\"\"\"\n\n\n@overload\n\
    def auto(cls: Optional[Type[T]]) -> Type[T]:\n    ...\n\n\n@overload\ndef auto(*,\
    \ angular: bool = False) -> Callable[[Type[T]], Type[T]]:\n    ...\n\n\ndef auto(\n\
    \    cls: Optional[Type[T]] = None, *, angular: Optional[bool] = None\n) -> Union[Type[T],\
    \ Callable[[Type[T]], Type[T]]]:\n    \"\"\"Class decorator to create __repr__\
    \ from __rich_repr__\"\"\"\n\n    def do_replace(cls: Type[T], angular: Optional[bool]\
    \ = None) -> Type[T]:\n        def auto_repr(self: T) -> str:\n            \"\"\
    \"Create repr string from __rich_repr__\"\"\"\n            repr_str: List[str]\
    \ = []\n            append = repr_str.append\n\n            angular: bool = getattr(self.__rich_repr__,\
    \ \"angular\", False)  # type: ignore[attr-defined]\n            for arg in self.__rich_repr__():\
    \  # type: ignore[attr-defined]\n                if isinstance(arg, tuple):\n\
    \                    if len(arg) == 1:\n                        append(repr(arg[0]))\n\
    \                    else:\n                        key, value, *default = arg\n\
    \                        if key is None:\n                            append(repr(value))\n\
    \                        else:\n                            if default and default[0]\
    \ == value:\n                                continue\n                      \
    \      append(f\"{key}={value!r}\")\n                else:\n                 \
    \   append(repr(arg))\n            if angular:\n                return f\"<{self.__class__.__name__}\
    \ {' '.join(repr_str)}>\"\n            else:\n                return f\"{self.__class__.__name__}({',\
    \ '.join(repr_str)})\"\n\n        def auto_rich_repr(self: Type[T]) -> Result:\n\
    \            \"\"\"Auto generate __rich_rep__ from signature of __init__\"\"\"\
    \n            try:\n                signature = inspect.signature(self.__init__)\n\
    \                for name, param in signature.parameters.items():\n          \
    \          if param.kind == param.POSITIONAL_ONLY:\n                        yield\
    \ getattr(self, name)\n                    elif param.kind in (\n            \
    \            param.POSITIONAL_OR_KEYWORD,\n                        param.KEYWORD_ONLY,\n\
    \                    ):\n                        if param.default is param.empty:\n\
    \                            yield getattr(self, param.name)\n               \
    \         else:\n                            yield param.name, getattr(self, param.name),\
    \ param.default\n            except Exception as error:\n                raise\
    \ ReprError(\n                    f\"Failed to auto generate __rich_repr__; {error}\"\
    \n                ) from None\n\n        if not hasattr(cls, \"__rich_repr__\"\
    ):\n            auto_rich_repr.__doc__ = \"Build a rich repr\"\n            cls.__rich_repr__\
    \ = auto_rich_repr  # type: ignore[attr-defined]\n\n        auto_repr.__doc__\
    \ = \"Return repr(self)\"\n        cls.__repr__ = auto_repr  # type: ignore[assignment]\n\
    \        if angular is not None:\n            cls.__rich_repr__.angular = angular\
    \  # type: ignore[attr-defined]\n        return cls\n\n    if cls is None:\n \
    \       return partial(do_replace, angular=angular)\n    else:\n        return\
    \ do_replace(cls, angular=angular)\n\n\n@overload\ndef rich_repr(cls: Optional[Type[T]])\
    \ -> Type[T]:\n    ...\n\n\n@overload\ndef rich_repr(*, angular: bool = False)\
    \ -> Callable[[Type[T]], Type[T]]:\n    ...\n\n\ndef rich_repr(\n    cls: Optional[Type[T]]\
    \ = None, *, angular: bool = False\n) -> Union[Type[T], Callable[[Type[T]], Type[T]]]:\n\
    \    if cls is None:\n        return auto(angular=angular)\n    else:\n      \
    \  return auto(cls)\n\n\nif __name__ == \"__main__\":\n\n    @auto\n    class\
    \ Foo:\n        def __rich_repr__(self) -> Result:\n            yield \"foo\"\n\
    \            yield \"bar\", {\"shopping\": [\"eggs\", \"ham\", \"pineapple\"]}\n\
    \            yield \"buy\", \"hand sanitizer\"\n\n    foo = Foo()\n    from rich.console\
    \ import Console\n\n    console = Console()\n\n    console.rule(\"Standard repr\"\
    )\n    console.print(foo)\n\n    console.print(foo, width=60)\n    console.print(foo,\
    \ width=30)\n\n    console.rule(\"Angular repr\")\n    Foo.__rich_repr__.angular\
    \ = True  # type: ignore[attr-defined]\n\n    console.print(foo)\n\n    console.print(foo,\
    \ width=60)\n    console.print(foo, width=30)\n\n\n### Dependency File: terminal_theme.py\n\
    from typing import List, Optional, Tuple\n\nfrom .color_triplet import ColorTriplet\n\
    from .palette import Palette\n\n_ColorTuple = Tuple[int, int, int]\n\n\nclass\
    \ TerminalTheme:\n    \"\"\"A color theme used when exporting console content.\n\
    \n    Args:\n        background (Tuple[int, int, int]): The background color.\n\
    \        foreground (Tuple[int, int, int]): The foreground (text) color.\n   \
    \     normal (List[Tuple[int, int, int]]): A list of 8 normal intensity colors.\n\
    \        bright (List[Tuple[int, int, int]], optional): A list of 8 bright colors,\
    \ or None\n            to repeat normal intensity. Defaults to None.\n    \"\"\
    \"\n\n    def __init__(\n        self,\n        background: _ColorTuple,\n   \
    \     foreground: _ColorTuple,\n        normal: List[_ColorTuple],\n        bright:\
    \ Optional[List[_ColorTuple]] = None,\n    ) -> None:\n        self.background_color\
    \ = ColorTriplet(*background)\n        self.foreground_color = ColorTriplet(*foreground)\n\
    \        self.ansi_colors = Palette(normal + (bright or normal))\n\n\nDEFAULT_TERMINAL_THEME\
    \ = TerminalTheme(\n    (255, 255, 255),\n    (0, 0, 0),\n    [\n        (0, 0,\
    \ 0),\n        (128, 0, 0),\n        (0, 128, 0),\n        (128, 128, 0),\n  \
    \      (0, 0, 128),\n        (128, 0, 128),\n        (0, 128, 128),\n        (192,\
    \ 192, 192),\n    ],\n    [\n        (128, 128, 128),\n        (255, 0, 0),\n\
    \        (0, 255, 0),\n        (255, 255, 0),\n        (0, 0, 255),\n        (255,\
    \ 0, 255),\n        (0, 255, 255),\n        (255, 255, 255),\n    ],\n)\n\nMONOKAI\
    \ = TerminalTheme(\n    (12, 12, 12),\n    (217, 217, 217),\n    [\n        (26,\
    \ 26, 26),\n        (244, 0, 95),\n        (152, 224, 36),\n        (253, 151,\
    \ 31),\n        (157, 101, 255),\n        (244, 0, 95),\n        (88, 209, 235),\n\
    \        (196, 197, 181),\n        (98, 94, 76),\n    ],\n    [\n        (244,\
    \ 0, 95),\n        (152, 224, 36),\n        (224, 213, 97),\n        (157, 101,\
    \ 255),\n        (244, 0, 95),\n        (88, 209, 235),\n        (246, 246, 239),\n\
    \    ],\n)\nDIMMED_MONOKAI = TerminalTheme(\n    (25, 25, 25),\n    (185, 188,\
    \ 186),\n    [\n        (58, 61, 67),\n        (190, 63, 72),\n        (135, 154,\
    \ 59),\n        (197, 166, 53),\n        (79, 118, 161),\n        (133, 92, 141),\n\
    \        (87, 143, 164),\n        (185, 188, 186),\n        (136, 137, 135),\n\
    \    ],\n    [\n        (251, 0, 31),\n        (15, 114, 47),\n        (196, 112,\
    \ 51),\n        (24, 109, 227),\n        (251, 0, 103),\n        (46, 112, 109),\n\
    \        (253, 255, 185),\n    ],\n)\nNIGHT_OWLISH = TerminalTheme(\n    (255,\
    \ 255, 255),\n    (64, 63, 83),\n    [\n        (1, 22, 39),\n        (211, 66,\
    \ 62),\n        (42, 162, 152),\n        (218, 170, 1),\n        (72, 118, 214),\n\
    \        (64, 63, 83),\n        (8, 145, 106),\n        (122, 129, 129),\n   \
    \     (122, 129, 129),\n    ],\n    [\n        (247, 110, 110),\n        (73,\
    \ 208, 197),\n        (218, 194, 107),\n        (92, 167, 228),\n        (105,\
    \ 112, 152),\n        (0, 201, 144),\n        (152, 159, 177),\n    ],\n)\n\n\
    SVG_EXPORT_THEME = TerminalTheme(\n    (41, 41, 41),\n    (197, 200, 198),\n \
    \   [\n        (75, 78, 85),\n        (204, 85, 90),\n        (152, 168, 75),\n\
    \        (208, 179, 68),\n        (96, 138, 177),\n        (152, 114, 159),\n\
    \        (104, 160, 179),\n        (197, 200, 198),\n        (154, 155, 153),\n\
    \    ],\n    [\n        (255, 38, 39),\n        (0, 130, 61),\n        (208, 132,\
    \ 66),\n        (25, 132, 233),\n        (255, 44, 122),\n        (57, 130, 128),\n\
    \        (253, 253, 197),\n    ],\n)\n\nOutput the complete test file, code only,\
    \ no explanations.\n### Time\nCurrent time: 2025-03-17 01:51:18\n"
  role: user
