response: "```python\nimport os\nimport sys\nimport traceback\nimport types\nfrom\
  \ io import StringIO\nfrom unittest import TestCase, skipIf\n\nfrom twisted.python.compat\
  \ import _PY3\nfrom twisted.python.failure import Failure, format_frames, NoCurrentExceptionError\n\
  from twisted.python.util import mergeFunctionMetadata\n\n\ndef _makeGetframeSafe():\n\
  \    \"\"\"\n    Make it safe to call L{inspect.getframeinfo} by monkey-patching\n\
  \    L{traceback._some_str} (which it calls) to not blow up on non-strings.\n\n\
  \    This is necessary because (as of Python 2.5) L{traceback.format_stack},\n \
  \   which this test calls internally, calls L{inspect.getframeinfo}, which\n   \
  \ calls L{traceback._some_str} on the locals of a frame, and therefore\n    attempting\
  \ to format a stack with arbitrary objects on it can fail.\n\n    @return: a 0-argument\
  \ callable that will restore L{traceback._some_str}.\n    \"\"\"\n    oldSomeStr\
  \ = traceback._some_str\n\n    def newSomeStr(obj):\n        try:\n            return\
  \ oldSomeStr(obj)\n        except Exception:\n            return \"<FAILURE>\"\n\
  \n    traceback._some_str = newSomeStr\n\n    def cleanup():\n        traceback._some_str\
  \ = oldSomeStr\n\n    return cleanup\n\n\nclass FailureTests(TestCase):\n    def\
  \ test_noCurrentFailure(self):\n        \"\"\"\n        L{Failure} raises L{NoCurrentExceptionError}\
  \ if instantiated when no\n        exception is present.\n        \"\"\"\n     \
  \   self.assertRaises(NoCurrentExceptionError, Failure)\n\n    def test_noCurrentFailureWithTraceback(self):\n\
  \        \"\"\"\n        If L{Failure} is constructed when no exception is present,\
  \ passing a\n        traceback object results in L{NoCurrentExceptionError}.\n \
  \       \"\"\"\n        try:\n            1 / 0\n        except BaseException:\n\
  \            excType, excValue, traceback = sys.exc_info()\n        self.assertRaises(NoCurrentExceptionError,\
  \ Failure, None, None, traceback)\n\n    def test_noCurrentFailureWithType(self):\n\
  \        \"\"\"\n        If L{Failure} is constructed when no exception is present,\
  \ passing an\n        exception type results in L{NoCurrentExceptionError}.\n  \
  \      \"\"\"\n        try:\n            1 / 0\n        except BaseException:\n\
  \            excType, excValue, traceback = sys.exc_info()\n        self.assertRaises(NoCurrentExceptionError,\
  \ Failure, None, excType)\n\n    def test_noCurrentFailureWithValue(self):\n   \
  \     \"\"\"\n        If L{Failure} is constructed when no exception is present,\
  \ passing an\n        exception value results in L{NoCurrentExceptionError}.\n \
  \       \"\"\"\n        try:\n            1 / 0\n        except BaseException:\n\
  \            excType, excValue, traceback = sys.exc_info()\n        self.assertRaises(NoCurrentExceptionError,\
  \ Failure, excValue)\n\n    def test_raiseException(self):\n        \"\"\"\n   \
  \     L{Failure.raiseException} raises the original exception.\n        \"\"\"\n\
  \        try:\n            raise ValueError(\"foo\")\n        except BaseException:\n\
  \            f = Failure()\n        self.assertRaises(ValueError, f.raiseException)\n\
  \n    def test_raiseExceptionWithNonException(self):\n        \"\"\"\n        L{Failure.raiseException}\
  \ raises the original exception even if it is\n        not an instance of L{Exception}.\n\
  \        \"\"\"\n        try:\n            raise BaseException(\"foo\")\n      \
  \  except BaseException:\n            f = Failure()\n        self.assertRaises(BaseException,\
  \ f.raiseException)\n\n    def test_raiseExceptionWhenPickled(self):\n        \"\
  \"\"\n        L{Failure.raiseException} raises the original exception even when\
  \ the\n        L{Failure} object was created from a pickled L{Failure}.\n      \
  \  \"\"\"\n        try:\n            raise ValueError(\"foo\")\n        except BaseException:\n\
  \            f = Failure()\n        pickled = pickle.loads(pickle.dumps(f))\n  \
  \      self.assertRaises(ValueError, pickled.raiseException)\n\n    def test_raiseExceptionWhenPickledWithNonException(self):\n\
  \        \"\"\"\n        L{Failure.raiseException} raises the original exception\
  \ even when the\n        L{Failure} object was created from a pickled L{Failure}\
  \ and the original\n        exception is not an instance of L{Exception}.\n    \
  \    \"\"\"\n        try:\n            raise BaseException(\"foo\")\n        except\
  \ BaseException:\n            f = Failure()\n        pickled = pickle.loads(pickle.dumps(f))\n\
  \        self.assertRaises(BaseException, pickled.raiseException)\n\n    def test_throwExceptionIntoGenerator(self):\n\
  \        \"\"\"\n        L{Failure.throwExceptionIntoGenerator} throws the original\
  \ exception\n        into a generator.\n        \"\"\"\n        try:\n         \
  \   raise ValueError(\"foo\")\n        except BaseException:\n            f = Failure()\n\
  \n        def generator():\n            try:\n                yield 1\n        \
  \    except ValueError:\n                return 42\n\n        g = generator()\n\
  \        next(g)\n        self.assertEqual(f.throwExceptionIntoGenerator(g), 42)\n\
  \n    def test_throwExceptionIntoGeneratorWithNonException(self):\n        \"\"\"\
  \n        L{Failure.throwExceptionIntoGenerator} throws the original exception\n\
  \        into a generator even if it is not an instance of L{Exception}.\n     \
  \   \"\"\"\n        try:\n            raise BaseException(\"foo\")\n        except\
  \ BaseException:\n            f = Failure()\n\n        def generator():\n      \
  \      try:\n                yield 1\n            except BaseException:\n      \
  \          return 42\n\n        g = generator()\n        next(g)\n        self.assertEqual(f.throwExceptionIntoGenerator(g),\
  \ 42)\n\n    def test_throwExceptionIntoGeneratorWhenPickled(self):\n        \"\"\
  \"\n        L{Failure.throwExceptionIntoGenerator} throws the original exception\n\
  \        into a generator even when the L{Failure} object was created from a\n \
  \       pickled L{Failure}.\n        \"\"\"\n        try:\n            raise ValueError(\"\
  foo\")\n        except BaseException:\n            f = Failure()\n        pickled\
  \ = pickle.loads(pickle.dumps(f))\n\n        def generator():\n            try:\n\
  \                yield 1\n            except ValueError:\n                return\
  \ 42\n\n        g = generator()\n        next(g)\n        self.assertEqual(pickled.throwExceptionIntoGenerator(g),\
  \ 42)\n\n    def test_throwExceptionIntoGeneratorWhenPickledWithNonException(self):\n\
  \        \"\"\"\n        L{Failure.throwExceptionIntoGenerator} throws the original\
  \ exception\n        into a generator even when the L{Failure} object was created\
  \ from a\n        pickled L{Failure} and the original exception is not an instance\
  \ of\n        L{Exception}.\n        \"\"\"\n        try:\n            raise BaseException(\"\
  foo\")\n        except BaseException:\n            f = Failure()\n        pickled\
  \ = pickle.loads(pickle.dumps(f))\n\n        def generator():\n            try:\n\
  \                yield 1\n            except BaseException:\n                return\
  \ 42\n\n        g = generator()\n        next(g)\n        self.assertEqual(pickled.throwExceptionIntoGenerator(g),\
  \ 42)\n\n    def test_defaultTraceback(self):\n        \"\"\"\n        When L{Failure}\
  \ is constructed with no arguments, it uses the current\n        exception.\n  \
  \      \"\"\"\n        try:\n            1 / 0\n        except BaseException:\n\
  \            f = Failure()\n            self.assertEqual(f.type, ZeroDivisionError)\n\
  \            self.assertTrue(f.tb)\n\n    def test_explicitTraceback(self):\n  \
  \      \"\"\"\n        When L{Failure} is constructed with an exception value, it\
  \ uses the\n        current exception.\n        \"\"\"\n        try:\n         \
  \   1 / 0\n        except BaseException:\n            excType, excValue, traceback\
  \ = sys.exc_info()\n        f = Failure(excValue)\n        self.assertEqual(f.type,\
  \ ZeroDivisionError)\n        self.assertEqual(f.tb, traceback)\n\n    def test_explicitTracebackWithTraceback(self):\n\
  \        \"\"\"\n        When L{Failure} is constructed with an exception value\
  \ and traceback, it\n        uses the given traceback.\n        \"\"\"\n       \
  \ try:\n            1 / 0\n        except BaseException:\n            excType, excValue,\
  \ traceback = sys.exc_info()\n        f = Failure(excValue, None, traceback)\n \
  \       self.assertEqual(f.type, ZeroDivisionError)\n        self.assertEqual(f.tb,\
  \ traceback)\n\n    def test_explicitTracebackWithType(self):\n        \"\"\"\n\
  \        When L{Failure} is constructed with an exception value and type, it uses\n\
  \        the given type.\n        \"\"\"\n        try:\n            1 / 0\n    \
  \    except BaseException:\n            excType, excValue, traceback = sys.exc_info()\n\
  \        f = Failure(excValue, excType)\n        self.assertEqual(f.type, ZeroDivisionError)\n\
  \        self.assertEqual(f.tb, traceback)\n\n    def test_getErrorMessage(self):\n\
  \        \"\"\"\n        L{Failure.getErrorMessage} returns the string representation\
  \ of the\n        exception value.\n        \"\"\"\n        try:\n            raise\
  \ ValueError(\"foo\")\n        except BaseException:\n            f = Failure()\n\
  \        self.assertEqual(f.getErrorMessage(), \"foo\")\n\n    def test_getTraceback(self):\n\
  \        \"\"\"\n        L{Failure.getTraceback} returns a string representation\
  \ of the\n        traceback.\n        \"\"\"\n        try:\n            1 / 0\n\
  \        except BaseException:\n            f = Failure()\n        io = StringIO()\n\
  \        traceback.print_tb(f.tb, file=io)\n        self.assertEqual(f.getTraceback(),\
  \ io.getvalue())\n\n    def test_printTraceback(self):\n        \"\"\"\n       \
  \ L{Failure.printTraceback} prints the traceback.\n        \"\"\"\n        try:\n\
  \            1 / 0\n        except BaseException:\n            f = Failure()\n \
  \       io = StringIO()\n        f.printTraceback(file=io)\n        self.assertIn(\"\
  ZeroDivisionError\", io.getvalue())\n\n    def test_printBriefTraceback(self):\n\
  \        \"\"\"\n        L{Failure.printBriefTraceback} prints the traceback with\
  \ the C{brief}\n        detail level.\n        \"\"\"\n        try:\n          \
  \  1 / 0\n        except BaseException:\n            f = Failure()\n        io =\
  \ StringIO()\n        f.printBriefTraceback(file=io)\n        self.assertIn(\"ZeroDivisionError\"\
  , io.getvalue())\n\n    def test_printDetailedTraceback(self):\n        \"\"\"\n\
  \        L{Failure.printDetailedTraceback} prints the traceback with the\n     \
  \   C{verbose} detail level.\n        \"\"\"\n        try:\n            1 / 0\n\
  \        except BaseException:\n            f = Failure()\n        io = StringIO()\n\
  \        f.printDetailedTraceback(file=io)\n        self.assertIn(\"ZeroDivisionError\"\
  , io.getvalue())\n\n    def test_format_framesDefault(self):\n        \"\"\"\n \
  \       L{format_frames} formats frames with the C{default} detail level by\n  \
  \      printing each frame's filename, line number, and function name and the\n\
  \        line of source, prefixed by four spaces.\n        \"\"\"\n        io =\
  \ StringIO()\n        format_frames(\n            [\n                (\"f1\", __file__,\
  \ 1, {}, {}),\n                (\"f2\", __file__, 2, {}, {}),\n            ],\n\
  \            io.write,\n        )\n        self.assertEqual(\n            io.getvalue(),\n\
  \            '  File \"twisted/test/test_failure.py\", line 1, in f1\\n'\n     \
  \       \"    \\n\"\n            '  File \"twisted/test/test_failure.py\", line\
  \ 2, in f2\\n'\n            \"    \\n\",\n        )\n\n    def test_format_framesBrief(self):\n\
  \        \"\"\"\n        L{format_frames} formats frames with the C{brief} detail\
  \ level by\n        printing each frame's filename, line number, and function name.\n\
  \        \"\"\"\n        io = StringIO()\n        format_frames(\n            [\n\
  \                (\"f1\", __file__, 1, {}, {}),\n                (\"f2\", __file__,\
  \ 2, {}, {}),\n            ],\n            io.write,\n            detail=\"brief\"\
  ,\n        )\n        self.assertEqual(\n            io.getvalue(),\n          \
  \  \"twisted/test/test_failure.py:1:f1\\n\" \"twisted/test/test_failure.py:2:f2\\\
  n\",\n        )\n\n    def test_format_framesVerbose(self):\n        \"\"\"\n  \
  \      L{format_frames} formats frames with the C{verbose} detail level by\n   \
  \     printing each frame's filename, line number, and function name and the\n \
  \       locals and globals, formatted as reprs.\n        \"\"\"\n        io = StringIO()\n\
  \        format_frames(\n            [\n                (\"f1\", __file__, 1, [(\"\
  local1\", \"x\")], [(\"global1\", \"y\")]),\n                (\"f2\", __file__,\
  \ 2, [(\"local2\", \"x\")], [(\"global2\", \"y\")]),\n            ],\n         \
  \   io.write,\n            detail=\"verbose\",\n        )\n        self.assertEqual(\n\
  \            io.getvalue(),\n            \"twisted/test/test_failure.py:1: f1(...)\\\
  n\"\n            \" [ Locals ]\\n\"\n            \"  local1 : 'x'\\n\"\n       \
  \     \" ( Globals )\\n\"\n            \"  global1 : 'y'\\n\"\n            \"twisted/test/test_failure.py:2:\
  \ f2(...)\\n\"\n            \" [ Locals ]\\n\"\n            \"  local2 : 'x'\\n\"\
  \n            \" ( Globals )\\n\"\n            \"  global2 : 'y'\\n\",\n       \
  \ )\n\n    def test_format_framesInvalidDetail(self):\n        \"\"\"\n        L{format_frames}\
  \ raises L{ValueError} when given an invalid detail\n        level.\n        \"\"\
  \"\n        self.assertRaises(\n            ValueError, format_frames, [(\"f1\"\
  , __file__, 1, {}, {})], lambda: None, \"x\"\n        )\n\n    def test_format_framesVerboseVarsNotCaptured(self):\n\
  \        \"\"\"\n        L{format_frames} formats frames with the\n        C{verbose-vars-not-captured}\
  \ detail level by printing each frame's\n        filename, line number, and function\
  \ name, followed by a line\n        indicating that locals and globals are not captured.\n\
  \        \"\"\"\n        io = StringIO()\n        format_frames(\n            [\n\
  \                (\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\", \"\
  y\")]),\n                (\"f2\", __file__, 2, [(\"local2\", \"x\")], [(\"global2\"\
  , \"y\")]),\n            ],\n            io.write,\n            detail=\"verbose-vars-not-captured\"\
  ,\n        )\n        self.assertEqual(\n            io.getvalue(),\n          \
  \  \"twisted/test/test_failure.py:1: f1(...)\\n\"\n            \"twisted/test/test_failure.py:2:\
  \ f2(...)\\n\"\n            \" [Capture of Locals and Globals disabled (use captureVars=True)]\\\
  n\",\n        )\n\n    def test_check(self):\n        \"\"\"\n        L{Failure.check}\
  \ returns the type of the failure if the failure's type\n        is in the given\
  \ types.\n        \"\"\"\n        try:\n            raise ValueError(\"foo\")\n\
  \        except BaseException:\n            f = Failure()\n        self.assertEqual(f.check(ValueError),\
  \ ValueError)\n\n    def test_checkClassName(self):\n        \"\"\"\n        L{Failure.check}\
  \ returns the type of the failure if the failure's type\n        or one of its bases\
  \ is in the given types as a class name.\n        \"\"\"\n        try:\n       \
  \     raise ValueError(\"foo\")\n        except BaseException:\n            f =\
  \ Failure()\n        self.assertEqual(f.check(\"ValueError\"), \"ValueError\")\n\
  \        self.assertEqual(f.check(\"Exception\"), \"Exception\")\n\n    def test_checkClassNameMissing(self):\n\
  \        \"\"\"\n        L{Failure.check} returns L{None} if the failure's type\
  \ or one of its\n        bases is not in the given types as a class name.\n    \
  \    \"\"\"\n        try:\n            raise ValueError(\"foo\")\n        except\
  \ BaseException:\n            f = Failure()\n        self.assertIsNone(f.check(\"\
  KeyError\"))\n\n    def test_trap(self):\n        \"\"\"\n        L{Failure.trap}\
  \ raises the original exception if the failure's type is\n        not in the given\
  \ types.\n        \"\"\"\n        try:\n            raise ValueError(\"foo\")\n\
  \        except BaseException:\n            f = Failure()\n        self.assertRaises(KeyError,\
  \ f.trap, KeyError)\n\n    def test_trapReturnsType(self):\n        \"\"\"\n   \
  \     L{Failure.trap} returns the type of the failure if the failure's type\n  \
  \      is in the given types.\n        \"\"\"\n        try:\n            raise ValueError(\"\
  foo\")\n        except BaseException:\n            f = Failure()\n        self.assertEqual(f.trap(ValueError),\
  \ ValueError)\n\n    def test_trapFromPickle(self):\n        \"\"\"\n        L{Failure.trap}\
  \ returns the type of the failure if the failure's type\n        is in the given\
  \ types after being pickled.\n        \"\"\"\n        try:\n            raise ValueError(\"\
  foo\")\n        except BaseException:\n            f = Failure()\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertEqual(pf.trap(ValueError), ValueError)\n\n    def test_trapClassName(self):\n\
  \        \"\"\"\n        L{Failure.trap} returns the type of the failure if the\
  \ failure's type\n        is in the given types as a class name.\n        \"\"\"\
  \n        try:\n            raise ValueError(\"foo\")\n        except BaseException:\n\
  \            f = Failure()\n        self.assertEqual(f.trap(\"ValueError\"), \"\
  ValueError\")\n\n    def test_trapClassNameMissing(self):\n        \"\"\"\n    \
  \    L{Failure.trap} raises the original exception if the failure's type is\n  \
  \      not in the given types as a class name.\n        \"\"\"\n        try:\n \
  \           raise ValueError(\"foo\")\n        except BaseException:\n         \
  \   f = Failure()\n        self.assertRaises(KeyError, f.trap, \"KeyError\")\n\n\
  \    def test_cleanFailure(self):\n        \"\"\"\n        L{Failure.cleanFailure}\
  \ removes the traceback.\n        \"\"\"\n        try:\n            raise ValueError(\"\
  foo\")\n        except BaseException:\n            f = Failure()\n        f.cleanFailure()\n\
  \        self.assertIsNone(f.tb)\n\n    def test_cleanFailureWhenPickled(self):\n\
  \        \"\"\"\n        L{Failure.cleanFailure} removes the traceback when the\
  \ L{Failure}\n        object was created from a pickled L{Failure}.\n        \"\"\
  \"\n        try:\n            raise ValueError(\"foo\")\n        except BaseException:\n\
  \            f = Failure()\n        pf = pickle.loads(pickle.dumps(f))\n       \
  \ pf.cleanFailure()\n        self.assertIsNone(pf.tb)\n\n    def test_getTracebackObject(self):\n\
  \        \"\"\"\n        L{Failure.getTracebackObject} returns the traceback.\n\
  \        \"\"\"\n        try:\n            raise ValueError(\"foo\")\n        except\
  \ BaseException:\n            f = Failure()\n        self.assertEqual(f.getTracebackObject(),\
  \ f.tb)\n\n    def test_getTracebackObjectWhenPickled(self):\n        \"\"\"\n \
  \       L{Failure.getTracebackObject} returns the traceback when the L{Failure}\n\
  \        object was created from a pickled L{Failure}.\n        \"\"\"\n       \
  \ try:\n            raise ValueError(\"foo\")\n        except BaseException:\n \
  \           f = Failure()\n        pf = pickle.loads(pickle.dumps(f))\n        self.assertEqual(pf.getTracebackObject(),\
  \ None)\n\n    def test_getTracebackObjectWhenNoTraceback(self):\n        \"\"\"\
  \n        L{Failure.getTracebackObject} returns the traceback when the L{Failure}\n\
  \        object was created from a pickled L{Failure} and the original exception\n\
  \        has no traceback.\n        \"\"\"\n        try:\n            raise ValueError(\"\
  foo\")\n        except BaseException:\n            f = Failure()\n        f.cleanFailure()\n\
  \        pf = pickle.loads(pickle.dumps(f))\n        self.assertEqual(pf.getTracebackObject(),\
  \ None)\n\n    def test_getTracebackObjectWhenNoTracebackOrFrames(self):\n     \
  \   \"\"\"\n        L{Failure.getTracebackObject} returns L{None} when the L{Failure}\
  \ object\n        was created from a pickled L{Failure} and the original exception\
  \ has no\n        traceback or frames.\n        \"\"\"\n        try:\n         \
  \   raise ValueError(\"foo\")\n        except BaseException:\n            f = Failure()\n\
  \        f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n        pf.cleanFailure()\n\
  \        self.assertIsNone(pf.getTracebackObject())\n\n    def test_getTracebackObjectWithFrames(self):\n\
  \        \"\"\"\n        L{Failure.getTracebackObject} returns a fake traceback\
  \ object if there\n        are frames but no traceback.\n        \"\"\"\n      \
  \  try:\n            raise ValueError(\"foo\")\n        except BaseException:\n\
  \            f = Failure()\n        f.cleanFailure()\n        f.frames = [(\"f1\"\
  , __file__, 1, [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n        tb = f.getTracebackObject()\n\
  \        self.assertIsInstance(tb, types.TracebackType)\n        self.assertEqual(tb.tb_lineno,\
  \ 1)\n        self.assertEqual(tb.tb_frame.f_code.co_filename, __file__)\n     \
  \   self.assertEqual(tb.tb_frame.f_code.co_name, \"f1\")\n        self.assertEqual(tb.tb_frame.f_locals,\
  \ {\"local1\": \"x\"})\n        self.assertEqual(tb.tb_frame.f_globals, {\"global1\"\
  : \"y\"})\n\n    def test_getTracebackObjectWithFramesWhenPickled(self):\n     \
  \   \"\"\"\n        L{Failure.getTracebackObject} returns a fake traceback object\
  \ if there\n        are frames but no traceback when the L{Failure} object was created\
  \ from\n        a pickled L{Failure}.\n        \"\"\"\n        try:\n          \
  \  raise ValueError(\"foo\")\n        except BaseException:\n            f = Failure()\n\
  \        f.cleanFailure()\n        f.frames = [(\"f1\", __file__, 1, [(\"local1\"\
  , \"x\")], [(\"global1\", \"y\")])]\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        tb = pf.getTracebackObject()\n        self.assertIsInstance(tb, types.TracebackType)\n\
  \        self.assertEqual(tb.tb_lineno, 1)\n        self.assertEqual(tb.tb_frame.f_code.co_filename,\
  \ __file__)\n        self.assertEqual(tb.tb_frame.f_code.co_name, \"f1\")\n    \
  \    self.assertEqual(tb.tb_frame.f_locals, {\"local1\": \"x\"})\n        self.assertEqual(tb.tb_frame.f_globals,\
  \ {\"global1\": \"y\"})\n\n    def test_getTracebackObjectWithFramesWhenNoTraceback(self):\n\
  \        \"\"\"\n        L{Failure.getTracebackObject} returns a fake traceback\
  \ object if there\n        are frames but no traceback when the L{Failure} object\
  \ was created from\n        a pickled L{Failure} and the original exception has\
  \ no traceback.\n        \"\"\"\n        try:\n            raise ValueError(\"foo\"\
  )\n        except BaseException:\n            f = Failure()\n        f.cleanFailure()\n\
  \        f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\"\
  , \"y\")])]\n        pf = pickle.loads(pickle.dumps(f))\n        tb = pf.getTracebackObject()\n\
  \        self.assertIsInstance(tb, types.TracebackType)\n        self.assertEqual(tb.tb_lineno,\
  \ 1)\n        self.assertEqual(tb.tb_frame.f_code.co_filename, __file__)\n     \
  \   self.assertEqual(tb.tb_frame.f_code.co_name, \"f1\")\n        self.assertEqual(tb.tb_frame.f_locals,\
  \ {\"local1\": \"x\"})\n        self.assertEqual(tb.tb_frame.f_globals, {\"global1\"\
  : \"y\"})\n\n    def test_getTracebackObjectWithFramesWhenNoTracebackOrFrames(self):\n\
  \        \"\"\"\n        L{Failure.getTracebackObject} returns L{None} when the\
  \ L{Failure} object\n        was created from a pickled L{Failure} and the original\
  \ exception has no\n        traceback or frames.\n        \"\"\"\n        try:\n\
  \            raise ValueError(\"foo\")\n        except BaseException:\n        \
  \    f = Failure()\n        f.cleanFailure()\n        f.frames = [(\"f1\", __file__,\
  \ 1, [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        pf.cleanFailure()\n        self.assertIsNone(pf.getTracebackObject())\n\
  \n    def test_repr(self):\n        \"\"\"\n        L{Failure.__repr__} includes\
  \ the type and error message of the\n        exception.\n        \"\"\"\n      \
  \  try:\n            raise ValueError(\"foo\")\n        except BaseException:\n\
  \            f = Failure()\n        self.assertEqual(repr(f), \"<twisted.python.failure.Failure\
  \ builtins.ValueError: foo>\")\n\n    def test_reprWhenPickled(self):\n        \"\
  \"\"\n        L{Failure.__repr__} includes the type and error message of the\n \
  \       exception when the L{Failure} object was created from a pickled\n      \
  \  L{Failure}.\n        \"\"\"\n        try:\n            raise ValueError(\"foo\"\
  )\n        except BaseException:\n            f = Failure()\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertEqual(repr(pf), \"<twisted.python.failure.Failure builtins.ValueError:\
  \ foo>\")\n\n    def test_str(self):\n        \"\"\"\n        L{Failure.__str__}\
  \ includes the error message of the exception.\n        \"\"\"\n        try:\n \
  \           raise ValueError(\"foo\")\n        except BaseException:\n         \
  \   f = Failure()\n        self.assertEqual(str(f), \"[Failure instance: Traceback\
  \ (failure with no frames): builtins.ValueError: foo\\n]\")\n\n    def test_strWhenPickled(self):\n\
  \        \"\"\"\n        L{Failure.__str__} includes the error message of the exception\
  \ when the\n        L{Failure} object was created from a pickled L{Failure}.\n \
  \       \"\"\"\n        try:\n            raise ValueError(\"foo\")\n        except\
  \ BaseException:\n            f = Failure()\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertEqual(str(pf), \"[Failure instance: Traceback (failure with\
  \ no frames): builtins.ValueError: foo\\n]\")\n\n    def test_noFramesIfNoCaptureVars(self):\n\
  \        \"\"\"\n        L{Failure.frames} is empty if L{Failure} is constructed\
  \ with no\n        exception and C{captureVars} is L{False}.\n        \"\"\"\n \
  \       try:\n            1 / 0\n        except BaseException:\n            f =\
  \ Failure(captureVars=False)\n        self.assertEqual(f.frames, [])\n\n    def\
  \ test_framesIfCaptureVars(self):\n        \"\"\"\n        L{Failure.frames} is\
  \ not empty if L{Failure} is constructed with no\n        exception and C{captureVars}\
  \ is L{True}.\n        \"\"\"\n        try:\n            1 / 0\n        except BaseException:\n\
  \            f = Failure(captureVars=True)\n        self.assertNotEqual(f.frames,\
  \ [])\n\n    def test_framesIfNoCaptureVarsWhenPickled(self):\n        \"\"\"\n\
  \        L{Failure.frames} is empty if L{Failure} is constructed with no\n     \
  \   exception and C{captureVars} is L{False} when the L{Failure} object was\n  \
  \      created from a pickled L{Failure}.\n        \"\"\"\n        try:\n      \
  \      1 / 0\n        except BaseException:\n            f = Failure(captureVars=False)\n\
  \        pf = pickle.loads(pickle.dumps(f))\n        self.assertEqual(pf.frames,\
  \ [])\n\n    def test_framesIfCaptureVarsWhenPickled(self):\n        \"\"\"\n  \
  \      L{Failure.frames} is not empty if L{Failure} is constructed with no\n   \
  \     exception and C{captureVars} is L{True} when the L{Failure} object was\n \
  \       created from a pickled L{Failure}.\n        \"\"\"\n        try:\n     \
  \       1 / 0\n        except BaseException:\n            f = Failure(captureVars=True)\n\
  \        pf = pickle.loads(pickle.dumps(f))\n        self.assertNotEqual(pf.frames,\
  \ [])\n\n    def test_framesWithTraceback(self):\n        \"\"\"\n        L{Failure.frames}\
  \ is not empty if L{Failure} is constructed with a\n        traceback.\n       \
  \ \"\"\"\n        try:\n            1 / 0\n        except BaseException:\n     \
  \       excType, excValue, traceback = sys.exc_info()\n        f = Failure(excValue,\
  \ None, traceback)\n        self.assertNotEqual(f.frames, [])\n\n    def test_framesWithTracebackWhenPickled(self):\n\
  \        \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed\
  \ with a\n        traceback when the L{Failure} object was created from a pickled\n\
  \        L{Failure}.\n        \"\"\"\n        try:\n            1 / 0\n        except\
  \ BaseException:\n            excType, excValue, traceback = sys.exc_info()\n  \
  \      f = Failure(excValue, None, traceback)\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertNotEqual(pf.frames, [])\n\n    def test_framesWithFrames(self):\n\
  \        \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed\
  \ with a\n        list of frames.\n        \"\"\"\n        f = Failure()\n     \
  \   f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\", \"y\"\
  )])]\n        self.assertNotEqual(f.frames, [])\n\n    def test_framesWithFramesWhenPickled(self):\n\
  \        \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed\
  \ with a\n        list of frames when the L{Failure} object was created from a pickled\n\
  \        L{Failure}.\n        \"\"\"\n        f = Failure()\n        f.frames =\
  \ [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n     \
  \   pf = pickle.loads(pickle.dumps(f))\n        self.assertNotEqual(pf.frames, [])\n\
  \n    def test_framesWithFramesWhenPickledWithoutTraceback(self):\n        \"\"\"\
  \n        L{Failure.frames} is not empty if L{Failure} is constructed with a\n \
  \       list of frames when the L{Failure} object was created from a pickled\n \
  \       L{Failure} and the original exception has no traceback.\n        \"\"\"\n\
  \        f = Failure()\n        f.frames = [(\"f1\", __file__, 1, [(\"local1\",\
  \ \"x\")], [(\"global1\", \"y\")])]\n        f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertNotEqual(pf.frames, [])\n\n    def test_framesWithFramesWhenPickledWithoutTracebackOrFrames(self):\n\
  \        \"\"\"\n        L{Failure.frames} is empty if L{Failure} is constructed\
  \ with a list of\n        frames when the L{Failure} object was created from a pickled\
  \ L{Failure}\n        and the original exception has no traceback or frames.\n \
  \       \"\"\"\n        f = Failure()\n        f.frames = [(\"f1\", __file__, 1,\
  \ [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n        f.cleanFailure()\n  \
  \      pf = pickle.loads(pickle.dumps(f))\n        pf.cleanFailure()\n        self.assertEqual(pf.frames,\
  \ [])\n\n    def test_framesWithFramesWhenNoTraceback(self):\n        \"\"\"\n \
  \       L{Failure.frames} is not empty if L{Failure} is constructed with a list\n\
  \        of frames when the L{Failure} object was created from a pickled\n     \
  \   L{Failure} and the original exception has no traceback.\n        \"\"\"\n  \
  \      f = Failure()\n        f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"\
  x\")], [(\"global1\", \"y\")])]\n        f.cleanFailure()\n        self.assertNotEqual(f.frames,\
  \ [])\n\n    def test_framesWithFramesWhenNoTracebackOrFrames(self):\n        \"\
  \"\"\n        L{Failure.frames} is empty if L{Failure} is constructed with a list\
  \ of\n        frames when the L{Failure} object was created from a pickled L{Failure}\n\
  \        and the original exception has no traceback or frames.\n        \"\"\"\n\
  \        f = Failure()\n        f.frames = [(\"f1\", __file__, 1, [(\"local1\",\
  \ \"x\")], [(\"global1\", \"y\")])]\n        f.cleanFailure()\n        f.cleanFailure()\n\
  \        self.assertEqual(f.frames, [])\n\n    def test_framesWithFramesWhenPickledWithoutTracebackOrFramesOrFrames(self):\n\
  \        \"\"\"\n        L{Failure.frames} is empty if L{Failure} is constructed\
  \ with a list of\n        frames when the L{Failure} object was created from a pickled\
  \ L{Failure}\n        and the original exception has no traceback or frames or frames.\n\
  \        \"\"\"\n        f = Failure()\n        f.frames = [(\"f1\", __file__, 1,\
  \ [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n        f.cleanFailure()\n  \
  \      f.cleanFailure()\n        f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertEqual(pf.frames, [])\n\n    def test_framesWithTracebackWithTraceback(self):\n\
  \        \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed\
  \ with a\n        traceback and a traceback when the L{Failure} object was created\
  \ from a\n        pickled L{Failure}.\n        \"\"\"\n        try:\n          \
  \  1 / 0\n        except BaseException:\n            excType, excValue, traceback\
  \ = sys.exc_info()\n        f = Failure(excValue, None, traceback)\n        pf =\
  \ pickle.loads(pickle.dumps(f))\n        self.assertNotEqual(pf.frames, [])\n\n\
  \    def test_framesWithTracebackWithTracebackWhenPickled(self):\n        \"\"\"\
  \n        L{Failure.frames} is not empty if L{Failure} is constructed with a\n \
  \       traceback and a traceback when the L{Failure} object was created from a\n\
  \        pickled L{Failure} and the original exception has no traceback.\n     \
  \   \"\"\"\n        try:\n            1 / 0\n        except BaseException:\n   \
  \         excType, excValue, traceback = sys.exc_info()\n        f = Failure(excValue,\
  \ None, traceback)\n        f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertNotEqual(pf.frames, [])\n\n    def test_framesWithTracebackWithTracebackWhenNoTraceback(self):\n\
  \        \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed\
  \ with a\n        traceback and a traceback when the L{Failure} object was created\
  \ from a\n        pickled L{Failure} and the original exception has no traceback.\n\
  \        \"\"\"\n        try:\n            1 / 0\n        except BaseException:\n\
  \            excType, excValue, traceback = sys.exc_info()\n        f = Failure(excValue,\
  \ None, traceback)\n        f.cleanFailure()\n        self.assertNotEqual(f.frames,\
  \ [])\n\n    def test_framesWithTracebackWithTracebackWhenNoTracebackOrFrames(self):\n\
  \        \"\"\"\n        L{Failure.frames} is empty if L{Failure} is constructed\
  \ with a traceback\n        and a traceback when the L{Failure} object was created\
  \ from a pickled\n        L{Failure} and the original exception has no traceback\
  \ or frames.\n        \"\"\"\n        try:\n            1 / 0\n        except BaseException:\n\
  \            excType, excValue, traceback = sys.exc_info()\n        f = Failure(excValue,\
  \ None, traceback)\n        f.cleanFailure()\n        f.cleanFailure()\n       \
  \ self.assertEqual(f.frames, [])\n\n    def test_framesWithTracebackWithFrames(self):\n\
  \        \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed\
  \ with a\n        traceback and a list of frames.\n        \"\"\"\n        f = Failure()\n\
  \        f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\"\
  , \"y\")])]\n        self.assertNotEqual(f.frames, [])\n\n    def test_framesWithTracebackWithFramesWhenPickled(self):\n\
  \        \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed\
  \ with a\n        traceback and a list of frames when the L{Failure} object was\
  \ created\n        from a pickled L{Failure}.\n        \"\"\"\n        f = Failure()\n\
  \        f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\"\
  , \"y\")])]\n        pf = pickle.loads(pickle.dumps(f))\n        self.assertNotEqual(pf.frames,\
  \ [])\n\n    def test_framesWithTracebackWithFramesWhenNoTraceback(self):\n    \
  \    \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed\
  \ with a\n        traceback and a list of frames when the L{Failure} object was\
  \ created\n        from a pickled L{Failure} and the original exception has no traceback.\n\
  \        \"\"\"\n        f = Failure()\n        f.frames = [(\"f1\", __file__, 1,\
  \ [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n        f.cleanFailure()\n  \
  \      pf = pickle.loads(pickle.dumps(f))\n        self.assertNotEqual(pf.frames,\
  \ [])\n\n    def test_framesWithTracebackWithFramesWhenNoTracebackOrFrames(self):\n\
  \        \"\"\"\n        L{Failure.frames} is empty if L{Failure} is constructed\
  \ with a traceback\n        and a list of frames when the L{Failure} object was\
  \ created from a\n        pickled L{Failure} and the original exception has no traceback\
  \ or\n        frames.\n        \"\"\"\n        f = Failure()\n        f.frames =\
  \ [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n     \
  \   f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n        pf.cleanFailure()\n\
  \        self.assertEqual(pf.frames, [])\n\n    def test_framesWithTracebackWithFramesWhenPickledWithoutTraceback(self):\n\
  \        \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed\
  \ with a\n        traceback and a list of frames when the L{Failure} object was\
  \ created\n        from a pickled L{Failure} and the original exception has no traceback.\n\
  \        \"\"\"\n        f = Failure()\n        f.frames = [(\"f1\", __file__, 1,\
  \ [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n        f.cleanFailure()\n  \
  \      pf = pickle.loads(pickle.dumps(f))\n        self.assertNotEqual(pf.frames,\
  \ [])\n\n    def test_framesWithTracebackWithFramesWhenPickledWithoutTracebackOrFrames(self):\n\
  \        \"\"\"\n        L{Failure.frames} is empty if L{Failure} is constructed\
  \ with a traceback\n        and a list of frames when the L{Failure} object was\
  \ created from a\n        pickled L{Failure} and the original exception has no traceback\
  \ or\n        frames.\n        \"\"\"\n        f = Failure()\n        f.frames =\
  \ [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n     \
  \   f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n        pf.cleanFailure()\n\
  \        self.assertEqual(pf.frames, [])\n\n    def test_framesWithTracebackWithFramesWhenPickledWithoutTracebackOrFramesOrFrames(self):\n\
  \        \"\"\"\n        L{Failure.frames} is empty if L{Failure} is constructed\
  \ with a traceback\n        and a list of frames when the L{Failure} object was\
  \ created from a\n        pickled L{Failure} and the original exception has no traceback\
  \ or\n        frames or frames.\n        \"\"\"\n        f = Failure()\n       \
  \ f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\", \"y\"\
  )])]\n        f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n   \
  \     pf.cleanFailure()\n        pf.cleanFailure()\n        self.assertEqual(pf.frames,\
  \ [])\n\n    def test_captureVars(self):\n        \"\"\"\n        L{Failure.captureVars}\
  \ is L{True} if L{Failure} is constructed with\n        C{captureVars} as L{True}.\n\
  \        \"\"\"\n        try:\n            1 / 0\n        except BaseException:\n\
  \            f = Failure(captureVars=True)\n        self.assertTrue(f.captureVars)\n\
  \n    def test_captureVarsIfNoCaptureVars(self):\n        \"\"\"\n        L{Failure.captureVars}\
  \ is L{False} if L{Failure} is constructed with\n        no exception and C{captureVars}\
  \ is L{False}.\n        \"\"\"\n        try:\n            1 / 0\n        except\
  \ BaseException:\n            f = Failure(captureVars=False)\n        self.assertFalse(f.captureVars)\n\
  \n    def test_captureVarsIfCaptureVars(self):\n        \"\"\"\n        L{Failure.captureVars}\
  \ is L{True} if L{Failure} is constructed with no\n        exception and C{captureVars}\
  \ is L{True}.\n        \"\"\"\n        try:\n            1 / 0\n        except BaseException:\n\
  \            f = Failure(captureVars=True)\n        self.assertTrue(f.captureVars)\n\
  \n    def test_captureVarsIfNoCaptureVarsWhenPickled(self):\n        \"\"\"\n  \
  \      L{Failure.captureVars} is L{False} if L{Failure} is constructed with\n  \
  \      no exception and C{captureVars} is L{False} when the L{Failure} object\n\
  \        was created from a pickled L{Failure}.\n        \"\"\"\n        try:\n\
  \            1 / 0\n        except BaseException:\n            f = Failure(captureVars=False)\n\
  \        pf = pickle.loads(pickle.dumps(f))\n        self.assertFalse(pf.captureVars)\n\
  \n    def test_captureVarsIfCaptureVarsWhenPickled(self):\n        \"\"\"\n    \
  \    L{Failure.captureVars} is L{True} if L{Failure} is constructed with no\n  \
  \      exception and C{captureVars} is L{True} when the L{Failure} object was\n\
  \        created from a pickled L{Failure}.\n        \"\"\"\n        try:\n    \
  \        1 / 0\n        except BaseException:\n            f = Failure(captureVars=True)\n\
  \        pf = pickle.loads(pickle.dumps(f))\n        self.assertTrue(pf.captureVars)\n\
  \n    def test_captureVarsWithTraceback(self):\n        \"\"\"\n        L{Failure.captureVars}\
  \ is L{True} if L{Failure} is constructed with a\n        traceback.\n        \"\
  \"\"\n        try:\n            1 / 0\n        except BaseException:\n         \
  \   excType, excValue, traceback = sys.exc_info()\n        f = Failure(excValue,\
  \ None, traceback)\n        self.assertTrue(f.captureVars)\n\n    def test_captureVarsWithTracebackWhenPickled(self):\n\
  \        \"\"\"\n        L{Failure.captureVars} is L{True} if L{Failure} is constructed\
  \ with a\n        traceback when the L{Failure} object was created from a pickled\n\
  \        L{Failure}.\n        \"\"\"\n        try:\n            1 / 0\n        except\
  \ BaseException:\n            excType, excValue, traceback = sys.exc_info()\n  \
  \      f = Failure(excValue, None, traceback)\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertTrue(pf.captureVars)\n\n    def test_captureVarsWithTracebackWhenNoTraceback(self):\n\
  \        \"\"\"\n        L{Failure.captureVars} is L{True} if L{Failure} is constructed\
  \ with a\n        traceback when the L{Failure} object was created from a pickled\n\
  \        L{Failure} and the original exception has no traceback.\n        \"\"\"\
  \n        try:\n            1 / 0\n        except BaseException:\n            excType,\
  \ excValue, traceback = sys.exc_info()\n        f = Failure(excValue, None, traceback)\n\
  \        f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n        self.assertTrue(pf.captureVars)\n\
  \n    def test_captureVarsWithTracebackWhenNoTracebackOrFrames(self):\n        \"\
  \"\"\n        L{Failure.captureVars} is L{False} if L{Failure} is constructed with\
  \ a\n        traceback when the L{Failure} object was created from a pickled\n \
  \       L{Failure} and the original exception has no traceback or frames.\n    \
  \    \"\"\"\n        try:\n            1 / 0\n        except BaseException:\n  \
  \          excType, excValue, traceback = sys.exc_info()\n        f = Failure(excValue,\
  \ None, traceback)\n        f.cleanFailure()\n        f.cleanFailure()\n       \
  \ pf = pickle.loads(pickle.dumps(f))\n        self.assertFalse(pf.captureVars)\n\
  \n    def test_captureVarsWithFrames(self):\n        \"\"\"\n        L{Failure.captureVars}\
  \ is L{True} if L{Failure} is constructed with a\n        list of frames.\n    \
  \    \"\"\"\n        f = Failure()\n        f.frames = [(\"f1\", __file__, 1, [(\"\
  local1\", \"x\")], [(\"global1\", \"y\")])]\n        self.assertTrue(f.captureVars)\n\
  \n    def test_captureVarsWithFramesWhenPickled(self):\n        \"\"\"\n       \
  \ L{Failure.captureVars} is L{True} if L{Failure} is constructed with a\n      \
  \  list of frames when the L{Failure} object was created from a pickled\n      \
  \  L{Failure}.\n        \"\"\"\n        f = Failure()\n        f.frames = [(\"f1\"\
  , __file__, 1, [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertTrue(pf.captureVars)\n\n    def test_captureVarsWithFramesWhenPickledWithoutTraceback(self):\n\
  \        \"\"\"\n        L{Failure.captureVars} is L{True} if L{Failure} is constructed\
  \ with a\n        list of frames when the L{Failure} object was created from a pickled\n\
  \        L{Failure} and the original exception has no traceback.\n        \"\"\"\
  \n        f = Failure()\n        f.frames = [(\"f1\", __file__, 1, [(\"local1\"\
  , \"x\")], [(\"global1\", \"y\")])]\n        f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertTrue(pf.captureVars)\n\n    def test_captureVarsWithFramesWhenPickledWithoutTracebackOrFrames(self):\n\
  \        \"\"\"\n        L{Failure.captureVars} is L{False} if L{Failure} is constructed\
  \ with a\n        list of frames when the L{Failure} object was created from a pickled\n\
  \        L{Failure} and the original exception has no traceback or frames.\n   \
  \     \"\"\"\n        f = Failure()\n        f.frames = [(\"f1\", __file__, 1, [(\"\
  local1\", \"x\")], [(\"global1\", \"y\")])]\n        f.cleanFailure()\n        pf\
  \ = pickle.loads(pickle.dumps(f))\n        pf.cleanFailure()\n        self.assertFalse(pf.captureVars)\n\
  \n    def test_captureVarsWithFramesWhenNoTraceback(self):\n        \"\"\"\n   \
  \     L{Failure.captureVars} is L{True} if L{Failure} is constructed with a\n  \
  \      list of frames when the L{Failure} object was created from a pickled\n  \
  \      L{Failure} and the original exception has no traceback.\n        \"\"\"\n\
  \        f = Failure()\n        f.frames = [(\"f1\", __file__, 1, [(\"local1\",\
  \ \"x\")], [(\"global1\", \"y\")])]\n        f.cleanFailure()\n        self.assertTrue(f.captureVars)\n\
  \n    def test_captureVarsWithFramesWhenNoTracebackOrFrames(self):\n        \"\"\
  \"\n        L{Failure.captureVars} is L{False} if L{Failure} is constructed with\
  \ a\n        list of frames when the L{Failure} object was created from a pickled\n\
  \        L{Failure} and the original exception has no traceback or frames.\n   \
  \     \"\"\"\n        f = Failure()\n        f.frames = [(\"f1\", __file__, 1, [(\"\
  local1\", \"x\")], [(\"global1\", \"y\")])]\n        f.cleanFailure()\n        f.cleanFailure()\n\
  \        self.assertFalse(f.captureVars)\n\n    def test_captureVarsWithTracebackWithTraceback(self):\n\
  \        \"\"\"\n        L{Failure.captureVars} is L{True} if L{Failure} is constructed\
  \ with a\n        traceback and a traceback when the L{Failure} object was created\
  \ from a\n        pickled L{Failure}.\n        \"\"\"\n        try:\n          \
  \  1 / 0\n        except BaseException:\n            excType, excValue, traceback\
  \ = sys.exc_info()\n        f = Failure(excValue, None, traceback)\n        pf =\
  \ pickle.loads(pickle.dumps(f))\n        self.assertTrue(pf.captureVars)\n\n   \
  \ def test_captureVarsWithTracebackWithTracebackWhenPickled(self):\n        \"\"\
  \"\n        L{Failure.captureVars} is L{True} if L{Failure} is constructed with\
  \ a\n        traceback and a traceback when the L{Failure} object was created from\
  \ a\n        pickled L{Failure} and the original exception has no traceback.\n \
  \       \"\"\"\n        try:\n            1 / 0\n        except BaseException:\n\
  \            excType, excValue, traceback = sys.exc_info()\n        f = Failure(excValue,\
  \ None, traceback)\n        f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertTrue(pf.captureVars)\n\n    def test_captureVarsWithTracebackWithTracebackWhenNoTraceback(self):\n\
  \        \"\"\"\n        L{Failure.captureVars} is L{True} if L{Failure} is constructed\
  \ with a\n        traceback and a traceback when the L{Failure} object was created\
  \ from a\n        pickled L{Failure} and the original exception has no traceback.\n\
  \        \"\"\"\n        try:\n            1 / 0\n        except BaseException:\n\
  \            excType, excValue, traceback = sys.exc_info()\n        f = Failure(excValue,\
  \ None, traceback)\n        f.cleanFailure()\n        self.assertTrue(f.captureVars)\n\
  \n    def test_captureVarsWithTracebackWithTracebackWhenNoTracebackOrFrames(self):\n\
  \        \"\"\"\n        L{Failure.captureVars} is L{False} if L{Failure} is constructed\
  \ with a\n        traceback and a traceback when the L{Failure} object was created\
  \ from a\n        pickled L{Failure} and the original exception has no traceback\
  \ or\n        frames.\n        \"\"\"\n        try:\n            1 / 0\n       \
  \ except BaseException:\n            excType, excValue, traceback = sys.exc_info()\n\
  \        f = Failure(excValue, None, traceback)\n        f.cleanFailure()\n    \
  \    f.cleanFailure()\n        self.assertFalse(f.captureVars)\n\n    def test_captureVarsWithTracebackWithFrames(self):\n\
  \        \"\"\"\n        L{Failure.captureVars} is L{True} if L{Failure} is constructed\
  \ with a\n        traceback and a list of frames.\n        \"\"\"\n        f = Failure()\n\
  \        f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\"\
  , \"y\")])]\n        self.assertTrue(f.captureVars)\n\n    def test_captureVarsWithTracebackWithFramesWhenPickled(self):\n\
  \        \"\"\"\n        L{Failure.captureVars} is L{True} if L{Failure} is constructed\
  \ with a\n        traceback and a list of frames when the L{Failure} object was\
  \ created\n        from a pickled L{Failure}.\n        \"\"\"\n        f = Failure()\n\
  \        f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\"\
  , \"y\")])]\n        pf = pickle.loads(pickle.dumps(f))\n        self.assertTrue(pf.captureVars)\n\
  \n    def test_captureVarsWithTracebackWithFramesWhenNoTraceback(self):\n      \
  \  \"\"\"\n        L{Failure.captureVars} is L{True} if L{Failure} is constructed\
  \ with a\n        traceback and a list of frames when the L{Failure} object was\
  \ created\n        from a pickled L{Failure} and the original exception has no traceback.\n\
  \        \"\"\"\n        f = Failure()\n        f.frames = [(\"f1\", __file__, 1,\
  \ [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n        f.cleanFailure()\n  \
  \      pf = pickle.loads(pickle.dumps(f))\n        self.assertTrue(pf.captureVars)\n\
  \n    def test_captureVarsWithTracebackWithFramesWhenNoTracebackOrFrames(self):\n\
  \        \"\"\"\n        L{Failure.captureVars} is L{False} if L{Failure} is constructed\
  \ with a\n        traceback and a list of frames when the L{Failure} object was\
  \ created\n        from a pickled L{Failure} and the original exception has no traceback\
  \ or\n        frames.\n        \"\"\"\n        f = Failure()\n        f.frames =\
  \ [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n     \
  \   f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n        pf.cleanFailure()\n\
  \        self.assertFalse(pf.captureVars)\n\n    def test_captureVarsWithTracebackWithFramesWhenPickledWithoutTraceback(self):\n\
  \        \"\"\"\n        L{Failure.captureVars} is L{True} if L{Failure} is constructed\
  \ with a\n        traceback and a list of frames when the L{Failure} object was\
  \ created\n        from a pickled L{Failure} and the original exception has no traceback.\n\
  \        \"\"\"\n        f = Failure()\n        f.frames = [(\"f1\", __file__, 1,\
  \ [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n        f.cleanFailure()\n  \
  \      pf = pickle.loads(pickle.dumps(f))\n        self.assertTrue(pf.captureVars)\n\
  \n    def test_captureVarsWithTracebackWithFramesWhenPickledWithoutTracebackOrFrames(self):\n\
  \        \"\"\"\n        L{Failure.captureVars} is L{False} if L{Failure} is constructed\
  \ with a\n        traceback and a list of frames when the L{Failure} object was\
  \ created\n        from a pickled L{Failure} and the original exception has no traceback\
  \ or\n        frames.\n        \"\"\"\n        f = Failure()\n        f.frames =\
  \ [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n     \
  \   f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n        pf.cleanFailure()\n\
  \        self.assertFalse(pf.captureVars)\n\n    def test_captureVarsWithTracebackWithFramesWhenPickledWithoutTracebackOrFramesOrFrames(self):\n\
  \        \"\"\"\n        L{Failure.captureVars} is L{False} if L{Failure} is constructed\
  \ with a\n        traceback and a list of frames when the L{Failure} object was\
  \ created\n        from a pickled L{Failure} and the original exception has no traceback\
  \ or\n        frames or frames.\n        \"\"\"\n        f = Failure()\n       \
  \ f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\", \"y\"\
  )])]\n        f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n   \
  \     pf.cleanFailure()\n        pf.cleanFailure()\n        self.assertFalse(pf.captureVars)\n\
  \n    def test_framesIfNoCaptureVarsWithTraceback(self):\n        \"\"\"\n     \
  \   L{Failure.frames} is empty if L{Failure} is constructed with a\n        traceback\
  \ and C{captureVars} is L{False}.\n        \"\"\"\n        try:\n            1 /\
  \ 0\n        except BaseException:\n            excType, excValue, traceback = sys.exc_info()\n\
  \        f = Failure(excValue, None, traceback, captureVars=False)\n        self.assertEqual(f.frames,\
  \ [])\n\n    def test_framesIfCaptureVarsWithTraceback(self):\n        \"\"\"\n\
  \        L{Failure.frames} is not empty if L{Failure} is constructed with a\n  \
  \      traceback and C{captureVars} is L{True}.\n        \"\"\"\n        try:\n\
  \            1 / 0\n        except BaseException:\n            excType, excValue,\
  \ traceback = sys.exc_info()\n        f = Failure(excValue, None, traceback, captureVars=True)\n\
  \        self.assertNotEqual(f.frames, [])\n\n    def test_framesIfNoCaptureVarsWithTracebackWhenPickled(self):\n\
  \        \"\"\"\n        L{Failure.frames} is empty if L{Failure} is constructed\
  \ with a\n        traceback and C{captureVars} is L{False} when the L{Failure} object\
  \ was\n        created from a pickled L{Failure}.\n        \"\"\"\n        try:\n\
  \            1 / 0\n        except BaseException:\n            excType, excValue,\
  \ traceback = sys.exc_info()\n        f = Failure(excValue, None, traceback, captureVars=False)\n\
  \        pf = pickle.loads(pickle.dumps(f))\n        self.assertEqual(pf.frames,\
  \ [])\n\n    def test_framesIfCaptureVarsWithTracebackWhenPickled(self):\n     \
  \   \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed\
  \ with a\n        traceback and C{captureVars} is L{True} when the L{Failure} object\
  \ was\n        created from a pickled L{Failure}.\n        \"\"\"\n        try:\n\
  \            1 / 0\n        except BaseException:\n            excType, excValue,\
  \ traceback = sys.exc_info()\n        f = Failure(excValue, None, traceback, captureVars=True)\n\
  \        pf = pickle.loads(pickle.dumps(f))\n        self.assertNotEqual(pf.frames,\
  \ [])\n\n    def test_framesIfNoCaptureVarsWithFrames(self):\n        \"\"\"\n \
  \       L{Failure.frames} is empty if L{Failure} is constructed with a list of\n\
  \        frames and C{captureVars} is L{False}.\n        \"\"\"\n        f = Failure(captureVars=False)\n\
  \        f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\"\
  , \"y\")])]\n        self.assertEqual(f.frames, [])\n\n    def test_framesIfCaptureVarsWithFrames(self):\n\
  \        \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed\
  \ with a list\n        of frames and C{captureVars} is L{True}.\n        \"\"\"\n\
  \        f = Failure(captureVars=True)\n        f.frames = [(\"f1\", __file__, 1,\
  \ [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n        self.assertNotEqual(f.frames,\
  \ [])\n\n    def test_framesIfNoCaptureVarsWithFramesWhenPickled(self):\n      \
  \  \"\"\"\n        L{Failure.frames} is empty if L{Failure} is constructed with\
  \ a list of\n        frames and C{captureVars} is L{False} when the L{Failure} object\
  \ was\n        created from a pickled L{Failure}.\n        \"\"\"\n        f = Failure(captureVars=False)\n\
  \        f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\"\
  , \"y\")])]\n        pf = pickle.loads(pickle.dumps(f))\n        self.assertEqual(pf.frames,\
  \ [])\n\n    def test_framesIfCaptureVarsWithFramesWhenPickled(self):\n        \"\
  \"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed with a\
  \ list\n        of frames and C{captureVars} is L{True} when the L{Failure} object\
  \ was\n        created from a pickled L{Failure}.\n        \"\"\"\n        f = Failure(captureVars=True)\n\
  \        f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\"\
  , \"y\")])]\n        pf = pickle.loads(pickle.dumps(f))\n        self.assertNotEqual(pf.frames,\
  \ [])\n\n    def test_framesIfNoCaptureVarsWithFramesWhenPickledWithoutTraceback(self):\n\
  \        \"\"\"\n        L{Failure.frames} is empty if L{Failure} is constructed\
  \ with a list of\n        frames and C{captureVars} is L{False} when the L{Failure}\
  \ object was\n        created from a pickled L{Failure} and the original exception\
  \ has no\n        traceback.\n        \"\"\"\n        f = Failure(captureVars=False)\n\
  \        f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\"\
  , \"y\")])]\n        f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertEqual(pf.frames, [])\n\n    def test_framesIfCaptureVarsWithFramesWhenPickledWithoutTraceback(self):\n\
  \        \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed\
  \ with a list\n        of frames and C{captureVars} is L{True} when the L{Failure}\
  \ object was\n        created from a pickled L{Failure} and the original exception\
  \ has no\n        traceback.\n        \"\"\"\n        f = Failure(captureVars=True)\n\
  \        f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\"\
  , \"y\")])]\n        f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertNotEqual(pf.frames, [])\n\n    def test_framesIfNoCaptureVarsWithFramesWhenPickledWithoutTracebackOrFrames(self):\n\
  \        \"\"\"\n        L{Failure.frames} is empty if L{Failure} is constructed\
  \ with a list of\n        frames and C{captureVars} is L{False} when the L{Failure}\
  \ object was\n        created from a pickled L{Failure} and the original exception\
  \ has no\n        traceback or frames.\n        \"\"\"\n        f = Failure(captureVars=False)\n\
  \        f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\"\
  , \"y\")])]\n        f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        pf.cleanFailure()\n        self.assertEqual(pf.frames, [])\n\n    def test_framesIfCaptureVarsWithFramesWhenPickledWithoutTracebackOrFrames(self):\n\
  \        \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed\
  \ with a list\n        of frames and C{captureVars} is L{True} when the L{Failure}\
  \ object was\n        created from a pickled L{Failure} and the original exception\
  \ has no\n        traceback or frames.\n        \"\"\"\n        f = Failure(captureVars=True)\n\
  \        f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\"\
  , \"y\")])]\n        f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        pf.cleanFailure()\n        self.assertNotEqual(pf.frames, [])\n\n    def\
  \ test_framesIfNoCaptureVarsWithFramesWhenNoTraceback(self):\n        \"\"\"\n \
  \       L{Failure.frames} is empty if L{Failure} is constructed with a list of\n\
  \        frames and C{captureVars} is L{False} when the L{Failure} object was\n\
  \        created from a pickled L{Failure} and the original exception has no\n \
  \       traceback.\n        \"\"\"\n        f = Failure(captureVars=False)\n   \
  \     f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\", \"\
  y\")])]\n        f.cleanFailure()\n        self.assertEqual(f.frames, [])\n\n  \
  \  def test_framesIfCaptureVarsWithFramesWhenNoTraceback(self):\n        \"\"\"\n\
  \        L{Failure.frames} is not empty if L{Failure} is constructed with a list\n\
  \        of frames and C{captureVars} is L{True} when the L{Failure} object was\n\
  \        created from a pickled L{Failure} and the original exception has no\n \
  \       traceback.\n        \"\"\"\n        f = Failure(captureVars=True)\n    \
  \    f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\", \"\
  y\")])]\n        f.cleanFailure()\n        self.assertNotEqual(f.frames, [])\n\n\
  \    def test_framesIfNoCaptureVarsWithFramesWhenNoTracebackOrFrames(self):\n  \
  \      \"\"\"\n        L{Failure.frames} is empty if L{Failure} is constructed with\
  \ a list of\n        frames and C{captureVars} is L{False} when the L{Failure} object\
  \ was\n        created from a pickled L{Failure} and the original exception has\
  \ no\n        traceback or frames.\n        \"\"\"\n        f = Failure(captureVars=False)\n\
  \        f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\"\
  , \"y\")])]\n        f.cleanFailure()\n        f.cleanFailure()\n        self.assertEqual(f.frames,\
  \ [])\n\n    def test_framesIfCaptureVarsWithFramesWhenNoTracebackOrFrames(self):\n\
  \        \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed\
  \ with a list\n        of frames and C{captureVars} is L{True} when the L{Failure}\
  \ object was\n        created from a pickled L{Failure} and the original exception\
  \ has no\n        traceback or frames.\n        \"\"\"\n        f = Failure(captureVars=True)\n\
  \        f.frames = [(\"f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\"\
  , \"y\")])]\n        f.cleanFailure()\n        f.cleanFailure()\n        self.assertNotEqual(f.frames,\
  \ [])\n\n    def test_framesIfNoCaptureVarsWithTracebackWithTraceback(self):\n \
  \       \"\"\"\n        L{Failure.frames} is empty if L{Failure} is constructed\
  \ with a\n        traceback and a traceback and C{captureVars} is L{False}.\n  \
  \      \"\"\"\n        try:\n            1 / 0\n        except BaseException:\n\
  \            excType, excValue, traceback = sys.exc_info()\n        f = Failure(excValue,\
  \ None, traceback, captureVars=False)\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertEqual(pf.frames, [])\n\n    def test_framesIfCaptureVarsWithTracebackWithTraceback(self):\n\
  \        \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed\
  \ with a\n        traceback and a traceback and C{captureVars} is L{True}.\n   \
  \     \"\"\"\n        try:\n            1 / 0\n        except BaseException:\n \
  \           excType, excValue, traceback = sys.exc_info()\n        f = Failure(excValue,\
  \ None, traceback, captureVars=True)\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertNotEqual(pf.frames, [])\n\n    def test_framesIfNoCaptureVarsWithTracebackWithTracebackWhenPickled(self):\n\
  \        \"\"\"\n        L{Failure.frames} is empty if L{Failure} is constructed\
  \ with a\n        traceback and a traceback and C{captureVars} is L{False} when\
  \ the\n        L{Failure} object was created from a pickled L{Failure}.\n      \
  \  \"\"\"\n        try:\n            1 / 0\n        except BaseException:\n    \
  \        excType, excValue, traceback = sys.exc_info()\n        f = Failure(excValue,\
  \ None, traceback, captureVars=False)\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertEqual(pf.frames, [])\n\n    def test_framesIfCaptureVarsWithTracebackWithTracebackWhenPickled(self):\n\
  \        \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed\
  \ with a\n        traceback and a traceback and C{captureVars} is L{True} when the\n\
  \        L{Failure} object was created from a pickled L{Failure}.\n        \"\"\"\
  \n        try:\n            1 / 0\n        except BaseException:\n            excType,\
  \ excValue, traceback = sys.exc_info()\n        f = Failure(excValue, None, traceback,\
  \ captureVars=True)\n        pf = pickle.loads(pickle.dumps(f))\n        self.assertNotEqual(pf.frames,\
  \ [])\n\n    def test_framesIfNoCaptureVarsWithTracebackWithTracebackWhenPickledWithoutTraceback(\n\
  \        self,\n    ):\n        \"\"\"\n        L{Failure.frames} is empty if L{Failure}\
  \ is constructed with a\n        traceback and a traceback and C{captureVars} is\
  \ L{False} when the\n        L{Failure} object was created from a pickled L{Failure}\
  \ and the\n        original exception has no traceback.\n        \"\"\"\n      \
  \  try:\n            1 / 0\n        except BaseException:\n            excType,\
  \ excValue, traceback = sys.exc_info()\n        f = Failure(excValue, None, traceback,\
  \ captureVars=False)\n        f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertEqual(pf.frames, [])\n\n    def test_framesIfCaptureVarsWithTracebackWithTracebackWhenPickledWithoutTraceback(\n\
  \        self,\n    ):\n        \"\"\"\n        L{Failure.frames} is not empty if\
  \ L{Failure} is constructed with a\n        traceback and a traceback and C{captureVars}\
  \ is L{True} when the\n        L{Failure} object was created from a pickled L{Failure}\
  \ and the\n        original exception has no traceback.\n        \"\"\"\n      \
  \  try:\n            1 / 0\n        except BaseException:\n            excType,\
  \ excValue, traceback = sys.exc_info()\n        f = Failure(excValue, None, traceback,\
  \ captureVars=True)\n        f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertNotEqual(pf.frames, [])\n\n    def test_framesIfNoCaptureVarsWithTracebackWithTracebackWhenPickledWithoutTracebackOrFrames(\n\
  \        self,\n    ):\n        \"\"\"\n        L{Failure.frames} is empty if L{Failure}\
  \ is constructed with a traceback\n        and a traceback and C{captureVars} is\
  \ L{False} when the L{Failure}\n        object was created from a pickled L{Failure}\
  \ and the original exception\n        has no traceback or frames.\n        \"\"\"\
  \n        try:\n            1 / 0\n        except BaseException:\n            excType,\
  \ excValue, traceback = sys.exc_info()\n        f = Failure(excValue, None, traceback,\
  \ captureVars=False)\n        f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        pf.cleanFailure()\n        self.assertEqual(pf.frames, [])\n\n    def test_framesIfCaptureVarsWithTracebackWithTracebackWhenPickledWithoutTracebackOrFrames(\n\
  \        self,\n    ):\n        \"\"\"\n        L{Failure.frames} is not empty if\
  \ L{Failure} is constructed with a\n        traceback and a traceback and C{captureVars}\
  \ is L{True} when the\n        L{Failure} object was created from a pickled L{Failure}\
  \ and the\n        original exception has no traceback or frames.\n        \"\"\"\
  \n        try:\n            1 / 0\n        except BaseException:\n            excType,\
  \ excValue, traceback = sys.exc_info()\n        f = Failure(excValue, None, traceback,\
  \ captureVars=True)\n        f.cleanFailure()\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        pf.cleanFailure()\n        self.assertNotEqual(pf.frames, [])\n\n    def\
  \ test_framesIfNoCaptureVarsWithTracebackWithTracebackWhenNoTraceback(self):\n \
  \       \"\"\"\n        L{Failure.frames} is empty if L{Failure} is constructed\
  \ with a traceback\n        and a traceback and C{captureVars} is L{False} when\
  \ the L{Failure}\n        object was created from a pickled L{Failure} and the original\
  \ exception\n        has no traceback.\n        \"\"\"\n        try:\n         \
  \   1 / 0\n        except BaseException:\n            excType, excValue, traceback\
  \ = sys.exc_info()\n        f = Failure(excValue, None, traceback, captureVars=False)\n\
  \        f.cleanFailure()\n        self.assertEqual(f.frames, [])\n\n    def test_framesIfCaptureVarsWithTracebackWithTracebackWhenNoTraceback(self):\n\
  \        \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed\
  \ with a\n        traceback and a traceback and C{captureVars} is L{True} when the\n\
  \        L{Failure} object was created from a pickled L{Failure} and the\n     \
  \   original exception has no traceback.\n        \"\"\"\n        try:\n       \
  \     1 / 0\n        except BaseException:\n            excType, excValue, traceback\
  \ = sys.exc_info()\n        f = Failure(excValue, None, traceback, captureVars=True)\n\
  \        f.cleanFailure()\n        self.assertNotEqual(f.frames, [])\n\n    def\
  \ test_framesIfNoCaptureVarsWithTracebackWithTracebackWhenNoTracebackOrFrames(\n\
  \        self,\n    ):\n        \"\"\"\n        L{Failure.frames} is empty if L{Failure}\
  \ is constructed with a traceback\n        and a traceback and C{captureVars} is\
  \ L{False} when the L{Failure}\n        object was created from a pickled L{Failure}\
  \ and the original exception\n        has no traceback or frames.\n        \"\"\"\
  \n        try:\n            1 / 0\n        except BaseException:\n            excType,\
  \ excValue, traceback = sys.exc_info()\n        f = Failure(excValue, None, traceback,\
  \ captureVars=False)\n        f.cleanFailure()\n        f.cleanFailure()\n     \
  \   self.assertEqual(f.frames, [])\n\n    def test_framesIfCaptureVarsWithTracebackWithTracebackWhenNoTracebackOrFrames(\n\
  \        self,\n    ):\n        \"\"\"\n        L{Failure.frames} is not empty if\
  \ L{Failure} is constructed with a\n        traceback and a traceback and C{captureVars}\
  \ is L{True} when the\n        L{Failure} object was created from a pickled L{Failure}\
  \ and the\n        original exception has no traceback or frames.\n        \"\"\"\
  \n        try:\n            1 / 0\n        except BaseException:\n            excType,\
  \ excValue, traceback = sys.exc_info()\n        f = Failure(excValue, None, traceback,\
  \ captureVars=True)\n        f.cleanFailure()\n        f.cleanFailure()\n      \
  \  self.assertNotEqual(f.frames, [])\n\n    def test_framesIfNoCaptureVarsWithTracebackWithFrames(self):\n\
  \        \"\"\"\n        L{Failure.frames} is empty if L{Failure} is constructed\
  \ with a traceback\n        and a list of frames and C{captureVars} is L{False}.\n\
  \        \"\"\"\n        f = Failure(captureVars=False)\n        f.frames = [(\"\
  f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n        self.assertEqual(f.frames,\
  \ [])\n\n    def test_framesIfCaptureVarsWithTracebackWithFrames(self):\n      \
  \  \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed with\
  \ a\n        traceback and a list of frames and C{captureVars} is L{True}.\n   \
  \     \"\"\"\n        f = Failure(captureVars=True)\n        f.frames = [(\"f1\"\
  , __file__, 1, [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n        self.assertNotEqual(f.frames,\
  \ [])\n\n    def test_framesIfNoCaptureVarsWithTracebackWithFramesWhenPickled(self):\n\
  \        \"\"\"\n        L{Failure.frames} is empty if L{Failure} is constructed\
  \ with a traceback\n        and a list of frames and C{captureVars} is L{False}\
  \ when the L{Failure}\n        object was created from a pickled L{Failure}.\n \
  \       \"\"\"\n        f = Failure(captureVars=False)\n        f.frames = [(\"\
  f1\", __file__, 1, [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n        pf =\
  \ pickle.loads(pickle.dumps(f))\n        self.assertEqual(pf.frames, [])\n\n   \
  \ def test_framesIfCaptureVarsWithTracebackWithFramesWhenPickled(self):\n      \
  \  \"\"\"\n        L{Failure.frames} is not empty if L{Failure} is constructed with\
  \ a\n        traceback and a list of frames and C{captureVars} is L{True} when the\n\
  \        L{Failure} object was created from a pickled L{Failure}.\n        \"\"\"\
  \n        f = Failure(captureVars=True)\n        f.frames = [(\"f1\", __file__,\
  \ 1, [(\"local1\", \"x\")], [(\"global1\", \"y\")])]\n        pf = pickle.loads(pickle.dumps(f))\n\
  \        self.assertNotEqual(pf.frames, [])\n\n    def test_framesIfNoCaptureVarsWithTracebackWithFramesWhenPickledWithoutTraceback(\n\
  \        self,\n    ):\n        \"\"\"\n        L{Failure.frames} is empty if L{Failure}\
  \ is constructed with a traceback\n        and a list of frames and C{captureVars}\
  \ is L{False} when the L{Failure}\n        object was created from a pickled L{Failure}\
  \ and the original exception\n        has no traceback.\n        \"\"\"\n      \
  \  f = Failure(captureVars=False)\n        f.frames = [(\"f1\", __file__, 1, [(\"\
  local1\", \"x\")], [(\"global1\", \"y\")])]\n        f.cleanFailure()\n        pf\
  \ = pickle.loads(pickle.dumps(f))\n        self.assertEqual(pf.frames, [])\n\n \
  \   def test_framesIfCaptureVarsWithTracebackWithFramesWhenPickledWithoutTraceback(\n\
  \        self,\n    ):\n        \"\"\"\n        L{Failure.frames} is not empty if\
  \ L{Failure} is constructed with a\n        traceback and a list of frames and C{captureVars}\
  \ is L{True} when the\n        L{Failure} object was created from a pickled L{Failure}\
  \ and the original\n        exception has no traceback.\n        \"\"\"\n      \
  \  f = Failure(captureVars=True)\n        f.frames = [(\"f1\", __file__, 1, [(\"\
  local1\", \"x\")], [(\"global1\", \"y\")])]\n        f.cleanFailure()\n        pf\
  \ = pickle.loads(pickle.dumps(f))\n        self.assertNotEqual(pf.frames, [])\n\n\
  \    def test_framesIfNo"
